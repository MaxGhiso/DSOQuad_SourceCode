//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   06/May/2011  11:15:38 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\Users\Administrator\Desktop\mini DSO             /
//                       download\APP_V2.32\APP_V2.32\source\Files.c         /
//    Command line    =  "C:\Users\Administrator\Desktop\mini DSO            /
//                       download\APP_V2.32\APP_V2.32\source\Files.c" -lA    /
//                       "C:\Users\Administrator\Desktop\mini DSO            /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\List\"  /
//                       -o "C:\Users\Administrator\Desktop\mini DSO         /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\Obj\"   /
//                       -s9 --debug --cpu_mode thumb --endian little --cpu  /
//                       cortex-M3 --stack_align 4 --fpu None --dlib_config  /
//                       "E:\IARWorkBench(Cracked)\Embedded Workbench 4.0    /
//                       Evaluation\ARM\LIB\dl7mptnnl8f.h" -I                /
//                       "C:\Users\Administrator\Desktop\mini DSO            /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\..\..\F /
//                       WLib\inc\" -I "C:\Users\Administrator\Desktop\mini  /
//                       DSO download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\..\ /
//                       ..\USBLib\inc\" -I "C:\Users\Administrator\Desktop\ /
//                       mini DSO download\APP_V2.32\APP_V2.32\IAR_V4_Prpjec /
//                       t\..\include\" -I "E:\IARWorkBench(Cracked)\Embedde /
//                       d Workbench 4.0 Evaluation\ARM\INC\"                /
//                       --inline_threshold=16                               /
//    List file       =  C:\Users\Administrator\Desktop\mini DSO             /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\List\Fi /
//                       les.s79                                             /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Files

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable10 EQU 0
??DataTable11 EQU 0
??DataTable13 EQU 0
??DataTable14 EQU 0
??DataTable15 EQU 0
??DataTable16 EQU 0
??DataTable17 EQU 0
??DataTable18 EQU 0
??DataTable19 EQU 0
??DataTable2 EQU 0
??DataTable20 EQU 0
??DataTable3 EQU 0
??DataTable4 EQU 0
??DataTable6 EQU 0
??DataTable9 EQU 0
        MULTWEAK ??Print_Clk??rT
        MULTWEAK ??__Disk_Buff_RD??rT
        MULTWEAK ??__Disk_Buff_WR??rT
        MULTWEAK ??__LCD_GetPixl??rT
        MULTWEAK ??__Param_Area_RD??rT
        MULTWEAK ??__Param_Area_WR??rT
        MULTWEAK ??__Point_SCR??rT
        MULTWEAK ??memset??rT
        MULTWEAK ??u8ToDec3??rT
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC BMP_Color
        PUBLIC ClusterNum
        PUBLIC Color_Num
        FUNCTION Color_Num,0203H
        PUBLIC Count
        PUBLIC DirSecNum
        PUBLIC DiskStart
        PUBLIC FAT_Size16
        PUBLIC FAT_Size32
        PUBLIC FileBuff
        PUBLIC File_Addr
        PUBLIC File_Size
        PUBLIC Hidden_Sec
        PUBLIC Load_Dat
        FUNCTION Load_Dat,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC Load_Parameter
        FUNCTION Load_Parameter,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC MaxNum
        PUBLIC Offset
        PUBLIC Open_File
        FUNCTION Open_File,0203H
        LOCFRAME CSTACK, 52, STACK
        PUBLIC Root_Addr
        PUBLIC RsvdSecCnt
        PUBLIC Save_Bmp
        FUNCTION Save_Bmp,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC Save_Dat
        FUNCTION Save_Dat,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Save_Parameter
        FUNCTION Save_Parameter,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC SecBuff
        PUBLIC SecPerClus
        PUBLIC SectorSize
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Print_Clk           SYMBOL "Print_Clk"
__Disk_Buff_RD      SYMBOL "__Disk_Buff_RD"
__Disk_Buff_WR      SYMBOL "__Disk_Buff_WR"
__LCD_GetPixl       SYMBOL "__LCD_GetPixl"
__Param_Area_RD     SYMBOL "__Param_Area_RD"
__Param_Area_WR     SYMBOL "__Param_Area_WR"
__Point_SCR         SYMBOL "__Point_SCR"
memset              SYMBOL "memset"
u8ToDec3            SYMBOL "u8ToDec3"
??Print_Clk??rT     SYMBOL "??rT", Print_Clk
??__Disk_Buff_RD??rT SYMBOL "??rT", __Disk_Buff_RD
??__Disk_Buff_WR??rT SYMBOL "??rT", __Disk_Buff_WR
??__LCD_GetPixl??rT SYMBOL "??rT", __LCD_GetPixl
??__Param_Area_RD??rT SYMBOL "??rT", __Param_Area_RD
??__Param_Area_WR??rT SYMBOL "??rT", __Param_Area_WR
??__Point_SCR??rT   SYMBOL "??rT", __Point_SCR
??memset??rT        SYMBOL "??rT", memset
??u8ToDec3??rT      SYMBOL "??rT", u8ToDec3

        EXTERN Current
        EXTERN Detail
        EXTERN Ka1
        EXTERN Ka2
        EXTERN Ka3
        EXTERN Kb1
        EXTERN Kb2
        EXTERN Kb3
        EXTERN Meter
        EXTERN Print_Clk
        FUNCTION Print_Clk,0202H
        EXTERN Title
        EXTERN TrackBuff
        EXTERN V_Trigg
        EXTERN __Disk_Buff_RD
        FUNCTION __Disk_Buff_RD,0202H
        EXTERN __Disk_Buff_WR
        FUNCTION __Disk_Buff_WR,0202H
        EXTERN __LCD_GetPixl
        FUNCTION __LCD_GetPixl,0202H
        EXTERN __Param_Area_RD
        FUNCTION __Param_Area_RD,0202H
        EXTERN __Param_Area_WR
        FUNCTION __Param_Area_WR,0202H
        EXTERN __Point_SCR
        FUNCTION __Point_SCR,0202H
        EXTERN memset
        FUNCTION memset,010202H
        EXTERN u8ToDec3
        FUNCTION u8ToDec3,0202H

// C:\Users\Administrator\Desktop\mini DSO download\APP_V2.32\APP_V2.32\source\Files.c
//    1 /********************* (C) COPYRIGHT 2010 e-Design Co.,Ltd. ********************
//    2  File Name : file.c  
//    3  Version   : DS203_APP Ver 2.3x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include <string.h>
//    6 #include "Interrupt.h"
//    7 #include "Function.h"
//    8 #include "Process.h"
//    9 #include "BIOS.h"
//   10 #include "File.h"
//   11 #include "Draw.h"
//   12 #include "Menu.h"
//   13 
//   14 /*******************************************************************************
//   15 
//   16 U盘导引扇区内容：0x00      如果为 0xEB 或 0xE9 则表示该扇区同时也是逻辑分区零扇区
//   17                  0x01C6~0x01C9 4字节为逻辑分区开始位置（高位在后）  DiskStart    
//   18 
//   19 分区零扇区内容：0x000B,0x000C 2字节该盘扇区字节长度（高位在后）    SectorsLen   
//   20                        0x000D 1字节该盘每簇的扇区数（2的整数次幂） SecPerClus   
//   21                 0x000E,0x000F 2字节该盘的保留扇区数（高位在后）    RsvdSecCnt    
//   22 （FAT16）       0x0016,0x0017 2字节 FAT占用的扇区数（高位在后）    FAT_Size16   FAT32时该值为 0x0000
//   23                 0x001C~0x001F 4字节该盘的隐藏扇区数（高位在后）    Hidden_Sec    
//   24 （FAT32）       0x0024,0x0025 2字节 FAT占用的扇区数（高位在后）    FAT_Size32   
//   25 
//   26 FAT表的长度(length of FAT)   ：FAT_LEN   = FAT_Size16 ×SectorsLen           
//   27 FAT1开始扇区(addr of FAT1)  ：FAT1_Sect = DiskStart + RsvdSecCnt           
//   28 FAT2开始扇区 (addr of FAT2) ：FAT2_Sect = FAT1_Sect + FAT_Size16           
//   29 根目录开始扇区(Section of root catalogue)：Root_Sect = FAT2_Sect + FAT_Size16           
//   30 根目录开始地址(addr of root catalogue)：Root_Addr = Root_Sect ×SectorsLen   
//   31 
//   32 根目录扇区内容：        Root_Addr + 0x0020 开始，每条目录项长度为 0x20，//Each catalogue length is 0x20
//   33 (Root catalogue details:)FAT16根目录占用扇区数 SecPerRoot = 0x20 //Sections for root catalogue of fat16
//   34                           FAT32根目录占用扇区数 SecPerRoot = 0x01 × SecPerClus //Sections for root catalogue of fat32
//   35 
//   36 目录项中的内容：      0x00~0x07 8字节文件名  //8 bytes filename 
//   37 (catalogue details:)  0x08~0x0A 3字节扩展名   //3 bytes extroname
//   38                       0x16,0x17 2字节最近修改时间（ = Hour << 11 + Minute << 5 + Second >> 1 ）//2 bytes modified time
//   39                       0x18,0x19 2字节最近修改日期（ =（ Year - 1980 ）<< 9 + Month << 5 + Day ）//2 bytes modified date
//   40         （FAT32）     0x14,0x15 文件开始簇号Bit 16~31（高位字节在后）Cluster_Hi//Cluster_hi for files
//   41         （FAT16）     0x1A,0x1B 文件开始簇号Bit  0~15（高位字节在后）Cluster     0x12E5//Cluster_low for files
//   42                       0x1C-0x1F 4字节的文件字节长度 （高位在后）//4 bytes file length
//   43                   
//   44 文件开始地址  ：File_Addr =（ Root_Sect + SecPerRoot +（Cluster -0x02）×SecPerClus ）×Sectors_LEN
//   45 
//   46 *******************************************************************************/
//   47 u32 DiskStart, Hidden_Sec, Root_Addr, ClusterNum, File_Addr, File_Size; 

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   48 u16 RsvdSecCnt, SectorSize, FAT_Size16, FAT_Size32; 
FAT_Size32:
        DS8 2

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   49 u16 SecPerClus, /*DirFliePtr, DirFlieSec, */DirSecNum, MaxNum;
MaxNum:
        DS8 2

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   50 u8  SecBuff[512];
SecBuff:
        DS8 512
//   51 u8  FileBuff[1200];

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   52 u32 Offset, Count;
Offset:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
Count:
        DS8 4

        RSEG DATA_I:DATA:SORT:NOROOT(2)
RsvdSecCnt:
        DS8 2
        REQUIRE `?<Initializer for RsvdSecCnt>`
SectorSize:
        DS8 2
        REQUIRE `?<Initializer for SectorSize>`
FAT_Size16:
        DS8 2
        REQUIRE `?<Initializer for FAT_Size16>`
SecPerClus:
        DS8 2
        REQUIRE `?<Initializer for SecPerClus>`
DirSecNum:
        DS8 2
        REQUIRE `?<Initializer for DirSecNum>`
        DS8 2
//   53 u16 BMP_Color[16] = { WHT,  CYAN,  CYAN_,  YEL,   
BMP_Color:
        DS8 32
        REQUIRE `?<Initializer for BMP_Color>`
DiskStart:
        DS8 4
        REQUIRE `?<Initializer for DiskStart>`
Hidden_Sec:
        DS8 4
        REQUIRE `?<Initializer for Hidden_Sec>`
Root_Addr:
        DS8 4
        REQUIRE `?<Initializer for Root_Addr>`
ClusterNum:
        DS8 4
        REQUIRE `?<Initializer for ClusterNum>`
File_Addr:
        DS8 4
        REQUIRE `?<Initializer for File_Addr>`
File_Size:
        DS8 4
        REQUIRE `?<Initializer for File_Size>`
FileBuff:
        DS8 1200
        REQUIRE `?<Initializer for FileBuff>`
//   54                       YEL_, PURPL, PURPL_, GRN,    
//   55                       GRN_, GRAY,  ORANGE, BLUE,    
//   56                       RED,  BLACK, BLACK,  BLACK,}; 
//   57 
//   58   
//   59 #define WHT        0xFFFF
//   60 #define CYAN       0xFFE0
//   61 #define CYAN_      0xBDE0
//   62 #define YEL        0x07FF
//   63 #define YEL_       0x05F7
//   64 #define PURPL      0xF81F
//   65 #define PURPL_     0xB817
//   66 #define GRN        0x07E0
//   67 #define GRN_       0x05E0
//   68 #define GRAY       0x7BEF   
//   69 #define ORANGE     0x051F
//   70 #define BLUE       0xF800
//   71 #define RED        0x001F
//   72 #define BLACK      0x0000
//   73 
//   74 /*******************************************************************************
//   75  打开指定扩展名的文件            输入：文件扩展名             返回值：0x00=成功 
//   76 Open the files with specified extro name         INPUT:extroname     RETURN VALUE: 0x00=SUCCESS
//   77 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function Open_File
        THUMB
//   78 u8 Open_File(u8 FileNum, u8 *ExtName)
//   79 {
//   80   u8 i, j, k; 
//   81   u16 SectorCnt;
//   82   u8 FileName[12]="FILE    BMP", Num[4];
Open_File:
        LDR.N    R2,??Open_File_0  ;; `?<Constant "FILE    BMP">`
        PUSH     {R4-R6,R8,R9,R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        SUB      SP,SP,#+16
        CFI CFA R13+44
        MOVS     R4,R1
        ADD      R1,SP,#+4
        MOVS     R5,#+12
??Open_File_1:
        SUBS     R5,R5,#+1
        LDRB     R3,[R2, R5]
        STRB     R3,[R1, R5]
        BNE.N    ??Open_File_1
//   83   
//   84                // ------------生成文件名------------ //   
//   85               //------------Generate file name--------//
//   86   u8ToDec3(Num, FileNum);
//   87   FileName[4] = Num[0];
//   88   FileName[5] = Num[1];
//   89   FileName[6] = Num[2];
//   90   FileName[8] = ExtName[0];
//   91   FileName[9] = ExtName[1];
//   92   FileName[10]= ExtName[2];
//   93   
//   94                // ------------读取U盘参数----------- //  
//   95                  //------------Read the parameter of USB disk---//
//   96   DiskStart =0;
//   97   DirSecNum = 0x20;             
//   98   __Disk_Buff_RD(SecBuff, 0, 256);
        LDR.N    R5,??DataTable7  ;; SecBuff
        MOVS     R1,R0
        MOV      R0,SP
        _BLF     u8ToDec3,??u8ToDec3??rT
        LDRB     R0,[SP, #+0]
        MOVS     R1,#+0
        STRB     R0,[SP, #+8]
        LDRB     R0,[SP, #+1]
        STRB     R0,[SP, #+9]
        LDRB     R0,[SP, #+2]
        STRB     R0,[SP, #+10]
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+12]
        LDRB     R0,[R4, #+1]
        STRB     R0,[SP, #+13]
        LDRB     R0,[R4, #+2]
        LDR.N    R4,??Open_File_0+0x4  ;; RsvdSecCnt
        STRB     R0,[SP, #+14]
        MOVS     R0,#+0
        MOV      R8,R0
        STR      R8,[R4, #+44]
        MOVS     R0,#+32
        STRH     R0,[R4, #+8]
        LSLS     R2,R0,#+3
        MOVS     R0,R5
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//   99   SectorSize =(SecBuff[0x0C]<<8)+(SecBuff[0x0B]);     // 0200
        LDRB     R0,[R5, #+12]
        LDRB     R1,[R5, #+11]
//  100   SecPerClus = SecBuff[0x0D];                            // 01
//  101   RsvdSecCnt =(SecBuff[0x0F]<<8)+(SecBuff[0x0E]);     // 0008
//  102   FAT_Size16 =(SecBuff[0x17]<<8)+(SecBuff[0x16]);     // 000C
//  103   Hidden_Sec =(SecBuff[0x1F]<<24)+(SecBuff[0x1E]<<16)
//  104     +(SecBuff[0x1D]<<8)+(SecBuff[0x1C]);              // 0000
//  105 
//  106                // ------------读取根目录----------- //  
//  107   //-------------Read the root catalogue------//
//  108   Root_Addr =(DiskStart + RsvdSecCnt + 2*FAT_Size16)*SectorSize; // 4000 
//  109   __Disk_Buff_RD(SecBuff, Root_Addr, 512);
        MOVS     R2,#+512
//  110 
//  111                // ------------查找文件名----------- //  
//  112         //-------------Seek the file name--------//
//  113   for(SectorCnt =0; SectorCnt < DirSecNum; SectorCnt++){
        MOV      R9,R8
        ADDS     R0,R1,R0, LSL #+8
        LDRB     R1,[R5, #+14]
        STRH     R0,[R4, #+2]
        LDRB     R0,[R5, #+13]
        STRH     R0,[R4, #+6]
        LDRB     R0,[R5, #+15]
        ADDS     R0,R1,R0, LSL #+8
        LDRB     R1,[R5, #+22]
        STRH     R0,[R4, #+0]
        LDRB     R0,[R5, #+23]
        ADDS     R0,R1,R0, LSL #+8
        LDRB     R1,[R5, #+30]
        STRH     R0,[R4, #+4]
        LDRB     R0,[R5, #+31]
        LSLS     R1,R1,#+16
        ADDS     R0,R1,R0, LSL #+24
        LDRB     R1,[R5, #+29]
        ADDS     R0,R0,R1, LSL #+8
        LDRB     R1,[R5, #+28]
        ADDS     R0,R0,R1
        LDRH     R1,[R4, #+0]
        STR      R0,[R4, #+48]
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,R1
        LDRH     R1,[R4, #+4]
        ADDS     R1,R0,R1, LSL #+1
        LDRH     R0,[R4, #+2]
        MULS     R1,R0,R1
        STR      R1,[R4, #+52]
        MOVS     R0,R5
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        B.N      ??Open_File_2
//  114     __Disk_Buff_RD(SecBuff, Root_Addr + SectorCnt*512, 512);
//  115     for(i=0; i<16; i++){
??Open_File_3:
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+16
        BCC.N    ??Open_File_4
        MOV      R0,R9
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        MOV      R9,R0
??Open_File_2:
        LDRH     R1,[R4, #+8]
        CMP      R9,R1
        BCS.N    ??Open_File_5
        LDR      R0,[R4, #+52]
        MOVS     R2,#+512
        ADDS     R1,R0,R9, LSL #+9
        MOVS     R0,R5
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        MOVS     R0,#+0
//  116       if(SecBuff[i*32] == 0xE5)  k = 0xFF;  // 已删除的文件项//Files deleted
??Open_File_4:
        ADDS     R11,R5,R0, LSL #+5
        LDRB     R2,[R11, #+0]
        CMP      R2,#+229
        ITE     NE 
        MOVNE    R2,#+0
        MOVEQ    R2,#+255
//  117       else                       k = 0;     // 正常的文件项 //Files normal
//  118       for(j=0; j<11; j++){
        MOVS     R3,#+0
//  119         if(SecBuff[i*32+j] != FileName[j])  k |= 0xFF; // 
??Open_File_6:
        ADDS     R6,R3,R0, LSL #+5
        LDRB     R6,[R5, R6]
        MOV      R12,R6
        ADD      R6,SP,#+4
        LDRB     R6,[R6, R3]
        CMP      R12,R6
        IT      NE 
        MOVNE    R2,#+255
//  120       }
        ADDS     R3,R3,#+1
        UXTB     R3,R3
        CMP      R3,#+11
        BCC.N    ??Open_File_6
//  121       if(k == 0) {                              // File is found
        CMP      R2,#+0
        BNE.N    ??Open_File_3
//  122         
//  123                // ------计算文件大小及存放地址----- // 
//  124               //-------Cal the file size and address---//
//  125         ClusterNum =((SecBuff[i*32+0x1B]<<8)+(SecBuff[i*32+0x1A])); // 00E5
        LDRB     R0,[R11, #+27]
        LDRB     R1,[R11, #+26]
//  126         File_Addr  = Root_Addr +(DirSecNum +(ClusterNum -2)*SecPerClus)*512;// 4000+(20+(E5-2))*200
        LDRH     R3,[R4, #+6]
        ADDS     R0,R1,R0, LSL #+8
        LDRH     R1,[R4, #+8]
        STR      R0,[R4, #+56]
        LDR      R2,[R4, #+56]
        LDR      R0,[R4, #+52]
        SUBS     R2,R2,#+2
        MLA      R1,R2,R3,R1
        ADDS     R0,R0,R1, LSL #+9
        STR      R0,[R4, #+60]
//  127         File_Size  =((SecBuff[i*32+0x1C])+(SecBuff[i*32+0x1D]<<8)+
//  128                     (SecBuff[i*32+0x1E]<<16)+(SecBuff[i*32+0x1F]<<24));
        LDRB     R1,[R11, #+29]
        LDRB     R0,[R11, #+28]
        ADDS     R0,R0,R1, LSL #+8
        LDRB     R1,[R11, #+30]
        ADDS     R0,R0,R1, LSL #+16
        LDRB     R1,[R11, #+31]
        ADDS     R0,R0,R1, LSL #+24
        STR      R0,[R4, #+64]
//  129         return 0;
        MOVS     R0,#+0
        B.N      ??Open_File_7
//  130       }
//  131     }
//  132   }
//  133   return 0xFF;
??Open_File_5:
        MOVS     R0,#+255
??Open_File_7:
        ADD      SP,SP,#+16
        CFI CFA R13+28
        POP      {R4-R6,R8,R9,R11,PC}
        Nop      
        DATA
??Open_File_0:
        DC32     `?<Constant "FILE    BMP">`
        DC32     RsvdSecCnt
        CFI EndBlock cfiBlock0
//  134 }
//  135 /*******************************************************************************
//  136 Save_Dat: 保存当前屏幕显示图像原始数据    输入：文件编号     返回值：0x00=成功 
//  137 	Save the data of waveform     INPUT: File NO.     RETURN: 0x00=Success
//  138 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function Save_Dat
        THUMB
//  139 u8 Save_Dat(u8 FileNum)
//  140 {
Save_Dat:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  141   u16 i, j, Rvalue; 
//  142   
//  143   Rvalue = Open_File(FileNum, "DAT");  // 2 KB data lenght : 4 *300 = 1.2KBytes
        ADR.N    R1,??DataTable5  ;; "DAT"
        BL       Open_File
//  144   if(Rvalue != 0) return Rvalue;
        MOVS     R1,R0
        BNE.N    ??Save_Dat_0
//  145   
//  146   for(j=0; j<4; j++){
        LDR.N    R5,??DataTable7  ;; SecBuff
        LDR.N    R7,??DataTable8  ;; RsvdSecCnt
        MOVS     R4,#+0
//  147     for(i=0; i<299; i++){
??Save_Dat_1:
        LDR.N    R6,??Save_Dat_2  ;; TrackBuff
        MOVS     R1,#+0
//  148       SecBuff[i] = TrackBuff[i*4 + j];
??Save_Dat_3:
        ADDS     R3,R4,R1, LSL #+2
        LDRB     R3,[R6, R3]
        STRB     R3,[R5, R1]
//  149     }
        LDR.N    R3,??Save_Dat_2+0x4  ;; 0x12b
        ADDS     R1,R1,#+1
        UXTH     R1,R1
        CMP      R1,R3
        BCC.N    ??Save_Dat_3
//  150     SecBuff[299] = Title[j][POSI].Value;
        LDR.N    R2,??DataTable12  ;; Title
//  151     __Disk_Buff_WR(SecBuff, File_Addr + j*512);
        LDR      R0,[R7, #+60]
        MOVS     R1,#+80
        LSLS     R6,R4,#+9
        MLA      R1,R4,R1,R2
//  152     __Disk_Buff_WR(SecBuff + 256, File_Addr + 256 +j*512);
//  153   }
        ADDS     R4,R4,#+1
        UXTH     R4,R4
        ADDS     R1,R1,#+76
        LDRH     R1,[R1, #+0]
        STRB     R1,[R5, #+299]
        ADDS     R1,R0,R6
        MOVS     R0,R5
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[R7, #+60]
        ADDS     R0,R6,R0
        ADDW     R1,R0,#+256
        ADDW     R0,R5,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        CMP      R4,#+4
        BCC.N    ??Save_Dat_1
//  154   
//  155   return 0;
        MOVS     R0,#+0
??Save_Dat_0:
        POP      {R4-R7,PC}
        DATA
??Save_Dat_2:
        DC32     TrackBuff
        DC32     0x12b
        CFI EndBlock cfiBlock1
//  156 }
//  157 /*******************************************************************************
//  158 Load_Dat: 加载保存过的屏幕图像原始数据    输入：文件编号     返回值：0x00=成功 
//  159           load the data  in USB disk               INPUT:File NO.       RETUREN:0x00 = Success
//  160 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Load_Dat
        THUMB
//  161 u8 Load_Dat(u8 FileNum)
//  162 {
Load_Dat:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  163   u16  Rvalue;
//  164 
//  165   Rvalue = Open_File(FileNum, "DAT");  // 2 KB data lenght : 4 *300 = 1.2KBytes
        ADR.N    R1,??DataTable5  ;; "DAT"
        BL       Open_File
//  166   if(Rvalue != 0) return Rvalue;
        MOVS     R1,R0
        IT      NE 
        POPNE    {R4,PC}
//  167   
//  168   __Disk_Buff_RD(FileBuff,         File_Addr,     300);
        LDR.N    R4,??DataTable8  ;; RsvdSecCnt
        MOVS     R2,#+300
        LDR      R1,[R4, #+60]
        MOVS     R0,R4
        ADDS     R0,R0,#+68
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  169   
//  170   __Disk_Buff_RD(FileBuff+300,     File_Addr+2*256, 300);
        LDR      R0,[R4, #+60]
        MOVS     R2,#+300
        ADDW     R1,R0,#+512
        ADDW     R0,R4,#+368
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  171 
//  172   __Disk_Buff_RD(FileBuff+600,     File_Addr+4*256, 300);
        LDR      R0,[R4, #+60]
        MOVS     R2,#+300
        ADDS     R1,R0,#+1024
        ADDW     R0,R4,#+668
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  173 
//  174   __Disk_Buff_RD(FileBuff+900,     File_Addr+6*256, 300);
        LDR      R0,[R4, #+60]
        MOVS     R2,#+300
        ADDS     R1,R0,#+1536
        ADDW     R0,R4,#+968
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  175   
//  176   return 0;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock2
//  177 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC8      "DAT"
//  178 /*******************************************************************************
//  179 Save_Bmp: 保存当前屏幕显示图像为BMP格式    输入：文件编号     返回值：0x00=成功 
//  180           Save the current Waveform as .BMP file INPUT:File No. RETURN:0x00=Success
//  181 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Save_Bmp
        THUMB
//  182 u8 Save_Bmp(u8 FileNum)
//  183 {
Save_Bmp:
        PUSH     {R4-R9,R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+4
        CFI CFA R13+36
//  184   u16  x=0, y=0, ColorH, ColorL, Rvalue;
//  185   u8   i, j, k; 
//  186 
//  187   Rvalue = Open_File(FileNum, "BMP");  // 47 KB data lenght = 256*188 = 48128 Bytes
        ADR.N    R1,??Save_Bmp_0  ;; "BMP"
        BL       Open_File
//  188   if(Rvalue != 0) return Rvalue;
        MOVS     R1,R0
        BNE.N    ??Save_Bmp_1
//  189   __Disk_Buff_RD(SecBuff, File_Addr, 256);
        LDR.N    R0,??DataTable7  ;; SecBuff
        MOVS     R2,#+256
        MOV      R8,R0
        LDR.N    R0,??DataTable8  ;; RsvdSecCnt
        MOV      R9,R0
        LDR      R1,[R9, #+60]
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  190   
//  191   i = 0x0036; // 调色板存放开始地址//Address of the assemble color 
//  192   for(j=0; j<16; ++j){
        MOVS     R0,#+0
        MOV      R11,R0
//  193     SecBuff[j*4 +i+0]=(BMP_Color[j]& 0xF800)>>8; // Bule
??Save_Bmp_2:
        ADDS     R1,R9,R0, LSL #+1
        LDRH     R1,[R1, #+12]
        ADDS     R3,R8,R0, LSL #+2
//  194     SecBuff[j*4 +i+1]=(BMP_Color[j]& 0x07E0)>>3; // Green
        LSLS     R2,R0,#+2
        ADDS     R2,R2,#+54
        ADD      R2,R2,R8
        ANDS     R4,R1,#0xF800
        LSRS     R4,R4,#+8
        STRB     R4,[R3, #+54]!
        ANDS     R3,R1,#0x7E0
        ASRS     R3,R3,#+3
        STRB     R3,[R2, #+1]
//  195     SecBuff[j*4 +i+2]=(BMP_Color[j]& 0x001F)<<3; // Red
        LSLS     R1,R1,#+3
        STRB     R1,[R2, #+2]
//  196     SecBuff[j*4 +i+3]= 0;                        // Alpha
        MOVS     R1,#+0
        STRB     R1,[R2, #+3]
//  197   }
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+16
        BCC.N    ??Save_Bmp_2
//  198   i = 0x0076; // 图像数据开始存放地址//Address to save the .bmp
        MOVS     R0,#+118
        STR      R0,[SP, #+0]
//  199   k = 0;
        MOVS     R4,#+0
//  200   for(y=0; y<240; y++){
//  201     for(x=0; x<400 ; x+=2){  
??Save_Bmp_3:
        MOVS     R5,#+0
//  202       __Point_SCR(x, y);
??Save_Bmp_4:
        MOV      R1,R11
        MOVS     R0,R5
        _BLF     __Point_SCR,??__Point_SCR??rT
//  203       ColorH =__LCD_GetPixl();
        _BLF     __LCD_GetPixl,??__LCD_GetPixl??rT
        MOVS     R7,R0
//  204       __Point_SCR(x+1, y);
        MOV      R1,R11
        ADDS     R0,R5,#+1
        UXTH     R0,R0
        _BLF     __Point_SCR,??__Point_SCR??rT
//  205       ColorL =__LCD_GetPixl();
        _BLF     __LCD_GetPixl,??__LCD_GetPixl??rT
        MOVS     R6,R0
//  206       SecBuff[i] =(Color_Num(ColorH)<<4)+ Color_Num(ColorL);
        MOVS     R0,R7
        BL       Color_Num
        MOVS     R7,R0
        MOVS     R0,R6
        BL       Color_Num
        LDR      R1,[SP, #+0]
        MOV      R2,R8
        ADDS     R0,R0,R7, LSL #+4
        UXTB     R1,R1
        STRB     R0,[R2, R1]
//  207       i++;
        LDR      R0,[SP, #+0]
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        STR      R0,[SP, #+0]
//  208       if(i==0){
        BNE.N    ??Save_Bmp_5
//  209         __Disk_Buff_WR(SecBuff, File_Addr +(k <<8));
        LDR      R0,[R9, #+60]
        ADDS     R1,R0,R4, LSL #+8
        MOV      R0,R8
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  210         Print_Clk(254, 0, (SCRN<<8)+ TEXT1, (k >>2)& 3);    // 进度指示 // Progress indicator
        LDR.N    R2,??Save_Bmp_0+0x4  ;; 0x50a
        ASRS     R0,R4,#+2
        LSLS     R3,R0,#+30
        LSRS     R3,R3,#+30
        MOVS     R1,#+0
        MOVS     R0,#+254
        _BLF     Print_Clk,??Print_Clk??rT
//  211         k++;
        ADDS     R4,R4,#+1
        UXTB     R4,R4
//  212       }
//  213     }
??Save_Bmp_5:
        ADDS     R5,R5,#+2
        UXTH     R5,R5
        MOVS     R1,#+400
        CMP      R5,R1
        BCC.N    ??Save_Bmp_4
//  214   }
        MOV      R0,R11
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        MOV      R11,R0
        CMP      R0,#+240
        BCC.N    ??Save_Bmp_3
//  215   __Disk_Buff_WR(SecBuff, File_Addr +(k <<8));
        LDR      R0,[R9, #+60]
        ADDS     R1,R0,R4, LSL #+8
        MOV      R0,R8
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  216   return 0;
        MOVS     R0,#+0
??Save_Bmp_1:
        ADD      SP,SP,#+4
        CFI CFA R13+32
        POP      {R4-R9,R11,PC}
        DATA
??Save_Bmp_0:
        DC8      "BMP"
        DC32     0x50a
        CFI EndBlock cfiBlock3
//  217 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     SecBuff

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     RsvdSecCnt

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Color_Num
        THUMB
//  218 u8 Color_Num(u16 Color)
//  219 {
//  220   if(Color == WHT)                   return 0;
Color_Num:
        LDR.N    R1,??Color_Num_0  ;; 0xffff
        CMP      R0,R1
        ITT     EQ 
        MOVEQ    R0,#+0
        BXEQ     LR
//  221   else if((Color & CYAN  )== CYAN  ) return 1;
        SUBS     R1,R1,#+31
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+1
        BXEQ     LR
//  222   else if((Color & YEL   )== YEL   ) return 3;
        LSRS     R1,R1,#+5
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+3
        BXEQ     LR
//  223   else if((Color & PURPL )== PURPL ) return 5;
        LDR.N    R1,??Color_Num_0+0x4  ;; 0xf81f
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+5
        BXEQ     LR
//  224   else if((Color & GRN   )== GRN   ) return 7;
        ANDS     R1,R0,#0x7E0
        CMP      R1,#+2016
        ITT     EQ 
        MOVEQ    R0,#+7
        BXEQ     LR
//  225   else if((Color & CYAN_ )== CYAN_ ) return 2;
        LDR.N    R1,??Color_Num_0+0x8  ;; 0xbde0
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+2
        BXEQ     LR
//  226   else if((Color & YEL_  )== YEL_  ) return 4;
        LDR.N    R1,??Color_Num_0+0xC  ;; 0x5f7
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+4
        BXEQ     LR
//  227   else if((Color & PURPL_)== PURPL_) return 6;
        LDR.N    R1,??Color_Num_0+0x10  ;; 0xb817
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+6
        BXEQ     LR
//  228   else if((Color & GRN_  )== GRN_  ) return 8;
        ANDS     R1,R0,#0x5E0
        CMP      R1,#+1504
        ITT     EQ 
        MOVEQ    R0,#+8
        BXEQ     LR
//  229   else if((Color & GRAY  )== GRAY  ) return 9;
        LDR.N    R1,??Color_Num_0+0x14  ;; 0x7bef
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+9
        BXEQ     LR
//  230   else if((Color & ORANGE)== ORANGE) return 10;
        LDR.N    R1,??Color_Num_0+0x18  ;; 0x51f
        MOVS     R2,R1
        ANDS     R2,R2,R0
        CMP      R2,R1
        ITT     EQ 
        MOVEQ    R0,#+10
        BXEQ     LR
//  231   else if((Color & BLUE  )== BLUE  ) return 11;
        ANDS     R1,R0,#0xF800
        CMP      R1,#+63488
        ITT     EQ 
        MOVEQ    R0,#+11
        BXEQ     LR
//  232   else if((Color & RED   )== RED   ) return 12;
        LSLS     R0,R0,#+27
        LSRS     R0,R0,#+27
        CMP      R0,#+31
        ITT     EQ 
        MOVEQ    R0,#+12
        BXEQ     LR
//  233   else                               return 13;
        MOVS     R0,#+13
        BX       LR               ;; return
        DATA
??Color_Num_0:
        DC32     0xffff
        DC32     0xf81f
        DC32     0xbde0
        DC32     0x5f7
        DC32     0xb817
        DC32     0x7bef
        DC32     0x51f
        CFI EndBlock cfiBlock4
//  234 }
//  235 /*******************************************************************************
//  236 Load_Parameter: 加载之前的工作参数                           Return: 0= Success
//  237                 Load the Parameter in flash.	
//  238 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function Load_Parameter
        THUMB
//  239 u8 Load_Parameter(void)            // 参数区共有4页，每页 256 Byte//  4 Pages of flash for parameters , 256 byte in each page.
//  240 { 
Load_Parameter:
        PUSH     {R4,R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  241   u8 Versions =0x03, Sum =0;
//  242   u16 i;
//  243   u16* p = (u16*)SecBuff;
//  244   
//  245   __Param_Area_RD(SecBuff, PAGE_0);
        LDR.N    R4,??DataTable21  ;; SecBuff
        MOVS     R1,#+0
        MOVS     R6,#+0
        MOVS     R0,R4
        _BLF     __Param_Area_RD,??__Param_Area_RD??rT
//  246  
//  247   if(Versions !=(*p & 0xFF)) return 1;          // 版本出错返回// ERROR of Version 
        LDRH     R0,[R4, #+0]
        UXTB     R0,R0
        CMP      R0,#+3
        ITT     NE 
        MOVNE    R0,#+1
        POPNE    {R4,R6,PC}
//  248   for(i=0; i<256; ++i) Sum += SecBuff[i];
        MOVS     R0,#+0
        MOVS     R2,#+256
        B.N      ??Load_Parameter_0
??Load_Parameter_1:
        LDRB     R1,[R4, R0]
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        ADDS     R6,R6,R1
        UXTB     R6,R6
??Load_Parameter_0:
        CMP      R0,R2
        BCC.N    ??Load_Parameter_1
//  249   if(Sum != 0) return 2;                  // 校验和出错返回// ERROR of checkout
        CBZ      R6,??Load_Parameter_2
        MOVS     R0,#+2
        POP      {R4,R6,PC}
//  250   
//  251   Current =(*p++ >>8);                    // 加载之前的 Current Title //Load previous Current Title
??Load_Parameter_2:
        LDR.N    R0,??DataTable22  ;; Current
        LDRH     R1,[R4], #+2
        LSRS     R1,R1,#+8
        STRB     R1,[R0, #+0]
//  252   
//  253   for(i=0; i<7; i++){ 
        MOVS     R0,#+0
        B.N      ??Load_Parameter_3
??Load_Parameter_4:
        LDR.N    R2,??DataTable23  ;; Detail
        ADDS     R1,R2,R0, LSL #+1
        LDRH     R2,[R4, #+0]
//  254     Detail[i*2]  = *p;
//  255     Detail[i*2+1]= (*p++ >>8);             // 加载之前的 Detail//Load previous Detail
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        STRB     R2,[R1, #+0]
        LDRH     R2,[R4], #+2
        LSRS     R2,R2,#+8
        STRB     R2,[R1, #+1]
??Load_Parameter_3:
        CMP      R0,#+7
        BCC.N    ??Load_Parameter_4
//  256   }
//  257   for(i=0; i<13; i++){
        LDR.N    R3,??DataTable12  ;; Title
        MOVS     R0,#+0
        B.N      ??Load_Parameter_5
//  258     Title[i][0].Value = *p++;             // 加载之前的显示菜单中各个对应项的值//Load the data of submenu of each menu
??Load_Parameter_6:
        MOVS     R2,#+80
//  259     Title[i][1].Value = *p++;
//  260     Title[i][2].Value = *p++;
//  261     Title[i][3].Value = *p++;
//  262   }
        ADDS     R0,R0,#+1
        MLA      R1,R1,R2,R3
        LDRH     R2,[R4, #+0]
        UXTH     R0,R0
        STRH     R2,[R1, #+16]!
        LDRH     R2,[R4, #+2]
        STRH     R2,[R1, #+20]
        LDRH     R2,[R4, #+4]
        STRH     R2,[R1, #+40]
        LDRH     R2,[R4, #+6]
        ADDS     R4,R4,#+8
        STRH     R2,[R1, #+60]
??Load_Parameter_5:
        MOVS     R1,R0
        CMP      R1,#+13
        BCC.N    ??Load_Parameter_6
//  263   for(i=0; i<9; i++){
        LDR.N    R3,??DataTable25  ;; Meter
        MOVS     R0,#+0
        B.N      ??Load_Parameter_7
//  264     Meter[i].Item     = *p;
??Load_Parameter_8:
        MOVS     R2,#+12
//  265     Meter[i].Track    =(*p++ >>8);        // 加载之前的测量项目及测量对象//Load the  previous measured items.
//  266   }
        ADDS     R0,R0,#+1
        MLA      R1,R1,R2,R3
        LDRH     R2,[R4, #+0]
        UXTH     R0,R0
        STRB     R2,[R1, #+5]
        LDRH     R2,[R4], #+2
        LSRS     R2,R2,#+8
        STRB     R2,[R1, #+4]
??Load_Parameter_7:
        MOVS     R1,R0
        CMP      R1,#+9
        BCC.N    ??Load_Parameter_8
//  267   for(i=0; i<10; i++){
        MOVS     R0,#+0
        B.N      ??Load_Parameter_9
//  268     Ka1[i] = *p;                         // 恢复原来的 A 通道零点误差校正系数//Reload CHA Calibrate factor in base point
??Load_Parameter_10:
        LDR.N    R2,??DataTable27  ;; Ka1
        LDRH     R3,[R4, #+0]
//  269     Kb1[i] =(*p++ >>8);                  // 恢复原来的 B 通道零点误差校正系数//Reload CHB Calibrate factor in base point
//  270     Ka2[i] = *p++;                       // 恢复原来的 A 通道增益误差校正系数//Reload CHA Calibrate factor for gain
//  271     Kb2[i] = *p++;                       // 加载之前的 B 通道增益误差校正系数//Reload CHB Calibrate factor for gain
//  272   }
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        STRB     R3,[R2, R1]
        LDR.N    R2,??DataTable26  ;; Kb1
        LDRH     R3,[R4, #+0]
        LSRS     R3,R3,#+8
        STRB     R3,[R2, R1]
        LDR.N    R2,??DataTable28  ;; Ka2
        LDRH     R3,[R4, #+2]
        STRH     R3,[R2, R1, LSL #+1]
        LDR.N    R2,??DataTable29  ;; Kb2
        LDRH     R3,[R4, #+4]
        ADDS     R4,R4,#+6
        STRH     R3,[R2, R1, LSL #+1]
??Load_Parameter_9:
        MOVS     R1,R0
        CMP      R1,#+10
        BCC.N    ??Load_Parameter_10
//  273   Ka3 = *p++;                            // 恢复原来的 A 通道位移误差校正系数//Reload Calibrate factor for offset of CHA
        LDR.N    R0,??DataTable30  ;; Ka3
        LDRH     R1,[R4, #+0]
        STRH     R1,[R0, #+0]
//  274   Kb3 = *p++;                            // 恢复原来的 B 通道位移误差校正系数//Reload Calibrate factor for offset of CHB
        LDR.N    R0,??DataTable31  ;; Kb3
        LDRH     R1,[R4, #+2]
        STRH     R1,[R0, #+0]
//  275 
//  276   V_Trigg[A].Value = *p++;
        LDR.N    R0,??DataTable32  ;; V_Trigg
        LDRH     R1,[R4, #+4]
        STRH     R1,[R0, #+0]
//  277   V_Trigg[B].Value = *p++;               // 恢复原来A,B通道触发阈值// Reload Trigger threshhold of channelA and B
        LDRH     R1,[R4, #+6]!
        STRH     R1,[R0, #+4]
//  278   
//  279   return 0;
        MOVS     R0,#+0
        POP      {R4,R6,PC}
        CFI EndBlock cfiBlock5
//  280 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable12:
        DC32     Title
//  281 /*******************************************************************************
//  282  Save_Parameter: 保存当前的工作参数                          Return: 0= Success
//  283 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function Save_Parameter
        THUMB
//  284 u8 Save_Parameter(u8 Default)             // 参数区共有4页，每页 256 Byte //4 pages flash for parameter ,256 bytes for each page.
//  285 {                                          // 目前只用了第0页//Only the section 0 was used yet
Save_Parameter:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  286   u8 Versions =0x03, Sum =0;
//  287   u16* p =(u16*)SecBuff;
//  288   u16  i;
//  289   
//  290   memset(SecBuff,0,256);  
        LDR.N    R6,??DataTable21  ;; SecBuff
        MOVS     R4,#+0
        MOVS     R2,#+256
        MOVS     R7,R0
        MOVS     R0,#+3
        MOV      R8,R0
        MOV      R1,R4
        MOVS     R0,R6
        _BLF     memset,??memset??rT
        MOVS     R5,#+0
//  291   
//  292   if(Default) Versions =0xFF;
        CBZ      R7,??Save_Parameter_0
        MOVS     R0,#+255
        MOV      R8,R0
//  293   *p++ =(Current <<8)+ Versions;            // 保存参数版本号及当前的 Title //Version of parameter and current Title
??Save_Parameter_0:
        LDR.N    R0,??DataTable22  ;; Current
//  294   
//  295   for(i=0; i<7; i++) 
        MOVS     R1,#+0
        LDRB     R0,[R0, #+0]
        ADDS     R0,R8,R0, LSL #+8
        STRH     R0,[R6, #+0]
        ADDS     R0,R6,#+2
        B.N      ??Save_Parameter_1
??Save_Parameter_2:
        LDR.N    R3,??DataTable23  ;; Detail
        ADDS     R2,R3,R1, LSL #+1
        LDRB     R3,[R2, #+1]
        LDRB     R2,[R2, #+0]
//  296     *p++ =(Detail[i*2+1]<<8)+ Detail[i*2]; // 保存当前的 Detail//Save the Current Detail
        ADDS     R1,R1,#+1
        UXTH     R1,R1
        ADDS     R2,R2,R3, LSL #+8
        STRH     R2,[R0], #+2
??Save_Parameter_1:
        CMP      R1,#+7
        BCC.N    ??Save_Parameter_2
//  297   
//  298   for(i=0; i<13; i++){                     // 保存显示菜单中各个对应项的值//Save the value for each submemu
        LDR.N    R7,??DataTable24  ;; Title
        MOVS     R1,#+0
        B.N      ??Save_Parameter_3
//  299     *p++ = Title[i][0].Value;
??Save_Parameter_4:
        MOVS     R3,#+80
//  300     *p++ = Title[i][1].Value;
//  301     *p++ = Title[i][2].Value;
//  302     *p++ = Title[i][3].Value;
//  303   }
        ADDS     R1,R1,#+1
        MLA      R2,R2,R3,R7
        UXTH     R1,R1
        LDRH     R3,[R2, #+16]
        STRH     R3,[R0, #+0]
        LDRH     R3,[R2, #+36]
        STRH     R3,[R0, #+2]
        LDRH     R3,[R2, #+56]
        ADDS     R2,R2,#+76
        STRH     R3,[R0, #+4]
        LDRH     R2,[R2, #+0]
        STRH     R2,[R0, #+6]
        ADDS     R0,R0,#+8
??Save_Parameter_3:
        MOVS     R2,R1
        CMP      R2,#+13
        BCC.N    ??Save_Parameter_4
//  304   for(i=0; i<9; i++){
        LDR.N    R7,??DataTable25  ;; Meter
        MOVS     R1,#+0
        B.N      ??Save_Parameter_5
//  305     *p++ =(Meter[i].Track<<8)+ Meter[i].Item; // 保存测量项目及测量对象//Save the current measure item
??Save_Parameter_6:
        MOVS     R3,#+12
//  306   }
        ADDS     R1,R1,#+1
        MLA      R2,R2,R3,R7
        UXTH     R1,R1
        LDRB     R3,[R2, #+4]
        LDRB     R2,[R2, #+5]
        ADDS     R2,R2,R3, LSL #+8
        STRH     R2,[R0], #+2
??Save_Parameter_5:
        MOVS     R2,R1
        CMP      R2,#+9
        BCC.N    ??Save_Parameter_6
//  307   for(i=0; i<10; i++){
        MOVS     R1,#+0
        B.N      ??Save_Parameter_7
//  308     *p++ =(Kb1[i]<<8)+ Ka1[i];             // 保存当前 A,B 通道零点误差校正系数//Save Calibrate factor in base point for CHA and CHB
??Save_Parameter_8:
        LDR.N    R3,??DataTable26  ;; Kb1
        LDR.N    R7,??DataTable27  ;; Ka1
//  309     *p++ = Ka2[i];                         // 保存当前 A 通道增益误差校正系数//Save Calibrate factor for gain of CHA
//  310     *p++ = Kb2[i];                         // 保存当前 B 通道增益误差校正系数//Save Calibrate factor for gain of CHB
//  311   }
        ADDS     R1,R1,#+1
        LDRSB    R3,[R3, R2]
        LDRSB    R7,[R7, R2]
        UXTH     R1,R1
        ADDS     R3,R7,R3, LSL #+8
        STRH     R3,[R0, #+0]
        LDR.N    R3,??DataTable28  ;; Ka2
        LDRH     R3,[R3, R2, LSL #+1]
        STRH     R3,[R0, #+2]
        LDR.N    R3,??DataTable29  ;; Kb2
        LDRH     R2,[R3, R2, LSL #+1]
        STRH     R2,[R0, #+4]
        ADDS     R0,R0,#+6
??Save_Parameter_7:
        MOVS     R2,R1
        CMP      R2,#+10
        BCC.N    ??Save_Parameter_8
//  312   *p++ = Ka3;                              // 保存当前 A 通道位移误差校正系数//Save Calibrate factor for offset of CHA
        LDR.N    R1,??DataTable30  ;; Ka3
        LDRH     R1,[R1, #+0]
        STRH     R1,[R0, #+0]
//  313   *p++ = Kb3;                              // 保存当前 B 通道位移误差校正系数//Save Calibrate factor for offset of CHB
        LDR.N    R1,??DataTable31  ;; Kb3
        LDRH     R1,[R1, #+0]
        STRH     R1,[R0, #+2]
//  314   
//  315   *p++ = V_Trigg[A].Value;
        LDR.N    R1,??DataTable32  ;; V_Trigg
        LDRH     R2,[R1, #+0]
        STRH     R2,[R0, #+4]
//  316   *p++ = V_Trigg[B].Value;                 // 保存当前A,B通道触发阈值  // Save Trigger threshhold of channelA and B
        LDRH     R1,[R1, #+4]
        STRH     R1,[R0, #+6]!
//  317    
//  318   
//  319   for(i=0; i<255; i++)  Sum += SecBuff[i]; //计算参数区校验和// Cal. the key value for the parameter area.
        B.N      ??Save_Parameter_9
??Save_Parameter_10:
        LDRB     R0,[R6, R4]
        ADDS     R4,R4,#+1
        UXTH     R4,R4
        ADDS     R5,R5,R0
        UXTB     R5,R5
??Save_Parameter_9:
        CMP      R4,#+255
        BCC.N    ??Save_Parameter_10
//  320   SecBuff[255] = (~Sum)+ 1;
        MVNS     R0,R5
        ADDS     R0,R0,#+1
        STRB     R0,[R6, #+255]
//  321   __Param_Area_WR(SecBuff, PAGE_0); 
        MOVS     R1,#+0
        MOVS     R0,R6
        _BLF     __Param_Area_WR,??__Param_Area_WR??rT
//  322   return 0;
        MOVS     R0,#+0
        POP      {R4-R8,PC}       ;; return
        CFI EndBlock cfiBlock6
//  323 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable21:
        DC32     SecBuff

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable22:
        DC32     Current

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable23:
        DC32     Detail

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable24:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable25:
        DC32     Meter

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable26:
        DC32     Kb1

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable27:
        DC32     Ka1

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable28:
        DC32     Ka2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable29:
        DC32     Kb2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable30:
        DC32     Ka3

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable31:
        DC32     Kb3

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable32:
        DC32     V_Trigg

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI NoFunction
        THUMB
??u8ToDec3??rT:
        LDR.N    R3,??Subroutine0_0  ;; u8ToDec3
        BX       R3
        DATA
??Subroutine0_0:
        DC32     u8ToDec3
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Disk_Buff_RD??rT:
        LDR.N    R3,??Subroutine1_0  ;; __Disk_Buff_RD
        BX       R3
        DATA
??Subroutine1_0:
        DC32     __Disk_Buff_RD
        CFI EndBlock cfiBlock8

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Disk_Buff_WR??rT:
        LDR.N    R3,??Subroutine2_0  ;; __Disk_Buff_WR
        BX       R3
        DATA
??Subroutine2_0:
        DC32     __Disk_Buff_WR
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Point_SCR??rT:
        LDR.N    R3,??Subroutine3_0  ;; __Point_SCR
        BX       R3
        DATA
??Subroutine3_0:
        DC32     __Point_SCR
        CFI EndBlock cfiBlock10

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI NoFunction
        THUMB
??__LCD_GetPixl??rT:
        LDR.N    R3,??Subroutine4_0  ;; __LCD_GetPixl
        BX       R3
        DATA
??Subroutine4_0:
        DC32     __LCD_GetPixl
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??Print_Clk??rT:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine5_0  ;; Print_Clk
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine5_0:
        DC32     Print_Clk
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Param_Area_RD??rT:
        LDR.N    R3,??Subroutine6_0  ;; __Param_Area_RD
        BX       R3
        DATA
??Subroutine6_0:
        DC32     __Param_Area_RD
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??memset??rT:
        LDR.N    R3,??Subroutine7_0  ;; memset
        BX       R3
        DATA
??Subroutine7_0:
        DC32     memset
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Param_Area_WR??rT:
        LDR.N    R3,??Subroutine8_0  ;; __Param_Area_WR
        BX       R3
        DATA
??Subroutine8_0:
        DC32     __Param_Area_WR
        CFI EndBlock cfiBlock15

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for RsvdSecCnt>`:
        DATA
        DC8 0, 0
`?<Initializer for SectorSize>`:
        DC8 0, 0
`?<Initializer for FAT_Size16>`:
        DC8 0, 0
`?<Initializer for SecPerClus>`:
        DC8 0, 0
`?<Initializer for DirSecNum>`:
        DC8 0, 0
        DC8 0, 0
`?<Initializer for BMP_Color>`:
        DC16 65535, 65504, 48608, 2047, 1527, 63519, 47127, 2016, 1504, 31727
        DC16 1311, 63488, 31, 0, 0, 0
`?<Initializer for DiskStart>`:
        DC8 0, 0, 0, 0
`?<Initializer for Hidden_Sec>`:
        DC8 0, 0, 0, 0
`?<Initializer for Root_Addr>`:
        DC8 0, 0, 0, 0
`?<Initializer for ClusterNum>`:
        DC8 0, 0, 0, 0
`?<Initializer for File_Addr>`:
        DC8 0, 0, 0, 0
`?<Initializer for File_Size>`:
        DC8 0, 0, 0, 0
`?<Initializer for FileBuff>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "FILE    BMP">`:
        DATA
        DC8 "FILE    BMP"

        RSEG DATA_C:CONST:SORT:NOROOT(2)
        DATA
        DC8 "DAT"

        RSEG DATA_C:CONST:SORT:NOROOT(2)
        DATA
        DC8 "BMP"

        END
//  324 
//  325 /******************************** END OF FILE *********************************/
//  326 
// 
// 1 664 bytes in segment CODE
//    20 bytes in segment DATA_C
// 1 268 bytes in segment DATA_I
// 1 268 bytes in segment DATA_ID
//   524 bytes in segment DATA_Z
//    24 bytes in segment INITTAB
// 
// 1 584 bytes of CODE  memory (+ 104 bytes shared)
// 1 288 bytes of CONST memory
// 1 792 bytes of DATA  memory
//
//Errors: none
//Warnings: none
