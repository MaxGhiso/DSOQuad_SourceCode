//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   06/May/2011  11:15:44 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  C:\Users\Administrator\Desktop\mini DSO             /
//                       download\APP_V2.32\APP_V2.32\source\Process.c       /
//    Command line    =  "C:\Users\Administrator\Desktop\mini DSO            /
//                       download\APP_V2.32\APP_V2.32\source\Process.c" -lA  /
//                       "C:\Users\Administrator\Desktop\mini DSO            /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\List\"  /
//                       -o "C:\Users\Administrator\Desktop\mini DSO         /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\Obj\"   /
//                       -s9 --debug --cpu_mode thumb --endian little --cpu  /
//                       cortex-M3 --stack_align 4 --fpu None --dlib_config  /
//                       "E:\IARWorkBench(Cracked)\Embedded Workbench 4.0    /
//                       Evaluation\ARM\LIB\dl7mptnnl8f.h" -I                /
//                       "C:\Users\Administrator\Desktop\mini DSO            /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\..\..\F /
//                       WLib\inc\" -I "C:\Users\Administrator\Desktop\mini  /
//                       DSO download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\..\ /
//                       ..\USBLib\inc\" -I "C:\Users\Administrator\Desktop\ /
//                       mini DSO download\APP_V2.32\APP_V2.32\IAR_V4_Prpjec /
//                       t\..\include\" -I "E:\IARWorkBench(Cracked)\Embedde /
//                       d Workbench 4.0 Evaluation\ARM\INC\"                /
//                       --inline_threshold=16                               /
//    List file       =  C:\Users\Administrator\Desktop\mini DSO             /
//                       download\APP_V2.32\APP_V2.32\IAR_V4_Prpject\List\Pr /
//                       ocess.s79                                           /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Process

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        EXTERN ??div32_t

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable2 EQU 0
??DataTable4 EQU 0
??DataTable9 EQU 0
        MULTWEAK ??Delayms??rT
        MULTWEAK ??Draw_Window??rT
        MULTWEAK ??Get_Ref_Wave??rT
        MULTWEAK ??Int_sqrt??rT
        MULTWEAK ??__Clear_Screen??rT
        MULTWEAK ??__Get??rT
        MULTWEAK ??__Read_FIFO??rT
        MULTWEAK ??__Set??rT
        MULTWEAK ??rT??div32_t
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC A_Max
        PUBLIC A_Min
        PUBLIC A_Rms
        PUBLIC A_Tab
        PUBLIC A_Vdc
        PUBLIC A_Vpp
        PUBLIC App_init
        FUNCTION App_init,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC B_Max
        PUBLIC B_Min
        PUBLIC B_Rms
        PUBLIC B_Vdc
        PUBLIC B_Vpp
        PUBLIC CH_D_Data
        FUNCTION CH_D_Data,0203H
        LOCFRAME CSTACK, 44, STACK
        PUBLIC Ch
        PUBLIC D_Tab
        PUBLIC DataBuf
        PUBLIC Full
        PUBLIC G_Attr
        PUBLIC Interlace
        PUBLIC JumpCnt
        PUBLIC Ka1
        PUBLIC Ka2
        PUBLIC Ka3
        PUBLIC Kb1
        PUBLIC Kb2
        PUBLIC Kb3
        PUBLIC Process
        FUNCTION Process,0203H
        LOCFRAME CSTACK, 60, STACK
        PUBLIC SAW_DATA
        PUBLIC SIN_DATA
        PUBLIC Synchro
        FUNCTION Synchro,0203H
        LOCFRAME CSTACK, 36, STACK
        PUBLIC TRG_DATA
        PUBLIC T_Attr
        PUBLIC Tmp
        PUBLIC TrackBuff
        PUBLIC Update_Base
        FUNCTION Update_Base,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Output
        FUNCTION Update_Output,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Range
        FUNCTION Update_Range,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Update_Trig
        FUNCTION Update_Trig,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC V
        PUBLIC View_init
        FUNCTION View_init,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Wait
        PUBLIC X_Attr
        PUBLIC Y_Attr
        PUBLIC a_Avg
        PUBLIC a_Ssq
        PUBLIC a_max
        PUBLIC a_min
        PUBLIC b_Avg
        PUBLIC b_Ssq
        PUBLIC b_max
        PUBLIC b_min
        PUBLIC n
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Delayms             SYMBOL "Delayms"
Draw_Window         SYMBOL "Draw_Window"
Get_Ref_Wave        SYMBOL "Get_Ref_Wave"
Int_sqrt            SYMBOL "Int_sqrt"
__Clear_Screen      SYMBOL "__Clear_Screen"
__Get               SYMBOL "__Get"
__Read_FIFO         SYMBOL "__Read_FIFO"
__Set               SYMBOL "__Set"
??Delayms??rT       SYMBOL "??rT", Delayms
??Draw_Window??rT   SYMBOL "??rT", Draw_Window
??Get_Ref_Wave??rT  SYMBOL "??rT", Get_Ref_Wave
??Int_sqrt??rT      SYMBOL "??rT", Int_sqrt
??__Clear_Screen??rT SYMBOL "??rT", __Clear_Screen
??__Get??rT         SYMBOL "??rT", __Get
??__Read_FIFO??rT   SYMBOL "??rT", __Read_FIFO
??__Set??rT         SYMBOL "??rT", __Set

        EXTERN Current
        EXTERN Delayms
        FUNCTION Delayms,0202H
        EXTERN Draw_Window
        FUNCTION Draw_Window,0202H
        EXTERN FileBuff
        EXTERN Get_Ref_Wave
        FUNCTION Get_Ref_Wave,0202H
        EXTERN Int_sqrt
        FUNCTION Int_sqrt,0202H
        EXTERN Meter
        EXTERN PD_Cnt
        EXTERN Title
        EXTERN Update
        EXTERN V_Trigg
        EXTERN Wait_Cnt
        EXTERN __Clear_Screen
        FUNCTION __Clear_Screen,0202H
        EXTERN __Get
        FUNCTION __Get,0202H
        EXTERN __Read_FIFO
        FUNCTION __Read_FIFO,0202H
        EXTERN __Set
        FUNCTION __Set,0202H

// C:\Users\Administrator\Desktop\mini DSO download\APP_V2.32\APP_V2.32\source\Process.c
//    1 /******************** (C) COPYRIGHT 2009 e-Design Co.,Ltd. *********************
//    2  File Name : Process.c       
//    3  Version   : DS203_APP Ver 2.3x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include "Interrupt.h"
//    6 #include "Function.h"
//    7 #include "Process.h"
//    8 #include "Draw.h"
//    9 #include "Menu.h"
//   10 #include "BIOS.h"
//   11 #include "File.h"
//   12 
//   13 u32 a_Avg, b_Avg, a_Ssq, b_Ssq;            // 统计用中间变量//variable for statistics
//   14 u8  a_max, b_max, a_min, b_min;            // 统计用中间变量//variable for statistics
//   15 s16 A_Vdc, A_Vpp, A_Max, A_Min, A_Rms;     // 计量结果//Calculated results

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   16 s16 B_Vdc, B_Vpp, B_Max, B_Min, B_Rms;     
B_Rms:
        DS8 2
//   17 u8  Ch[4], V[8];
//   18 s32 Tmp;
//   19 
//   20 u16  JumpCnt, n;
//   21 u8   Full=1, Interlace;
//   22 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   23 uc16 Wait[27]= {1000, 500, 200, 100, 50, 20, 10, 5, 2, 2,   
Wait:
        DATA
        DC16 1000, 500, 200, 100, 50, 20, 10, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC16 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC8 0, 0
//   24                 2,      2,   2,   2,  2,  2,  2, 2, 2, 2,    
//   25                 2,      2,   2,   2,  2,  2,  2 };
//   26                      

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   27 Y_attr *Y_Attr; 
Y_Attr:
        DS8 4
//   28 X_attr *X_Attr; 
//   29 G_attr *G_Attr; 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   30 T_attr *T_Attr; 
T_Attr:
        DS8 4
//   31 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   32 u32  DataBuf[4096];
DataBuf:
        DS8 16384

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   33 u8  TrackBuff  [X_SIZE * 4];         // 曲线轨迹缓存：i+0,i+1,i+2,i+3,分别存放1～4号轨迹数据//Buffer for Waveform.i+0,i+1,i+2,i+3 represents  waveform 1-4
TrackBuff:
        DS8 1200

        RSEG DATA_I:DATA:SORT:NOROOT(2)
V:
        DS8 8
        REQUIRE `?<Initializer for V>`
Ch:
        DS8 4
        REQUIRE `?<Initializer for Ch>`
a_max:
        DS8 1
        REQUIRE `?<Initializer for a_max>`
b_max:
        DS8 1
        REQUIRE `?<Initializer for b_max>`
a_min:
        DS8 1
        REQUIRE `?<Initializer for a_min>`
b_min:
        DS8 1
        REQUIRE `?<Initializer for b_min>`
Interlace:
        DS8 1
        REQUIRE `?<Initializer for Interlace>`
        DS8 1
A_Vdc:
        DS8 2
        REQUIRE `?<Initializer for A_Vdc>`
A_Vpp:
        DS8 2
        REQUIRE `?<Initializer for A_Vpp>`
A_Max:
        DS8 2
        REQUIRE `?<Initializer for A_Max>`
A_Min:
        DS8 2
        REQUIRE `?<Initializer for A_Min>`
A_Rms:
        DS8 2
        REQUIRE `?<Initializer for A_Rms>`
B_Vdc:
        DS8 2
        REQUIRE `?<Initializer for B_Vdc>`
B_Vpp:
        DS8 2
        REQUIRE `?<Initializer for B_Vpp>`
B_Max:
        DS8 2
        REQUIRE `?<Initializer for B_Max>`
B_Min:
        DS8 2
        REQUIRE `?<Initializer for B_Min>`
JumpCnt:
        DS8 2
        REQUIRE `?<Initializer for JumpCnt>`
n:
        DS8 2
        REQUIRE `?<Initializer for n>`
//   34 
//   35 s8  Ka1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // A通道零点误差校正系数//CHA Calibrate factor in base point
//   36 s8  Kb1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // B通道零点误差校正系数//CHB Calibrate factor in base point
//   37 u16 Ka2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // A通道增益误差校正系数//CHA Calibrate factor for gain
Ka2:
        DS8 20
        REQUIRE `?<Initializer for Ka2>`
//   38 u16 Kb2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // B通道增益误差校正系数//CHB Calibrate factor for gain
Kb2:
        DS8 20
        REQUIRE `?<Initializer for Kb2>`
Ka1:
        DS8 12
        REQUIRE `?<Initializer for Ka1>`
Kb1:
        DS8 12
        REQUIRE `?<Initializer for Kb1>`
a_Avg:
        DS8 4
        REQUIRE `?<Initializer for a_Avg>`
b_Avg:
        DS8 4
        REQUIRE `?<Initializer for b_Avg>`
a_Ssq:
        DS8 4
        REQUIRE `?<Initializer for a_Ssq>`
b_Ssq:
        DS8 4
        REQUIRE `?<Initializer for b_Ssq>`
Tmp:
        DS8 4
        REQUIRE `?<Initializer for Tmp>`
X_Attr:
        DS8 4
        REQUIRE `?<Initializer for X_Attr>`

        RSEG DATA_I:DATA:SORT:NOROOT(0)
Full:
        DS8 1
        REQUIRE `?<Initializer for Full>`

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   39 u16 Ka3 = 256, Kb3 = 256;                                                // A B通道位移误差校正系数//Calibrate factor for offset of CHA and CHB
Ka3:
        DS8 2
        REQUIRE `?<Initializer for Ka3>`
Kb3:
        DS8 2
        REQUIRE `?<Initializer for Kb3>`
G_Attr:
        DS8 4
        REQUIRE `?<Initializer for G_Attr>`
//   40 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   41 D_tab D_Tab[20] ={  // 脉冲波形输出驱动表, 基于72MHz主频//Digital Signal generator output ,based on 72M main frequency
D_Tab:
        DS8 280
        REQUIRE `?<Initializer for D_Tab>`
//   42 //    STR      PSC     ARR       DUTY% 
//   43   {" 10Hz ",  180-1,  40000-1,     50},
//   44   {" 20Hz ",  180-1,  20000-1,     50},
//   45   {" 50Hz ",  180-1,   8000-1,     50},
//   46   {"!100Hz!", 180-1,   4000-1,     50},
//   47   {"!200Hz!", 180-1,   2000-1,     50},
//   48   {"!500Hz!", 180-1,    800-1,     50},
//   49   {" 1KHz ",  180-1,    400-1,     50},
//   50   {" 2KHz ",  180-1,    200-1,     50},
//   51   {" 5KHz ",   18-1,    800-1,     50},
//   52   {"!10KHz!",  18-1,    400-1,     50},
//   53   {"!20KHz!",  18-1,    200-1,     50},
//   54   {"!50KHz!",   1-1,   1440-1,     50},
//   55   {"100KHz",    1-1,    720-1,     50},
//   56   {"200KHz",    1-1,    360-1,     50},
//   57   {"500KHz",    1-1,    144-1,     50},
//   58   {" 1MHz ",    1-1,     72-1,     50},
//   59   {" 2MHz ",    1-1,     36-1,     50},
//   60   {" 4MHz ",    1-1,     18-1,     50},
//   61   {" 6MHz ",    1-1,     12-1,     50},
//   62   {" 8MHz ",    1-1,      9-1,     50}};
//   63 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   64 A_tab A_Tab[11] ={ // 模拟波形输出驱动表, 基于72MHz主频, 每周期36点合成//Analog signal generator, based on 72M main frequency, and 36 points for each period
A_Tab:
        DS8 132
        REQUIRE `?<Initializer for A_Tab>`
//   65 //    STR     PSC     ARR 
//   66   {" 10Hz ",  20-1,  10000-1},
//   67   {" 20Hz ",  20-1,   5000-1},
//   68   {" 50Hz ",  20-1,   2000-1},
//   69   {"!100Hz!", 20-1,   1000-1},
//   70   {"!200Hz!", 20-1,    500-1},
//   71   {"!500Hz!", 20-1,    200-1},
//   72   {" 1KHz ",  20-1,    100-1},
//   73   {" 2KHz ",  20-1,     50-1},
//   74   {" 5KHz ",  20-1,     20-1},
//   75   {"!10KHz!", 20-1,     10-1},
//   76   {"!20KHz!", 20-1,      5-1}};
//   77 
//   78 u16 SIN_DATA[36] =  // Sine wave data                                                                                                 //         
SIN_DATA:
        DS8 72
        REQUIRE `?<Initializer for SIN_DATA>`
//   79   {0x000,0x027,0x08E,0x130,0x209,0x311,0x441,0x58F,0x6F0,    // 90
//   80    0x85A,0x9C0,0xB19,0xC59,0xD76,0xE68,0xF26,0xFAB,0xFF3,    // 180
//   81    0xFFF,0xFD7,0xF70,0xECE,0xDF5,0xCED,0xBBD,0xA6F,0x90E,    // 270
//   82    0x7A4,0x63E,0x4E5,0x3A5,0x288,0x196,0x0D8,0x053,0x00B,};  // 360   
//   83 
//   84 u16 TRG_DATA[36] =  // triangle wave data
TRG_DATA:
        DS8 72
        REQUIRE `?<Initializer for TRG_DATA>`
//   85   {0x000,0x0E3,0x1C6,0x2AA,0x38D,0x471,0x554,0x638,0x71B,    // 90
//   86    0x7FF,0x8E2,0x9C6,0xAA9,0xB8D,0xC70,0xD54,0xE37,0xF1B,    // 180
//   87    0xFFE,0xF1B,0xE37,0xD54,0xC70,0xB8D,0xAA9,0x9C6,0x8E2,    // 270
//   88    0x7FF,0x71B,0x638,0x554,0x471,0x38D,0x2AA,0x1C6,0x0E3};   // 360			
//   89          
//   90 u16 SAW_DATA[36] =  // Sawtooth wave data                                                                                             //         
SAW_DATA:
        DS8 72
        REQUIRE `?<Initializer for SAW_DATA>`
//   91   {0x000,0x075,0x0EA,0x15F,0x1D4,0x249,0x2BE,0x333,0x3A8,    // 90
//   92    0x41D,0x492,0x507,0x57C,0x5F1,0x666,0x6DB,0x750,0x7C5,    // 180
//   93    0x83A,0x8AF,0x924,0x999,0xA0E,0xA83,0xAF8,0xB6D,0xBE2,    // 270
//   94    0xC57,0xCCC,0xD41,0xDB6,0xE2B,0xEA0,0xF15,0xF8A,0xFFF};   // 360    
//   95 
//   96 
//   97 /*******************************************************************************
//   98  App_init: 显示窗口波形数据初始化
//   99             Init the data of app 
//  100 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function App_init
        THUMB
//  101 void App_init(void)
//  102 { 
App_init:
        PUSH     {R4,R5,R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  103   u16 i, j;
//  104   __Set(ADC_CTRL, EN );       
        MOVS     R1,#+1
//  105   __Set(STANDBY, DN);          // 退出省电状态//Exit the power saving mode
//  106   __Clear_Screen(BLACK);       // 清屏幕//Clear the screen
//  107   Delayms(20); 
//  108   __Set(FIFO_CLR, W_PTR); 
//  109   for(i=0; i<13; i++) for(j=0; j<4; j++) Title[i][j].Flag |= UPDAT;
        LDR.N    R4,??DataTable3  ;; Title
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R0,#+20
        _BLF     __Set,??__Set??rT
        MOVS     R0,#+0
        _BLF     __Clear_Screen,??__Clear_Screen??rT
        MOVS     R0,#+20
        _BLF     Delayms,??Delayms??rT
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOVS     R7,#+80
??App_init_0:
        MOVS     R3,#+0
??App_init_1:
        MOVS     R5,R2
        MOVS     R0,#+20
        MLA      R5,R5,R7,R4
        MLA      R0,R3,R0,R5
        ADDS     R3,R3,#+1
        UXTH     R3,R3
        LDRB     R5,[R0, #+18]
        ORRS     R5,R5,#0x2
        STRB     R5,[R0, #+18]
        CMP      R3,#+4
        BCC.N    ??App_init_1
        ADDS     R2,R2,#+1
        UXTH     R2,R2
        CMP      R2,#+13
        BCC.N    ??App_init_0
//  110   for(i=0; i<9; i++)                     Meter[i].Flag    |= UPDAT;
        LDR.N    R5,??App_init_2  ;; Meter
        MOVS     R0,#+0
??App_init_3:
        MOVS     R2,R0
        MOVS     R3,#+12
        ADDS     R0,R0,#+1
        MLA      R2,R2,R3,R5
        UXTH     R0,R0
        LDRB     R3,[R2, #+11]
        ORRS     R3,R3,#0x2
        STRB     R3,[R2, #+11]
        CMP      R0,#+9
        BCC.N    ??App_init_3
//  111   if(Current != FILE) {
        LDR.N    R0,??App_init_2+0x4  ;; Current
        LDRB     R0,[R0, #+0]
        CMP      R0,#+9
        BEQ.N    ??App_init_4
//  112     Title[FILE][0].Flag &= !UPDAT;
        ADDW     R0,R4,#+738
//  113     Title[FILE][1].Flag &= !UPDAT;
//  114     Title[FILE][3].Flag &= !UPDAT;
        STRB     R1,[R4, #+798]
        STRB     R1,[R0, #+0]
        STRB     R1,[R0, #+20]
//  115   }  
//  116   PD_Cnt = 600;
??App_init_4:
        LDR.N    R0,??App_init_2+0x8  ;; PD_Cnt
        MOVS     R1,#+600
        STRH     R1,[R0, #+0]
//  117   Update = 1;                  // 返回后恢复原来的档位设置//Load the previous setting of gears
        LDR.N    R0,??App_init_2+0xC  ;; Update
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  118 }
        POP      {R4,R5,R7,PC}
        DATA
??App_init_2:
        DC32     Meter
        DC32     Current
        DC32     PD_Cnt
        DC32     Update
        CFI EndBlock cfiBlock0
//  119 /*******************************************************************************
//  120  View_init: 显示窗口波形数据初始化
//  121              Init the data of wave
//  122 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function View_init
        THUMB
//  123 void View_init(void)
//  124 { 
View_init:
        PUSH     {R4,R6-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  125   u16 i, j = 0, k = 0;
        MOVS     R6,#+0
//  126   for(i = 0; i < X_SIZE * 4; i += 4){
        MOVS     R4,#+0
        MOV      R8,R6
        B.N      ??View_init_0
//  127     TrackBuff[i] = 160;
??View_init_1:
        LDR.N    R0,??DataTable1  ;; TrackBuff
        ADDS     R7,R0,R4
        MOVS     R0,#+160
        STRB     R0,[R7, #+0]
//  128     TrackBuff[i+1] = Get_Ref_Wave(i/4);
        LSRS     R0,R4,#+2
        UXTH     R0,R0
        _BLF     Get_Ref_Wave,??Get_Ref_Wave??rT
        STRB     R0,[R7, #+1]
//  129     if((i%160)==0) j = 1 - j;
        MOVS     R0,R4
        MOVS     R1,#+160
        _BLF     ??div32_t,??rT??div32_t
        CBNZ     R0,??View_init_2
        MOVS     R0,#+1
        MOV      R1,R8
        SUBS     R0,R0,R1
        UXTH     R0,R0
        MOV      R8,R0
//  130     TrackBuff[i+2] = 60 + (j * 17);
??View_init_2:
        MOVS     R0,#+17
        MUL      R0,R8,R0
        ADDS     R0,R0,#+60
        STRB     R0,[R7, #+2]
//  131     if((i%64)==0) k = 1 - k;
        LSRS     R0,R4,#+6
        UXTH     R0,R0
        SUBS     R0,R4,R0, LSL #+6
        ITTT    EQ 
        MOVEQ    R0,#+1
        SUBEQ    R6,R0,R6
        UXTHEQ   R6,R6
//  132     TrackBuff[i+3] = 20 + (k * 17);
        MOVS     R0,#+17
//  133   }
        ADDS     R4,R4,#+4
        MULS     R0,R6,R0
        ADDS     R0,R0,#+20
        STRB     R0,[R7, #+3]
        UXTH     R4,R4
??View_init_0:
        MOVS     R1,#+1200
        CMP      R4,R1
        BCC.N    ??View_init_1
//  134 }
        POP      {R4,R6-R8,PC}
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     TrackBuff
//  135 /*******************************************************************************
//  136  Update_Range: 
//  137 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Update_Range
        THUMB
//  138 void Update_Range(void) 
//  139 {
Update_Range:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  140   Interlace = 0;
        LDR.N    R4,??DataTable8  ;; V
//  141   __Set(ADC_MODE, SEPARATE);                        // Set Separate mode
//  142   __Set(CH_A_COUPLE, Title[TRACK1][COUPLE].Value);
        LDR.N    R5,??DataTable3  ;; Title
//  143   __Set(CH_A_RANGE,  Title[TRACK1][RANGE].Value);
//  144   __Set(CH_A_OFFSET, (Ka3 * Title[TRACK1][POSI].Value)/256);
        LDR.N    R7,??Update_Range_0  ;; Ka3
        MOVS     R0,#+0
        MOVS     R6,R5
        ADDS     R6,R6,#+16
        STRB     R0,[R4, #+16]
        MOVS     R1,#+0
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R6, #+20]
        MOVS     R0,#+9
//  145   if(_1_source == HIDE){
        ADDW     R8,R5,#+336
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R6, #+40]
        MOVS     R0,#+10
        _BLF     __Set,??__Set??rT
        LDRH     R0,[R7, #+0]
        LDRSH    R1,[R6, #+60]
        MULS     R0,R1,R0
        ASRS     R1,R0,#+7
        ADDS     R0,R0,R1, LSR #+24
        ASRS     R1,R0,#+8
        MOVS     R0,#+0
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R6, #+0]
        CBNZ     R0,??Update_Range_1
//  146     if(_T_base > 16){
        LDRSH    R0,[R8, #+100]
        CMP      R0,#+17
        BLT.N    ??Update_Range_1
//  147       __Set(CH_A_RANGE, G_Attr[0].Yp_Max+1);        // A通道合并到B通道 //integrate CHA to CHB
        LDR      R0,[R7, #+4]
        LDRH     R1,[R0, #+4]
        MOVS     R0,#+10
        ADDS     R1,R1,#+1
        _BLF     __Set,??__Set??rT
//  148       __Set(ADC_MODE, INTERLACE);                   // Set Interlace mode
        MOVS     R1,#+1
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
//  149       Interlace = 1;                      
        MOVS     R0,#+1
        STRB     R0,[R4, #+16]
//  150     }  
//  151   }
//  152   __Set(CH_B_COUPLE, Title[TRACK2][COUPLE].Value);
??Update_Range_1:
        LDRSH    R1,[R6, #+100]
        MOVS     R0,#+11
        _BLF     __Set,??__Set??rT
//  153   __Set(CH_B_RANGE,  Title[TRACK2][RANGE].Value);
        LDRSH    R1,[R6, #+120]
        MOVS     R0,#+12
        _BLF     __Set,??__Set??rT
//  154   __Set(CH_B_OFFSET, (Kb3 * Title[TRACK2][POSI].Value)/256);
        LDRH     R0,[R7, #+2]
        LDRSH    R1,[R5, #+156]
        MULS     R0,R1,R0
        ASRS     R1,R0,#+7
        ADDS     R0,R0,R1, LSR #+24
        ASRS     R1,R0,#+8
        MOVS     R0,#+1
        _BLF     __Set,??__Set??rT
//  155   if(_2_source == HIDE){
        LDRSH    R0,[R6, #+80]
        CBNZ     R0,??Update_Range_2
//  156     if(_T_base > 16){
        LDRSH    R0,[R8, #+100]
        CMP      R0,#+17
        BLT.N    ??Update_Range_2
//  157       __Set(CH_B_RANGE,  G_Attr[0].Yp_Max+1);      // B通道合并到A通道//integrate CHB to CHA
        LDR      R0,[R7, #+4]
        LDRH     R1,[R0, #+4]
        MOVS     R0,#+12
        ADDS     R1,R1,#+1
        _BLF     __Set,??__Set??rT
//  158       __Set(ADC_MODE, INTERLACE);                  // Set Interlace mode
        MOVS     R1,#+1
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
//  159       Interlace = 2;                        
        MOVS     R0,#+2
        STRB     R0,[R4, #+16]
//  160     }
//  161   } 
//  162   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);       // FIFO写指针复位//Reset the write pointer of FIFO
??Update_Range_2:
        LDRSH    R0,[R8, #+0]
        CBNZ     R0,??Update_Range_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  163 }
??Update_Range_3:
        POP      {R4-R8,PC}       ;; return
        DATA
??Update_Range_0:
        DC32     Ka3
        CFI EndBlock cfiBlock2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     Title
//  164 /*******************************************************************************
//  165  Update_Base: 
//  166 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Update_Base
        THUMB
//  167 void Update_Base(void) 
//  168 {
Update_Base:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  169   u16 i;
//  170   
//  171   __Set(ADC_CTRL, EN);       
//  172   i = Title[T_BASE][BASE].Value;
        LDR.N    R4,??Update_Base_0  ;; Title + 336
        MOVS     R1,#+1
//  173   __Set(T_BASE_PSC, X_Attr[i].PSC);
        LDR.N    R6,??DataTable8  ;; V
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        LDRSH    R5,[R4, #+100]
        MOVS     R0,#+20
        UXTH     R5,R5
        MULS     R5,R0,R5
        LDR      R0,[R6, #+124]
        ADDS     R0,R0,R5
        LDRSH    R1,[R0, #+8]
        MOVS     R0,#+7
        _BLF     __Set,??__Set??rT
//  174   __Set(T_BASE_ARR, X_Attr[i].ARR);
        LDR      R0,[R6, #+124]
        ADDS     R0,R0,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+8
        _BLF     __Set,??__Set??rT
//  175   Wait_Cnt = Wait[_T_base];
        LDR.N    R2,??DataTable5  ;; Wait
        LDR.N    R0,??DataTable6  ;; Wait_Cnt
        LDRSH    R1,[R4, #+100]
        LDRH     R1,[R2, R1, LSL #+1]
        STR      R1,[R0, #+0]
//  176   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位//Reset the write pointer of FIFO
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Base_1
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  177 }
??Update_Base_1:
        POP      {R4-R6,PC}       ;; return
        DATA
??Update_Base_0:
        DC32     Title + 336
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     Wait_Cnt
//  178 /*******************************************************************************
//  179  Update_Output: 
//  180 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Update_Output
        THUMB
//  181 void Update_Output(void) 
//  182 {
Update_Output:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  183   if(_Kind == SINE){
        LDR.N    R4,??Update_Output_0  ;; Title + 496
        LDR.N    R5,??Update_Output_0+0x4  ;; 0x40020450
        LDR.N    R6,??Update_Output_0+0x8  ;; A_Tab
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Output_1
//  184     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  185     (*((vu32 *)(0x40020400+0x50))) = (u32)&SIN_DATA[0];
        MOVS     R0,R6
        ADDS     R0,R0,#+132
        STR      R0,[R5, #+0]
//  186     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  187   }
//  188   if(_Kind == SAW){
??Update_Output_1:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+2
        BNE.N    ??Update_Output_2
//  189     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  190     (*((vu32 *)(0x40020400+0x50))) = (u32)&SAW_DATA[0];
        ADDW     R0,R6,#+276
        STR      R0,[R5, #+0]
//  191     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  192   }
//  193   if(_Kind == TRIANG){
??Update_Output_2:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Output_3
//  194     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
//  195     (*((vu32 *)(0x40020400+0x50))) = (u32)&TRG_DATA[0];
        ADDS     R6,R6,#+204
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
        STR      R6,[R5, #+0]
//  196     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  197   }
//  198   if(_Kind == DIGI){
??Update_Output_3:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+3
        BNE.N    ??Update_Output_4
//  199     __Set(DIGTAL_PSC, D_Tab[_Frqn].PSC);
        LDRSH    R0,[R4, #+20]
        LDR.N    R5,??Update_Output_0+0xC  ;; D_Tab
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+8]
        MOVS     R0,#+16
        _BLF     __Set,??__Set??rT
//  200     __Set(DIGTAL_ARR, D_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+17
        _BLF     __Set,??__Set??rT
//  201     __Set(DIGTAL_CCR, (D_Tab[_Frqn].ARR+1)/2);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R0,[R0, #+10]
        ADDS     R0,R0,#+1
        ADDS     R0,R0,R0, LSR #+31
        ASRS     R1,R0,#+1
        MOVS     R0,#+18
        _BLF     __Set,??__Set??rT
//  202   }
//  203 }
??Update_Output_4:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??Update_Output_0:
        DC32     Title + 496
        DC32     0x40020450
        DC32     A_Tab
        DC32     D_Tab
        CFI EndBlock cfiBlock4
//  204 /*******************************************************************************
//  205  Update_Trig: 
//  206 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function Update_Trig
        THUMB
//  207 void Update_Trig(void) 
//  208 { 
Update_Trig:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  209   if(T1 > T2)  __Set(T_THRESHOLD, (_T1 - _T2));  
//  210   else         __Set(T_THRESHOLD, (_T2 - _T1)); 
        LDR.N    R4,??DataTable7  ;; Title
//  211   __Set(TRIGG_MODE,  (_Tr_source<< 3)+_Tr_kind);
//  212   if(Title[TRIGG][SOURCE].Value == TRACK1){ 
        LDR.N    R6,??DataTable8  ;; V
        LDR.N    R7,??Update_Trig_0  ;; V_Trigg
        ADDW     R0,R4,#+816
        LDRSH    R1,[R0, #+20]
        LDRSH    R0,[R0, #+0]
        ADDW     R5,R4,#+576
        ADDW     R8,R4,#+56
        SUBS     R1,R1,R0
        MOVS     R0,#+34
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        LDRSH    R1,[R5, #+20]
        ADDS     R1,R1,R0, LSL #+3
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        CBNZ     R0,??Update_Trig_1
        LDRSH    R0,[R8, #+0]
        LDRSH    R1,[R7, #+0]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+80]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+40]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  213     __Set(V_THRESHOLD, (((_Vt1-Ka1[_A_Range])*1024)/Ka2[_A_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  214   }
//  215   if(Title[TRIGG][SOURCE].Value == TRACK2){ 
??Update_Trig_1:
        LDRSH    R0,[R5, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Trig_2
        LDRSH    R0,[R8, #+80]
        LDRSH    R1,[R7, #+4]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+92]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+60]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  216     __Set(V_THRESHOLD, (((_Vt2-Kb1[_B_Range])*1024)/Kb2[_B_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  217   }
//  218   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位//Reset the write pointer of FIFO
??Update_Trig_2:
        LDRSH    R0,[R4, #+336]
        CBNZ     R0,??Update_Trig_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  219 }
??Update_Trig_3:
        POP      {R4-R8,PC}       ;; return
        DATA
??Update_Trig_0:
        DC32     V_Trigg
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     V
//  220 /*******************************************************************************
//  221  Process: 计算处理缓冲区数据 
//  222           Handle the data in buffer
//  223 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function Process
        THUMB
//  224 void Process(void)
//  225 { 
Process:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
//  226   s16 i, j, k;
//  227   
//  228   n= 0;
        LDR.N    R4,??Process_0   ;; V
        SUB      SP,SP,#+24
        CFI CFA R13+60
        MOVS     R0,#+0
//  229   k =((1024 -_Kp)* 150)/1024 + _X_posi.Value;  // 计算插值运算后窗口位置的修正值//Calculate the correction of window position
        LDR      R3,[R4, #+124]
        MOV      R8,R0
        STRH     R0,[R4, #+38]
        LDR.N    R0,??Process_0+0x4  ;; Title
        MOVS     R2,#+20
        ADDW     R9,R0,#+436
        LDRSH    R1,[R9, #+0]
        MLA      R1,R1,R2,R3
        MOVS     R2,#+150
        LDRH     R1,[R1, #+14]
//  230   a_Avg =0; b_Avg =0; a_Ssq =0; b_Ssq =0;      // 统计用中间变量//Variable for statistics
        STR      R8,[R4, #+104]
        STR      R8,[R4, #+108]
        RSBS     R1,R1,#+1024
        STR      R8,[R4, #+112]
        MULS     R1,R2,R1
        ASRS     R2,R1,#+9
        STR      R8,[R4, #+116]
        ADDS     R1,R1,R2, LSR #+22
        LDRSH    R2,[R9, #+20]
        ASRS     R1,R1,#+10
        ADDS     R1,R1,R2
        SXTH     R1,R1
        STR      R1,[SP, #+12]
//  231   a_max =0; b_max =0; a_min =255; b_min =255;  // 统计用中间变量//Variable for statistics
        MOVS     R1,#+0
        STRH     R1,[R4, #+12]
        MOVS     R1,#+255
        STRB     R1,[R4, #+14]
        STRB     R1,[R4, #+15]
//  232 
//  233   if(Interlace == 0){                          // 独立采样模式//Sample the 2 channels independently
        MOVS     R1,R0
        ADDS     R0,R0,#+56
        MOV      R10,R0
        LDR.N    R0,??Process_0+0x8  ;; TrackBuff
        ADDS     R1,R1,#+236
        STR      R1,[SP, #+16]
        MOV      R11,R0
        LDRB     R0,[R4, #+16]
        CMP      R0,#+0
        BNE.W    ??Process_1
//  234     for(i=0; i <4096; i++){
        MOVS     R5,#+0
        B.N      ??Process_2
??Process_3:
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        CMP      R5,#+4096
        BGE.W    ??Process_4
//  235       if((__Get(FIFO_EMPTY)==0)&&(i == JumpCnt)&&(_Status == RUN)){
??Process_2:
        LDR.N    R0,??Process_0+0xC  ;; DataBuf
        ADDS     R6,R0,R5, LSL #+2
        MOVS     R0,#+1
        _BLF     __Get,??__Get??rT
        CBNZ     R0,??Process_5
        LDRH     R0,[R4, #+36]
        CMP      R5,R0
        BNE.N    ??Process_5
        LDR      R1,[SP, #+16]
        LDRSH    R1,[R1, #+100]
        CBNZ     R1,??Process_5
//  236         JumpCnt++;
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+36]
//  237         DataBuf[i] = __Read_FIFO();             // 读入32位FIFO数据, 读后指针+1//Load the 32 bits data in FIFO, and then increase the pointer by 1
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        STR      R0,[R6, #+0]
//  238       }
//  239       Ch[A] = (DataBuf[i] & 0xFF );              
??Process_5:
        LDR      R2,[R6, #+0]
//  240       a_Avg += Ch[A];                           // 累计直流平均值 //Cal average of DC             
        LDR      R0,[R4, #+104]
//  241       Tmp = Ch[A]-_1_posi;
        LDRSH    R3,[R10, #+20]
//  242       a_Ssq +=(Tmp * Tmp);                      // 统计平方和//Cal the Sum of the squares
        LDR      R6,[R4, #+112]
        STRB     R2,[R4, #+8]
        LDRB     R1,[R4, #+8]
        ADDS     R0,R0,R1
        STR      R0,[R4, #+104]
        MOVS     R0,R1
        SUBS     R3,R0,R3
        STR      R3,[R4, #+120]
        MLA      R3,R3,R3,R6
        STR      R3,[R4, #+112]
//  243       if(Ch[A] > a_max)  a_max = Ch[A];         // 统计最大值 //Tracing the maxmum 
        LDRB     R3,[R4, #+12]
        CMP      R3,R1
        IT      CC 
        STRBCC   R1,[R4, #+12]
//  244       if(Ch[A] < a_min)  a_min = Ch[A];         // 统计最小值   //Tracing the minmum 
        LDRB     R3,[R4, #+14]
        CMP      R1,R3
        IT      CC 
        STRBCC   R1,[R4, #+14]
//  245   
//  246   
//  247       Ch[B] = ((DataBuf[i] >> 8) & 0xFF);       
//  248       b_Avg += Ch[B];                           // 累计直流平均值//Cal average of DC
//  249       Tmp = Ch[B]-_2_posi;
        LDRSH    R6,[R10, #+100]
//  250       b_Ssq +=(Tmp * Tmp);                      // 统计平方和//Cal the Sum of the squares
        LDR      R7,[R4, #+116]
        LSRS     R1,R2,#+8
        STRB     R1,[R4, #+9]
        LDRB     R3,[R4, #+9]
        LDR      R1,[R4, #+108]
        ADDS     R1,R1,R3
        STR      R1,[R4, #+108]
        MOVS     R1,R3
        SUBS     R6,R1,R6
        STR      R6,[R4, #+120]
        MLA      R6,R6,R6,R7
        STR      R6,[R4, #+116]
//  251       if(Ch[B] > b_max)  b_max = Ch[B];         // 统计最大值  //Tracing the maxmum  
        LDRB     R6,[R4, #+13]
        CMP      R6,R3
        IT      CC 
        STRBCC   R3,[R4, #+13]
//  252       if(Ch[B] < b_min)  b_min = Ch[B];         // 统计最小值   //Tracing the minmum
        LDRB     R6,[R4, #+15]
        CMP      R3,R6
        IT      CC 
        STRBCC   R3,[R4, #+15]
        LSRS     R3,R2,#+16
        MOVS     R6,#+1
        ANDS     R6,R6,R3
        STRB     R6,[R4, #+10]
//  253   
//  254       Ch[C] = ((DataBuf[i] >>16)& 1);           //C and D channel are 1 bits only
//  255       Ch[D] = ((DataBuf[i] >>17)& 1);
        LSRS     R2,R2,#+17
        MOVS     R3,#+1
        ANDS     R3,R3,R2
        STRB     R3,[R4, #+11]
//  256     
//  257       if((i > k)&&(n < 300-1)){                 // 指针到达指定窗口位置//The pointer increase to the window set by" k"
        LDR      R2,[SP, #+12]
        CMP      R2,R5
        BGE.N    ??Process_3
        LDRH     R2,[R4, #+38]
        LDR.N    R3,??Process_6   ;; 0x12b
        CMP      R2,R3
        BCS.N    ??Process_3
//  258         j =i-k;
        LDR      R3,[SP, #+12]
        SUBS     R6,R5,R3
        LDRSH    R3,[R10, #+0]
        SXTH     R6,R6
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+40]
        MULS     R2,R0,R2
        ADDS     R0,R4,R3
        LDRSB    R0,[R0, #+80]
        ASRS     R3,R2,#+9
        ADDS     R2,R2,R3, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R0,R0,R2
        LDRSH    R2,[R10, #+80]
        STRB     R0,[R4, #+0]
        ADDS     R0,R4,R2, LSL #+1
        LDRH     R0,[R0, #+60]
        MULS     R0,R1,R0
        ADDS     R1,R4,R2
        LDRSB    R1,[R1, #+92]
        ASRS     R2,R0,#+9
        ADDS     R0,R0,R2, LSR #+22
        LDR      R2,[R4, #+124]
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRB     R0,[R4, #+1]
        LDRSH    R0,[R9, #+0]
        MOVS     R1,#+20
        MLA      R0,R0,R1,R2
        STR      R0,[SP, #+4]
        B.N      ??Process_7
//  259         V[A]  = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A])/1024;      
//  260         V[B]  = Kb1[_B_Range] +(Kb2[_B_Range] *Ch[B])/1024;      //计算当前点的主值//Cal the current V for channel A and B
//  261         while(j*1024 - n*_Kp > 0 ){
//  262           V[Ap]= V[A_]+((V[A]-V[A_])*((n *_Kp)-(j-1)*1024))/1024;  //计算当前CH_A点的插值//Get the interpolation of waveform 1
//  263           TrackBuff[n*4 + TRACK1] = V[Ap];
//  264           
//  265           V[Bp]= V[B_]+((V[B]-V[B_])*((n *_Kp)-(j-1)*1024))/1024;  //计算当前CH_B点的插值//Get the interpolation of waveform 2
//  266           TrackBuff[n*4 + TRACK2] = V[Bp];
//  267           
//  268           Tmp = _3_posi + 20 * Ch[C];
//  269           if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
//  270           else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??Process_8:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
??Process_9:
        STR      R0,[R4, #+120]
//  271           TrackBuff[n*4 + TRACK3] = Tmp;
        LDR      R1,[SP, #+0]
//  272           
//  273           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
//  274           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+2]
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+3]
//  275         V[A_] = V[A];  V[B_] = V[B];       
        LDRB     R0,[R4, #+0]
        STRH     R7,[R4, #+38]
        STRB     R0,[R4, #+2]
        LDRB     R0,[R4, #+1]
        STRB     R0,[R4, #+3]
??Process_7:
        LDR      R2,[SP, #+4]
        LDRH     R7,[R4, #+38]
        LSLS     R1,R6,#+10
        LDRH     R2,[R2, #+14]
        MOVS     R0,R7
        MLS      R1,R0,R2,R1
        CMP      R1,#+1
        BLT.W    ??Process_3
        SUBS     R1,R6,#+1
        LSLS     R1,R1,#+10
        STR      R1,[SP, #+8]
        LDRB     R1,[R4, #+2]
        LDRB     R2,[R4, #+0]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+8]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        ADDS     R2,R11,R0, LSL #+2
        STRB     R1,[R4, #+4]
        STR      R2,[SP, #+0]
        STRB     R1,[R2, #+0]
        LDR      R3,[SP, #+4]
        LDRB     R1,[R4, #+3]
        LDRB     R2,[R4, #+1]
        LDRH     R3,[R3, #+14]
        SUBS     R2,R2,R1
        MULS     R0,R3,R0
        LDR      R3,[SP, #+8]
        SUBS     R0,R0,R3
        MULS     R2,R0,R2
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRB     R0,[R4, #+5]
        LDR      R1,[SP, #+0]
        MOVS     R2,#+20
        STRB     R0,[R1, #+1]
        LDR      R0,[SP, #+16]
        LDRB     R1,[R4, #+10]
        LDRSH    R0,[R0, #+0]
        MLA      R0,R1,R2,R0
        CMP      R0,#+200
        BLT.N    ??Process_8
        MOVS     R0,#+199
        B.N      ??Process_9
//  276         }
//  277       }
//  278     }
//  279   } else {                                      // 交替采样模式//When channel A or B is hiden,interlace mode
//  280     for(i=0; i <4096; i++){
??Process_1:
        MOVS     R5,#+0
//  281       if((__Get(FIFO_EMPTY)==0)&&(i == JumpCnt)&&(_Status == RUN)){
??Process_10:
        LDR.N    R0,??Process_0+0xC  ;; DataBuf
        ADDS     R6,R0,R5, LSL #+2
        MOVS     R0,#+1
        _BLF     __Get,??__Get??rT
        CBNZ     R0,??Process_11
        LDRH     R0,[R4, #+36]
        CMP      R5,R0
        BNE.N    ??Process_11
        LDR      R1,[SP, #+16]
        LDRSH    R1,[R1, #+100]
        CBNZ     R1,??Process_11
//  282         JumpCnt++;
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+36]
//  283         DataBuf[i] = __Read_FIFO();             // 读入32位FIFO数据, 读后指针+1//Load the 32 bits data in FIFO, and then increase the pointer by 1
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        STR      R0,[R6, #+0]
//  284       }
//  285       Ch[A] = (DataBuf[i] & 0xFF );              
??Process_11:
        LDR      R2,[R6, #+0]
//  286       Ch[B] = ((DataBuf[i] >> 8) & 0xFF);       
//  287 
//  288       a_Avg += Ch[A]+Ch[B];                                   
        LDR      R3,[R4, #+104]
        STRB     R2,[R4, #+8]
//  289       b_Avg = a_Avg;                            // 累计直流平均值//Cal average of DC
//  290       
//  291       Tmp = Ch[A]-_1_posi;
//  292       a_Ssq +=(Tmp * Tmp);
        LDR      R7,[R4, #+112]
        LSRS     R0,R2,#+8
        STRB     R0,[R4, #+9]
        LDRB     R0,[R4, #+8]
        LDRB     R1,[R4, #+9]
        ADDS     R6,R0,R1
        ADDS     R3,R3,R6
        STR      R3,[R4, #+104]
        STR      R3,[R4, #+108]
        LDRSH    R3,[R10, #+20]
        SUBS     R6,R0,R3
        STR      R6,[R4, #+120]
        MLA      R6,R6,R6,R7
//  293       Tmp = Ch[B]-_1_posi;
        SUBS     R3,R1,R3
        STR      R3,[R4, #+120]
//  294       a_Ssq +=(Tmp * Tmp);                    
        MLA      R3,R3,R3,R6
        STR      R6,[R4, #+112]
        STR      R3,[R4, #+112]
//  295       b_Ssq  = a_Ssq;                           // 统计平方和//Cal the Sum of the squares
        STR      R3,[R4, #+116]
//  296       
//  297       if(Ch[A] > a_max)  a_max = Ch[A];          
        LDRB     R3,[R4, #+12]
        CMP      R3,R0
        IT      CC 
        STRBCC   R0,[R4, #+12]
//  298       if(Ch[B] > a_max)  a_max = Ch[B];         // 统计最大值 //Tracing the maxmum 
        LDRB     R3,[R4, #+12]
        CMP      R3,R1
        IT      CC 
        STRBCC   R1,[R4, #+12]
//  299       b_max = a_max;
        LDRB     R3,[R4, #+12]
        STRB     R3,[R4, #+13]
//  300       
//  301       if(Ch[A] < a_min)  a_min = Ch[A];         
        LDRB     R3,[R4, #+14]
        CMP      R0,R3
        IT      CC 
        STRBCC   R0,[R4, #+14]
//  302       if(Ch[B] < a_min)  a_min = Ch[B];         // 统计最小值 //Tracing the minnu  
        LDRB     R3,[R4, #+14]
        CMP      R1,R3
        IT      CC 
        STRBCC   R1,[R4, #+14]
//  303       b_min = a_min;
        LDRB     R3,[R4, #+14]
        MOVS     R6,#+1
        STRB     R3,[R4, #+15]
        LSRS     R3,R2,#+16
        ANDS     R6,R6,R3
        STRB     R6,[R4, #+10]
//  304   
//  305       Ch[C] = ((DataBuf[i] >>16)& 1);
//  306       Ch[D] = ((DataBuf[i] >>17)& 1);
        LSRS     R2,R2,#+17
        MOVS     R3,#+1
        ANDS     R3,R3,R2
//  307     
//  308       if(_2_source == HIDE){                 // B通道合并到A通道时//If channel B is hiden
        LDRSH    R2,[R10, #+40]
        STRB     R3,[R4, #+11]
        CBNZ     R2,??Process_12
        LDRSH    R3,[R10, #+0]
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+40]
        ADDS     R3,R4,R3
        LDRSB    R3,[R3, #+80]
        MULS     R0,R2,R0
        ASRS     R6,R0,#+9
//  309         V[A] = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A])/1024;        //计算当前第1点的主值//Cal the main value of 1st current data
//  310         V[B] = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[B])/1024;        //计算当前第2点的主值//Cal the main value of 2nd current data
        MULS     R2,R1,R2
        ADDS     R0,R0,R6, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+0]
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
        B.N      ??Process_13
//  311       } else {                            // A通道合并到B通道时//If channel A is hiden
??Process_12:
        LDRSH    R3,[R10, #+80]
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+60]
        ADDS     R3,R4,R3
        LDRSB    R3,[R3, #+92]
        MULS     R0,R2,R0
        ASRS     R6,R0,#+9
//  312         V[A] = Kb1[_B_Range] +(Kb2[_B_Range] * Ch[A])/1024;        //计算当前第1点的主值//Cal the main value of 1st current data
//  313         V[B] = Kb1[_B_Range] +(Kb2[_B_Range] * Ch[B])/1024;        //计算当前第2点的主值//Cal the main value of 2nd current data
        MULS     R2,R1,R2
        ADDS     R0,R0,R6, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+0]
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
??Process_13:
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+1]
//  314       }
//  315       if((i > k)&&(n < 300-1)){                 // 指针到达指定窗口位置//The pointer increase to the window set by" k"
        LDR      R0,[SP, #+12]
        CMP      R0,R5
        BGE.W    ??Process_14
        LDRH     R0,[R4, #+38]
        LDR.N    R1,??Process_6   ;; 0x12b
        CMP      R0,R1
        BCS.W    ??Process_14
//  316         j =i - k;
        LDR      R1,[SP, #+12]
        LDRSH    R0,[R9, #+0]
        LDR      R2,[R4, #+124]
        SUBS     R6,R5,R1
        MOVS     R1,#+20
        SXTH     R6,R6
        MLA      R0,R0,R1,R2
        STR      R0,[SP, #+4]
        B.N      ??Process_15
//  317         while(j*1024 > n*_Kp){
//  318           V[Bp] =V[A_]+((V[B]-V[A_])*((n *_Kp)-(j-1)*1024))/1024;  
//  319           TrackBuff[n*4 + TRACK1] = V[Bp];
//  320           TrackBuff[n*4 + TRACK2] = V[Bp];
//  321           Tmp = _3_posi + 20 * Ch[C];
//  322           if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
//  323           else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??Process_16:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
??Process_17:
        STR      R0,[R4, #+120]
//  324           TrackBuff[n*4 + TRACK3] = Tmp;
        LDR      R1,[SP, #+0]
//  325           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
//  326           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+2]
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+3]
        STRH     R7,[R4, #+38]
??Process_15:
        LDR      R0,[SP, #+16]
        LDRB     R1,[R4, #+10]
        MOVS     R2,#+20
        LDRSH    R0,[R0, #+0]
        MLA      R0,R1,R2,R0
        SUBS     R1,R6,#+1
        LSLS     R1,R1,#+10
        STR      R0,[SP, #+8]
        LDRH     R7,[R4, #+38]
        STR      R1,[SP, #+20]
        LDR      R1,[SP, #+4]
        MOVS     R0,R7
        LDRH     R1,[R1, #+14]
        MULS     R1,R0,R1
        CMP      R1,R6, LSL #+10
        BGE.N    ??Process_18
        LDRB     R1,[R4, #+2]
        LDRB     R2,[R4, #+1]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+20]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        ADDS     R0,R11,R0, LSL #+2
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        STRB     R1,[R4, #+5]
        STR      R0,[SP, #+0]
        STRB     R1,[R0, #+0]
        LDR      R0,[SP, #+0]
        STRB     R1,[R0, #+1]
        LDR      R0,[SP, #+8]
        CMP      R0,#+200
        BLT.N    ??Process_16
        MOVS     R0,#+199
        B.N      ??Process_17
        DATA
??Process_0:
        DC32     V
        DC32     Title
        DC32     TrackBuff
        DC32     DataBuf
        THUMB
//  327         }
//  328         while(j*1024 > n*_Kp){
//  329           V[Ap] =V[B]+((V[A]-V[B])*((n *_Kp)-(j-1)*1024))/1024;   
//  330           TrackBuff[n*4 + TRACK1] = V[Ap];
//  331           TrackBuff[n*4 + TRACK2] = V[Ap];
//  332           Tmp = _3_posi + 20 * Ch[C];
//  333           if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
//  334           else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??Process_19:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
??Process_20:
        STR      R0,[R4, #+120]
//  335           TrackBuff[n*4 + TRACK3] = Tmp;
        LDR      R1,[SP, #+0]
//  336           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
//  337           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+2]
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+3]
        STRH     R7,[R4, #+38]
??Process_18:
        LDR      R1,[SP, #+4]
        LDRH     R7,[R4, #+38]
        LDRB     R2,[R4, #+0]
        LDRH     R1,[R1, #+14]
        MOVS     R0,R7
        MULS     R1,R0,R1
        CMP      R1,R6, LSL #+10
        BGE.N    ??Process_21
        LDRB     R1,[R4, #+1]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+20]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        ADDS     R0,R11,R0, LSL #+2
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        STRB     R1,[R4, #+4]
        STR      R0,[SP, #+0]
        STRB     R1,[R0, #+0]
        LDR      R0,[SP, #+0]
        STRB     R1,[R0, #+1]
        LDR      R0,[SP, #+8]
        CMP      R0,#+200
        BLT.N    ??Process_19
        MOVS     R0,#+199
        B.N      ??Process_20
//  338         }
//  339         V[A_] = V[A]; 
??Process_21:
        STRB     R2,[R4, #+2]
//  340       }
//  341     }
??Process_14:
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        CMP      R5,#+4096
        BLT.W    ??Process_10
//  342   }
//  343   for(i=0; i<4; i++){                                    // 消除屏幕端点连线//Clear up the ligature
??Process_4:
        MOVS     R0,#+0
//  344     for(j=0; j<4; j++){
??Process_22:
        MOVS     R6,#+0
//  345       TrackBuff[(i+0)*4+ j]   = TrackBuff[(i+1)*4 + j];
??Process_23:
        ADDS     R1,R6,R0, LSL #+2
        ADD      R1,R1,R11
        LDRB     R2,[R1, #+4]
        STRB     R2,[R1, #+0]
//  346       TrackBuff[(299-i)*4+ j] = TrackBuff[(298-i)*4 + j];
        RSBS     R1,R0,#+0
        MOV      R2,R11
        ADDS     R1,R6,R1, LSL #+2
        ADDS     R1,R2,R1
        ADDS     R1,R1,#+1192
        LDRB     R2,[R1, #+0]
//  347     }
        ADDS     R6,R6,#+1
        CMP      R6,#+4
        STRB     R2,[R1, #+4]
        BLT.N    ??Process_23
//  348   }
        ADDS     R0,R0,#+1
        CMP      R0,#+4
        BLT.N    ??Process_22
//  349 }
        ADD      SP,SP,#+24
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Process_6:
        DC32     0x12b
        CFI EndBlock cfiBlock6
//  350 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function CH_D_Data
        THUMB
//  351 u8 CH_D_Data(void)  //计算生成CH_D通道的显示数据//Cal the data for channel D
//  352 {
//  353   s32 Tmp;
//  354   
//  355   switch (_4_source){  
CH_D_Data:
        LDR.N    R1,??DataTable11  ;; Title
        LDR.N    R3,??DataTable10  ;; V
        PUSH     {R4-R11}
        CFI R11 Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+12
        CFI CFA R13+44
        LDRSH    R0,[R1, #+316]
        MOVS     R2,R1
        LDRSH    R9,[R1, #+156]!
        LDRSH    R1,[R1, #+100]
        MOV      R8,R3
        LDRB     R3,[R8, #+0]
        LDRB     R5,[R8, #+5]
        LDRB     R6,[R8, #+16]
        ADDS     R2,R2,#+16
        LDRSH    R4,[R2, #+60]
        ADDS     R5,R0,R5
        SUBS     R5,R5,R9
        STR      R5,[SP, #+8]
        LDRB     R5,[R8, #+4]
        ADDS     R3,R0,R3
        SUBS     R3,R3,R4
        ADDS     R5,R0,R5
        SUBS     R4,R5,R4
        LDRB     R5,[R8, #+11]
        STR      R4,[SP, #+4]
        LDR.N    R4,??CH_D_Data_1  ;; FileBuff
        SUBS     R1,R1,#+2
        MOV      R10,R4
        LDRH     R4,[R8, #+38]
        ADDS     R11,R4,R10
        LDRB     R4,[R8, #+1]
        CMP      R1,#+7
        STR      R4,[SP, #+0]
        LDRSH    R4,[R2, #+80]
        LDRSH    R2,[R2, #+0]
        BHI.N    ??CH_D_Data_2
        TBB      [PC, R1]
        DATA
??CH_D_Data_0:
        DC8      +4,+16,+26,+26
        DC8      +33,+40,+45,+52
        THUMB
//  356   case A_add_B:
//  357     if(Interlace == 0){                          // 独立采样模式//Sample independently
??CH_D_Data_3:
        CBNZ     R6,??CH_D_Data_4
//  358       Tmp = _4_posi +(V[A]-_1_posi)+(V[B]-_2_posi);
        LDR      R0,[SP, #+0]
        ADDS     R0,R3,R0
        SUBS     R0,R0,R9
        B.N      ??CH_D_Data_5
//  359     } else {                                     // 交替采样模式//Sample interlacly
//  360       Tmp = _4_posi;
//  361       if(_1_source != HIDE)  Tmp = _4_posi +(V[Ap]-_1_posi);
??CH_D_Data_4:
        CBZ      R2,??CH_D_Data_6
        LDR      R0,[SP, #+4]
//  362       if(_2_source != HIDE)  Tmp = _4_posi +(V[Bp]-_2_posi);
??CH_D_Data_6:
        CMP      R4,#+0
        BEQ.N    ??CH_D_Data_5
??CH_D_Data_7:
        LDR      R0,[SP, #+8]
        B.N      ??CH_D_Data_5
//  363     } break;
//  364   case A_sub_B:
//  365     if(Interlace == 0){                          // 独立采样模式//Sample independently
??CH_D_Data_8:
        CBNZ     R6,??CH_D_Data_9
//  366       Tmp = _4_posi +(V[A]-_1_posi)-(V[B]-_2_posi);  break;
        LDR      R0,[SP, #+0]
        SUBS     R0,R3,R0
        ADDS     R0,R9,R0
        B.N      ??CH_D_Data_5
//  367     } else {                                     // 交替采样模式//Sample interlacly
//  368       Tmp = _4_posi;
//  369       if(_1_source != HIDE)  Tmp = _4_posi +(V[Ap]-_1_posi);
??CH_D_Data_9:
        CBZ      R2,??CH_D_Data_10
        LDR      R0,[SP, #+4]
//  370       if(_2_source != HIDE)  Tmp = _4_posi +(V[Bp]-_2_posi);
??CH_D_Data_10:
        CBZ      R4,??CH_D_Data_5
        B.N      ??CH_D_Data_7
//  371     } break;
//  372   case C_and_D:
//  373     Tmp = _4_posi + 20 *(Ch[C] & Ch[D]);  break;
??CH_D_Data_11:
        LDRB     R1,[R8, #+10]
        ANDS     R5,R5,R1
        MOVS     R1,#+20
        MLA      R0,R5,R1,R0
        B.N      ??CH_D_Data_5
//  374   case C_or_D:
//  375     Tmp =  _4_posi + 20 *(Ch[C] & Ch[D]);  break;
//  376   case FILE1:
//  377     Tmp = FileBuff[n] - FileBuff[299] +_4_posi;  break;
??CH_D_Data_12:
        LDRB     R1,[R11, #+0]
        LDRB     R2,[R10, #+299]
??CH_D_Data_13:
        SUBS     R1,R1,R2
        ADDS     R0,R1,R0
        B.N      ??CH_D_Data_5
//  378   case FILE2:
//  379     Tmp = FileBuff[n+300] - FileBuff[599] +_4_posi;  break;
??CH_D_Data_14:
        LDRB     R1,[R11, #+300]
        LDRB     R2,[R10, #+599]
        B.N      ??CH_D_Data_13
//  380   case FILE3:
//  381     Tmp = FileBuff[n+600] - FileBuff[899] +_4_posi;  break;
??CH_D_Data_15:
        LDRB     R1,[R11, #+600]
        LDRB     R2,[R10, #+899]
        SUBS     R1,R1,R2
        ADDS     R0,R1,R0
        B.N      ??CH_D_Data_5
//  382   case FILE4:
//  383     Tmp = FileBuff[n+900] - FileBuff[1199] +_4_posi;  break;
??CH_D_Data_16:
        LDRB     R1,[R11, #+900]
        LDRB     R2,[R10, #+1199]
        B.N      ??CH_D_Data_13
//  384   default:
//  385     Tmp = _4_posi + 20 * Ch[D];
??CH_D_Data_2:
        MOVS     R1,#+20
        MLA      R0,R5,R1,R0
//  386   }
//  387   if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
??CH_D_Data_5:
        CMP      R0,#+200
        BLT.N    ??CH_D_Data_17
        MOVS     R0,#+199
        B.N      ??CH_D_Data_18
//  388   else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??CH_D_Data_17:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
//  389   return Tmp;
??CH_D_Data_18:
        UXTB     R0,R0
        ADD      SP,SP,#+12
        CFI CFA R13+32
        POP      {R4-R11}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??CH_D_Data_1:
        DC32     FileBuff
        CFI EndBlock cfiBlock7
//  390 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable10:
        DC32     V
//  391 /*******************************************************************************
//  392  Synchro: 扫描同步处理，按设定模式显示波形 
//  393           Hanndle the scanning, and show waveform as the scan mode
//  394 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function Synchro
        THUMB
//  395 void Synchro(void)  //扫描同步方式共有：AUTO、NORM、SIGN、NONE、SCAN 5种模式//Scan mode
//  396 { 
//  397   u16  i;
//  398 
//  399   switch (_Mode){ 
Synchro:
        LDR.N    R0,??DataTable11  ;; Title
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        LDR.N    R4,??DataTable12  ;; V
        MOV      R8,R0
        ADDW     R0,R8,#+576
        LDRSH    R1,[R0, #+0]
        LDRSH    R0,[R0, #+20]
        ADDW     R6,R8,#+336
        MOVS     R7,#+0
        ADDS     R1,R0,R1, LSL #+3
        LDR.N    R0,??DataTable13  ;; Wait
        MOV      R9,R0
        LDR.N    R0,??DataTable14  ;; TrackBuff
        MOV      R10,R0
        LDR.N    R0,??DataTable15  ;; Wait_Cnt
        MOV      R11,R0
        LDRSH    R0,[R6, #+80]
        CMP      R0,#+4
        BHI.N    ??Synchro_1
        TBB      [PC, R0]
        DATA
??Synchro_0:
        DC8      +3,+29,+56,+64
        DC8      +64,+0
        THUMB
//  400   case AUTO:
//  401     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件//Set the trigger Condition
??Synchro_2:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  402     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_3
//  403       Process();                                  // 生成新的显示波形//Generate new wave 
??Synchro_4:
        BL       Process
//  404       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R6, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R11, #+0]
        B.N      ??Synchro_1
//  405     } else if(Wait_Cnt==0){
??Synchro_3:
        LDR      R0,[R11, #+0]
        CMP      R0,#+0
        BNE.N    ??Synchro_1
//  406       if(JumpCnt >= 4095)  JumpCnt = 0;         
        LDRH     R0,[R4, #+36]
        LDR.N    R1,??Synchro_5   ;; 0xfff
        CMP      R0,R1
        BCC.N    ??Synchro_4
        STRH     R7,[R4, #+36]
        B.N      ??Synchro_4
//  407       Process();   
//  408       Wait_Cnt = Wait[_T_base];
//  409     } break;
//  410   case NORM:
//  411     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件//Set the trigger Condition
??Synchro_6:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  412     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CMP      R0,#+0
        BNE.N    ??Synchro_4
//  413       Process();                                  // 生成新的显示波形//Generate new wave
//  414       Wait_Cnt = Wait[_T_base];
//  415     } else if(Wait_Cnt==0){                          //If not triggered in a period of time
        LDR      R0,[R11, #+0]
        CBNZ     R0,??Synchro_1
//  416       for(i=0; i<4*X_SIZE; ++i)  TrackBuff[i] = 0;// 清除旧的显示波形//clear the previous waveform
        MOVS     R3,#+0
??Synchro_7:
        MOV      R2,R10
        STRB     R7,[R2, R0]
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        MOVS     R2,#+1200
        CMP      R0,R2
        BCC.N    ??Synchro_7
//  417       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R6, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R11, #+0]
        B.N      ??Synchro_1
//  418     } break;
//  419   case SIGN:
//  420     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件//Set the trigger Condition
??Synchro_8:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  421     if(__Get(FIFO_START)!=0)  Process();          // 生成新的显示波形//Generate new wave 
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_1
        B.N      ??Synchro_9
//  422     break;
//  423   case NONE:
//  424   case SCAN:
//  425     __Set(TRIGG_MODE, UNCONDITION);               // 设为无条件触发//Trigger with no condition 
??Synchro_10:
        MOVS     R1,#+32
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  426     Process();                                    // 生成当前显示波形//Get current date and generate waveform
??Synchro_9:
        BL       Process
//  427     break;
//  428   }
//  429   Draw_Window();                                  // 刷新屏幕波形显示区//Refresh the wave area of LCD
??Synchro_1:
        _BLF     Draw_Window,??Draw_Window??rT
//  430 
//  431   if((_Status == RUN)&&(__Get(FIFO_FULL)!=0)){    // FIFO is full
        LDRSH    R0,[R6, R7]
        MOV      R5,R8
        ADDS     R5,R5,#+56
        CMP      R0,#+0
        BNE.N    ??Synchro_11
        MOVS     R0,#+3
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_11
//  432     __Set(FIFO_CLR, W_PTR);                       // FIFO写指针复位//Reset the write pointer of FIFO
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  433     Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R6, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R11, #+0]
//  434     JumpCnt =0;
//  435     if(_Mode == SIGN){
        LDRSH    R0,[R6, #+80]
        STRH     R7,[R4, #+36]
        CMP      R0,#+2
        BNE.N    ??Synchro_12
//  436       _Status = HOLD;                             // 一帧完后，进入暂停//Pause when finished one frame.
        MOVS     R0,#+1
        STRH     R0,[R6, #+0]
//  437       _State.Flag |= UPDAT;
        LDRB     R0,[R6, #+2]
        ORRS     R0,R0,#0x2
        STRB     R0,[R6, #+2]
        B.N      ??Synchro_11
//  438     }
//  439     if(_Mode == SCAN){
??Synchro_12:
        CMP      R0,#+4
        BNE.N    ??Synchro_11
//  440       for(i=0; i<X_SIZE; i++){                    // 重建当前轨迹基线  //Recreate the current  baseline if in scan mode                  
        MOVS     R0,#+0
??Synchro_13:
        LDRH     R2,[R5, #+20]
        ADDS     R1,R10,R0, LSL #+2
//  441         TrackBuff[i*4 + TRACK1] = _1_posi;
//  442         TrackBuff[i*4 + TRACK2] = _2_posi; 
//  443         TrackBuff[i*4 + TRACK3] = _3_posi; 
//  444         TrackBuff[i*4 + TRACK4] = _4_posi;
        ADDS     R0,R0,#+1
        STRB     R2,[R1, #+0]
        LDRH     R2,[R5, #+100]
        UXTH     R0,R0
        STRB     R2,[R1, #+1]
        MOV      R2,R8
        LDRH     R3,[R2, #+236]!
        ADDS     R2,R2,#+80
        STRB     R3,[R1, #+2]
        LDRH     R2,[R2, #+0]
        STRB     R2,[R1, #+3]
        MOVS     R2,#+300
        CMP      R0,R2
        BCC.N    ??Synchro_13
??Synchro_11:
        LDRSH    R1,[R5, R7]
        LDR      R2,[R4, #+104]
        ADDS     R0,R4,R1
        LDRSB    R0,[R0, #+80]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+40]
        LSRS     R2,R2,#+10
        MULS     R1,R2,R1
        LDR      R2,[R4, #+108]
        LSRS     R1,R1,#+12
        ADDS     R0,R0,R1
        LDRSH    R1,[R5, #+20]
        LSRS     R2,R2,#+10
        SUBS     R0,R0,R1
        LDRSH    R1,[R5, #+80]
        STRH     R0,[R4, #+18]
        ADDS     R0,R4,R1
        LDRSB    R0,[R0, #+92]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+60]
        MULS     R1,R2,R1
        LSRS     R1,R1,#+12
        ADDS     R0,R0,R1
        LDRSH    R1,[R5, #+100]
        SUBS     R0,R0,R1
        STRH     R0,[R4, #+28]
//  445       }
//  446     }
//  447   }    
//  448   A_Vdc = Ka1[_A_Range] +(Ka2[_A_Range]*(a_Avg/1024))/4096 - _1_posi;  
//  449   B_Vdc = Kb1[_B_Range] +(Kb2[_B_Range]*(b_Avg/1024))/4096 - _2_posi;  
//  450 
//  451   A_Rms = Ka1[_A_Range] +(Ka2[_A_Range]*Int_sqrt(a_Ssq/4096))/1024;
        LDR      R0,[R4, #+112]
        LSRS     R0,R0,#+12
        _BLF     Int_sqrt,??Int_sqrt??rT
        LDRSH    R1,[R5, R7]
        ADDS     R2,R4,R1
        LDRSB    R2,[R2, #+80]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+40]
        MULS     R1,R0,R1
        ADDS     R0,R2,R1, LSR #+10
        STRH     R0,[R4, #+26]
//  452   B_Rms = Kb1[_B_Range] +(Kb2[_B_Range]*Int_sqrt(b_Ssq/4096))/1024;
        LDR      R0,[R4, #+116]
        LSRS     R0,R0,#+12
        _BLF     Int_sqrt,??Int_sqrt??rT
        LDRSH    R1,[R5, #+80]
        LDRB     R3,[R4, #+12]
        LDRSH    R8,[R5, #+20]
        ADDS     R2,R4,R1, LSL #+1
        LDRH     R6,[R2, #+60]
        LDR.N    R2,??Synchro_5+0x4  ;; B_Rms
        ADDS     R1,R4,R1
        LDRSB    R1,[R1, #+92]
        MULS     R0,R6,R0
        ADDS     R0,R1,R0, LSR #+10
        STRH     R0,[R2, #+0]
        LDRSH    R2,[R5, R7]
//  453 
//  454   A_Max = Ka1[_A_Range] +(Ka2[_A_Range]*a_max)/1024 - _1_posi;
//  455   B_Max = Kb1[_B_Range] +(Kb2[_B_Range]*b_max)/1024 - _2_posi;
        LDRSH    R5,[R5, #+100]
        MOV      R9,R6
        LDRB     R6,[R4, #+13]
        ADDS     R0,R4,R2, LSL #+1
        LDRH     R0,[R0, #+40]
        ADDS     R2,R4,R2
        LDRSB    R2,[R2, #+80]
        MUL      R6,R9,R6
        MULS     R3,R0,R3
        ASRS     R7,R3,#+9
        ADDS     R3,R3,R7, LSR #+22
        ASRS     R7,R6,#+9
        ASRS     R3,R3,#+10
        ADDS     R6,R6,R7, LSR #+22
//  456  
//  457   A_Min = Ka1[_A_Range] +(Ka2[_A_Range]*a_min)/1024 - _1_posi;
        LDRB     R7,[R4, #+14]
        ADDS     R3,R2,R3
        SUBS     R3,R3,R8
        STRH     R3,[R4, #+22]
        MULS     R0,R7,R0
        ASRS     R7,R0,#+9
        ASRS     R6,R6,#+10
        ADDS     R0,R0,R7, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R2,R0
//  458   B_Min = Kb1[_B_Range] +(Kb2[_B_Range]*b_min)/1024 - _2_posi;
        LDRB     R2,[R4, #+15]
        ADDS     R6,R1,R6
        SUBS     R6,R6,R5
        STRH     R6,[R4, #+32]
        MUL      R2,R9,R2
        SUBS     R0,R0,R8
        STRH     R0,[R4, #+24]
        ASRS     R7,R2,#+9
//  459     
//  460   A_Vpp = A_Max - A_Min;
        SUBS     R0,R3,R0
        ADDS     R2,R2,R7, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        SUBS     R1,R1,R5
        STRH     R1,[R4, #+34]
        STRH     R0,[R4, #+20]
//  461   B_Vpp = B_Max - B_Min;
        SUBS     R0,R6,R1
        STRH     R0,[R4, #+30]
//  462 }  
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??Synchro_5:
        DC32     0xfff
        DC32     B_Rms
        CFI EndBlock cfiBlock8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable11:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable12:
        DC32     V

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable13:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable14:
        DC32     TrackBuff

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable15:
        DC32     Wait_Cnt

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Set??rT:
        LDR.N    R3,??Subroutine0_0  ;; __Set
        BX       R3
        DATA
??Subroutine0_0:
        DC32     __Set
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Clear_Screen??rT:
        LDR.N    R3,??Subroutine1_0  ;; __Clear_Screen
        BX       R3
        DATA
??Subroutine1_0:
        DC32     __Clear_Screen
        CFI EndBlock cfiBlock10

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI NoFunction
        THUMB
??Delayms??rT:
        LDR.N    R3,??Subroutine2_0  ;; Delayms
        BX       R3
        DATA
??Subroutine2_0:
        DC32     Delayms
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_Ref_Wave??rT:
        LDR.N    R3,??Subroutine3_0  ;; Get_Ref_Wave
        BX       R3
        DATA
??Subroutine3_0:
        DC32     Get_Ref_Wave
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI NoFunction
        THUMB
??rT??div32_t:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine4_0  ;; ??div32_t
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine4_0:
        DC32     ??div32_t
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Get??rT:
        LDR.N    R3,??Subroutine5_0  ;; __Get
        BX       R3
        DATA
??Subroutine5_0:
        DC32     __Get
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Read_FIFO??rT:
        LDR.N    R3,??Subroutine6_0  ;; __Read_FIFO
        BX       R3
        DATA
??Subroutine6_0:
        DC32     __Read_FIFO
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??Draw_Window??rT:
        LDR.N    R3,??Subroutine7_0  ;; Draw_Window
        BX       R3
        DATA
??Subroutine7_0:
        DC32     Draw_Window
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon0
        CFI NoFunction
        THUMB
??Int_sqrt??rT:
        LDR.N    R3,??Subroutine8_0  ;; Int_sqrt
        BX       R3
        DATA
??Subroutine8_0:
        DC32     Int_sqrt
        CFI EndBlock cfiBlock17

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for V>`:
        DATA
        DC8 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Ch>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_max>`:
        DC8 0
`?<Initializer for b_max>`:
        DC8 0
`?<Initializer for a_min>`:
        DC8 0
`?<Initializer for b_min>`:
        DC8 0
`?<Initializer for Interlace>`:
        DC8 0
        DC8 0
`?<Initializer for A_Vdc>`:
        DC8 0, 0
`?<Initializer for A_Vpp>`:
        DC8 0, 0
`?<Initializer for A_Max>`:
        DC8 0, 0
`?<Initializer for A_Min>`:
        DC8 0, 0
`?<Initializer for A_Rms>`:
        DC8 0, 0
`?<Initializer for B_Vdc>`:
        DC8 0, 0
`?<Initializer for B_Vpp>`:
        DC8 0, 0
`?<Initializer for B_Max>`:
        DC8 0, 0
`?<Initializer for B_Min>`:
        DC8 0, 0
`?<Initializer for JumpCnt>`:
        DC8 0, 0
`?<Initializer for n>`:
        DC8 0, 0
`?<Initializer for Ka2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Kb2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Ka1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Kb1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for a_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for Tmp>`:
        DC8 0, 0, 0, 0
`?<Initializer for X_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Full>`:
        DATA
        DC8 1

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for Ka3>`:
        DATA
        DC16 256
`?<Initializer for Kb3>`:
        DC16 256
`?<Initializer for G_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for D_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 179, 39999, 50
        DC8 " 20Hz "
        DC8 0
        DC16 179, 19999, 50
        DC8 " 50Hz "
        DC8 0
        DC16 179, 7999, 50
        DC8 "!100Hz!"
        DC16 179, 3999, 50
        DC8 "!200Hz!"
        DC16 179, 1999, 50
        DC8 "!500Hz!"
        DC16 179, 799, 50
        DC8 " 1KHz "
        DC8 0
        DC16 179, 399, 50
        DC8 " 2KHz "
        DC8 0
        DC16 179, 199, 50
        DC8 " 5KHz "
        DC8 0
        DC16 17, 799, 50
        DC8 "!10KHz!"
        DC16 17, 399, 50
        DC8 "!20KHz!"
        DC16 17, 199, 50
        DC8 "!50KHz!"
        DC16 0, 1439, 50
        DC8 "100KHz"
        DC8 0
        DC16 0, 719, 50
        DC8 "200KHz"
        DC8 0
        DC16 0, 359, 50
        DC8 "500KHz"
        DC8 0
        DC16 0, 143, 50
        DC8 " 1MHz "
        DC8 0
        DC16 0, 71, 50
        DC8 " 2MHz "
        DC8 0
        DC16 0, 35, 50
        DC8 " 4MHz "
        DC8 0
        DC16 0, 17, 50
        DC8 " 6MHz "
        DC8 0
        DC16 0, 11, 50
        DC8 " 8MHz "
        DC8 0
        DC16 0, 8, 50

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for A_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 19, 9999
        DC8 " 20Hz "
        DC8 0
        DC16 19, 4999
        DC8 " 50Hz "
        DC8 0
        DC16 19, 1999
        DC8 "!100Hz!"
        DC16 19, 999
        DC8 "!200Hz!"
        DC16 19, 499
        DC8 "!500Hz!"
        DC16 19, 199
        DC8 " 1KHz "
        DC8 0
        DC16 19, 99
        DC8 " 2KHz "
        DC8 0
        DC16 19, 49
        DC8 " 5KHz "
        DC8 0
        DC16 19, 19
        DC8 "!10KHz!"
        DC16 19, 9
        DC8 "!20KHz!"
        DC16 19, 4
`?<Initializer for SIN_DATA>`:
        DC16 0, 39, 142, 304, 521, 785, 1089, 1423, 1776, 2138, 2496, 2841
        DC16 3161, 3446, 3688, 3878, 4011, 4083, 4095, 4055, 3952, 3790, 3573
        DC16 3309, 3005, 2671, 2318, 1956, 1598, 1253, 933, 648, 406, 216, 83
        DC16 11
`?<Initializer for TRG_DATA>`:
        DC16 0, 227, 454, 682, 909, 1137, 1364, 1592, 1819, 2047, 2274, 2502
        DC16 2729, 2957, 3184, 3412, 3639, 3867, 4094, 3867, 3639, 3412, 3184
        DC16 2957, 2729, 2502, 2274, 2047, 1819, 1592, 1364, 1137, 909, 682
        DC16 454, 227
`?<Initializer for SAW_DATA>`:
        DC16 0, 117, 234, 351, 468, 585, 702, 819, 936, 1053, 1170, 1287, 1404
        DC16 1521, 1638, 1755, 1872, 1989, 2106, 2223, 2340, 2457, 2574, 2691
        DC16 2808, 2925, 3042, 3159, 3276, 3393, 3510, 3627, 3744, 3861, 3978
        DC16 4095

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
//  463 /******************************** END OF FILE *********************************/
// 
//  2 984 bytes in segment CODE
//     56 bytes in segment DATA_C
//    765 bytes in segment DATA_I
//    765 bytes in segment DATA_ID
// 17 594 bytes in segment DATA_Z
//     24 bytes in segment INITTAB
// 
//  2 904 bytes of CODE  memory (+ 104 bytes shared)
//    821 bytes of CONST memory
// 18 359 bytes of DATA  memory
//
//Errors: none
//Warnings: none
