//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   08/Aug/2011  16:45:30 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203\PRG\APP_V2.51\source\Process.c      /
//    Command line    =  D:\Design\DS203\PRG\APP_V2.51\source\Process.c -lA  /
//                       D:\Design\DS203\PRG\APP_V2.51\IAR_V4_Prpject\List\  /
//                       -o D:\Design\DS203\PRG\APP_V2.51\IAR_V4_Prpject\Obj /
//                       \ -s9 --debug --cpu_mode thumb --endian little      /
//                       --cpu cortex-M3 --stack_align 4 --fpu None          /
//                       --dlib_config "C:\Program Files\IAR                 /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\LIB\dl7mptnnl8f.h" -I                /
//                       D:\Design\DS203\PRG\APP_V2.51\IAR_V4_Prpject\..\..\ /
//                       FWLib\inc\ -I D:\Design\DS203\PRG\APP_V2.51\IAR_V4_ /
//                       Prpject\..\..\USBLib\inc\ -I                        /
//                       D:\Design\DS203\PRG\APP_V2.51\IAR_V4_Prpject\..\inc /
//                       lude\ -I "C:\Program Files\IAR Systems\Embedded     /
//                       Workbench 4.0 Evaluation\arm\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\Design\DS203\PRG\APP_V2.51\IAR_V4_Prpject\List\P /
//                       rocess.s79                                          /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Process

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        EXTERN ??div32_t

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable10 EQU 0
??DataTable11 EQU 0
??DataTable12 EQU 0
??DataTable13 EQU 0
??DataTable3 EQU 0
        MULTWEAK ??Delayms??rT
        MULTWEAK ??Draw_Window??rT
        MULTWEAK ??Get_Ref_Wave??rT
        MULTWEAK ??__Clear_Screen??rT
        MULTWEAK ??__Get??rT
        MULTWEAK ??__Read_FIFO??rT
        MULTWEAK ??__Set??rT
        MULTWEAK ??rT??div32_t
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC A_Posi
        PUBLIC A_Tab
        PUBLIC App_init
        FUNCTION App_init,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC B_Posi
        PUBLIC D_Tab
        PUBLIC DataBuf
        PUBLIC Full
        PUBLIC G_Attr
        PUBLIC Interlace
        PUBLIC JumpCnt
        PUBLIC Ka1
        PUBLIC Ka2
        PUBLIC Ka3
        PUBLIC Kab
        PUBLIC Kb1
        PUBLIC Kb2
        PUBLIC Kb3
        PUBLIC PaS
        PUBLIC PbS
        PUBLIC PcS
        PUBLIC PdS
        PUBLIC Posi_41
        PUBLIC Posi_412
        PUBLIC Posi_42
        PUBLIC Posi_4F1
        PUBLIC Posi_4F2
        PUBLIC Posi_4F3
        PUBLIC Posi_4F4
        PUBLIC Posi_4_2
        PUBLIC Process
        FUNCTION Process,0203H
        LOCFRAME CSTACK, 120, STACK
        PUBLIC SAW_DATA
        PUBLIC SIN_DATA
        PUBLIC Send_Data
        FUNCTION Send_Data,0203H
        LOCFRAME CSTACK, 52, STACK
        PUBLIC Synchro
        FUNCTION Synchro,0203H
        LOCFRAME CSTACK, 32, STACK
        PUBLIC TRG_DATA
        PUBLIC T_Attr
        PUBLIC TaN
        PUBLIC TaS
        PUBLIC TbN
        PUBLIC TbS
        PUBLIC TcN
        PUBLIC TcS
        PUBLIC TdN
        PUBLIC TdS
        PUBLIC TrackBuff
        PUBLIC Update_Base
        FUNCTION Update_Base,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Output
        FUNCTION Update_Output,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Range
        FUNCTION Update_Range,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Trig
        FUNCTION Update_Trig,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC View_init
        FUNCTION View_init,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Wait
        PUBLIC X_Attr
        PUBLIC Y_Attr
        PUBLIC a_Avg
        PUBLIC a_Max
        PUBLIC a_Mid_H
        PUBLIC a_Mid_L
        PUBLIC a_Min
        PUBLIC a_Ssq
        PUBLIC b_Avg
        PUBLIC b_Max
        PUBLIC b_Mid_H
        PUBLIC b_Mid_L
        PUBLIC b_Min
        PUBLIC b_Ssq
        PUBLIC c_Max
        PUBLIC d_Max
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Delayms             SYMBOL "Delayms"
Draw_Window         SYMBOL "Draw_Window"
Get_Ref_Wave        SYMBOL "Get_Ref_Wave"
__Clear_Screen      SYMBOL "__Clear_Screen"
__Get               SYMBOL "__Get"
__Read_FIFO         SYMBOL "__Read_FIFO"
__Set               SYMBOL "__Set"
??Delayms??rT       SYMBOL "??rT", Delayms
??Draw_Window??rT   SYMBOL "??rT", Draw_Window
??Get_Ref_Wave??rT  SYMBOL "??rT", Get_Ref_Wave
??__Clear_Screen??rT SYMBOL "??rT", __Clear_Screen
??__Get??rT         SYMBOL "??rT", __Get
??__Read_FIFO??rT   SYMBOL "??rT", __Read_FIFO
??__Set??rT         SYMBOL "??rT", __Set

        EXTERN Current
        EXTERN Delayms
        FUNCTION Delayms,0202H
        EXTERN Draw_Window
        FUNCTION Draw_Window,0202H
        EXTERN FileBuff
        EXTERN Get_Ref_Wave
        FUNCTION Get_Ref_Wave,0202H
        EXTERN Meter
        EXTERN PD_Cnt
        EXTERN Title
        EXTERN Update
        EXTERN V_Trigg
        EXTERN Wait_Cnt
        EXTERN __Clear_Screen
        FUNCTION __Clear_Screen,0202H
        EXTERN __Get
        FUNCTION __Get,0202H
        EXTERN __Read_FIFO
        FUNCTION __Read_FIFO,0202H
        EXTERN __Set
        FUNCTION __Set,0202H

// D:\Design\DS203\PRG\APP_V2.51\source\Process.c
//    1 /******************** (C) COPYRIGHT 2009 e-Design Co.,Ltd. *********************
//    2  File Name : Process.c       
//    3  Version   : DS203_APP Ver 2.3x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include "Interrupt.h"
//    6 #include "Function.h"
//    7 #include "Process.h"
//    8 #include "Draw.h"
//    9 #include "Menu.h"
//   10 #include "BIOS.h"
//   11 #include "File.h"
//   12 
//   13 u16 TaS, TbS, TcS, TdS;            // 周期累计
//   14 u16 PaS, PbS, PcS, PdS;            // 脉宽累计
//   15 u16 TaN, TbN, TcN, TdN;            // 周期计数
//   16 u8  a_Mid_H, a_Mid_L;
//   17 u8  b_Mid_H, b_Mid_L;
//   18 

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
//   19 s8  Kab;                                     // 模拟通道零点平衡校正系数
Kab:
        DS8 1
//   20 u32 a_Avg, b_Avg, a_Ssq, b_Ssq;              // 平均值累计,平方和累计
//   21 u8  a_Max, b_Max, a_Min, b_Min;              // 原始最大值,原始最小值
//   22 s16 Posi_412, Posi_41, Posi_42, Posi_4_2, Posi_4F1, Posi_4F2, Posi_4F3, Posi_4F4;
//   23 s16 c_Max, d_Max, A_Posi, B_Posi;
//   24 u8  Full=1, Interlace;
//   25 u16 JumpCnt;
//   26 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   27 uc16 Wait[27]= {1000, 500, 200, 100, 50, 20, 10, 5, 2, 2,   
Wait:
        DATA
        DC16 1000, 500, 200, 100, 50, 20, 10, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC16 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC8 0, 0
//   28                 2,      2,   2,   2,  2,  2,  2, 2, 2, 2,    
//   29                 2,      2,   2,   2,  2,  2,  2 };
//   30                      

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   31 Y_attr *Y_Attr; 
Y_Attr:
        DS8 4
//   32 X_attr *X_Attr; 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   33 G_attr *G_Attr; 
G_Attr:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   34 T_attr *T_Attr; 
T_Attr:
        DS8 4
//   35 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   36 u32 DataBuf[4096];
DataBuf:
        DS8 16384

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   37 u8  TrackBuff  [X_SIZE * 4];         // 曲线轨迹缓存：i+0,i+1,i+2,i+3,分别存放1～4号轨迹数据
TrackBuff:
        DS8 1200

        RSEG DATA_I:DATA:SORT:NOROOT(2)
a_Mid_H:
        DS8 1
        REQUIRE `?<Initializer for a_Mid_H>`
a_Mid_L:
        DS8 1
        REQUIRE `?<Initializer for a_Mid_L>`
b_Mid_H:
        DS8 1
        REQUIRE `?<Initializer for b_Mid_H>`
b_Mid_L:
        DS8 1
        REQUIRE `?<Initializer for b_Mid_L>`
a_Max:
        DS8 1
        REQUIRE `?<Initializer for a_Max>`
b_Max:
        DS8 1
        REQUIRE `?<Initializer for b_Max>`
a_Min:
        DS8 1
        REQUIRE `?<Initializer for a_Min>`
b_Min:
        DS8 1
        REQUIRE `?<Initializer for b_Min>`
Interlace:
        DS8 1
        REQUIRE `?<Initializer for Interlace>`
        DS8 1
TaS:
        DS8 2
        REQUIRE `?<Initializer for TaS>`
TbS:
        DS8 2
        REQUIRE `?<Initializer for TbS>`
TcS:
        DS8 2
        REQUIRE `?<Initializer for TcS>`
TdS:
        DS8 2
        REQUIRE `?<Initializer for TdS>`
PaS:
        DS8 2
        REQUIRE `?<Initializer for PaS>`
PbS:
        DS8 2
        REQUIRE `?<Initializer for PbS>`
PcS:
        DS8 2
        REQUIRE `?<Initializer for PcS>`
PdS:
        DS8 2
        REQUIRE `?<Initializer for PdS>`
TaN:
        DS8 2
        REQUIRE `?<Initializer for TaN>`
TbN:
        DS8 2
        REQUIRE `?<Initializer for TbN>`
TcN:
        DS8 2
        REQUIRE `?<Initializer for TcN>`
TdN:
        DS8 2
        REQUIRE `?<Initializer for TdN>`
Posi_412:
        DS8 2
        REQUIRE `?<Initializer for Posi_412>`
Posi_41:
        DS8 2
        REQUIRE `?<Initializer for Posi_41>`
Posi_42:
        DS8 2
        REQUIRE `?<Initializer for Posi_42>`
Posi_4_2:
        DS8 2
        REQUIRE `?<Initializer for Posi_4_2>`
Posi_4F1:
        DS8 2
        REQUIRE `?<Initializer for Posi_4F1>`
Posi_4F2:
        DS8 2
        REQUIRE `?<Initializer for Posi_4F2>`
Posi_4F3:
        DS8 2
        REQUIRE `?<Initializer for Posi_4F3>`
Posi_4F4:
        DS8 2
        REQUIRE `?<Initializer for Posi_4F4>`
c_Max:
        DS8 2
        REQUIRE `?<Initializer for c_Max>`
d_Max:
        DS8 2
        REQUIRE `?<Initializer for d_Max>`
A_Posi:
        DS8 2
        REQUIRE `?<Initializer for A_Posi>`
B_Posi:
        DS8 2
        REQUIRE `?<Initializer for B_Posi>`
JumpCnt:
        DS8 2
        REQUIRE `?<Initializer for JumpCnt>`
//   38 
//   39 s8  Ka1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // A通道低位误差校正系数
//   40 s8  Kb1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // B通道低位误差校正系数
//   41 u16 Ka2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // A通道增益误差校正系数
Ka2:
        DS8 20
        REQUIRE `?<Initializer for Ka2>`
Ka1:
        DS8 12
        REQUIRE `?<Initializer for Ka1>`
Kb1:
        DS8 12
        REQUIRE `?<Initializer for Kb1>`
a_Avg:
        DS8 4
        REQUIRE `?<Initializer for a_Avg>`
b_Avg:
        DS8 4
        REQUIRE `?<Initializer for b_Avg>`
a_Ssq:
        DS8 4
        REQUIRE `?<Initializer for a_Ssq>`
b_Ssq:
        DS8 4
        REQUIRE `?<Initializer for b_Ssq>`
X_Attr:
        DS8 4
        REQUIRE `?<Initializer for X_Attr>`

        RSEG DATA_I:DATA:SORT:NOROOT(0)
Full:
        DS8 1
        REQUIRE `?<Initializer for Full>`

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   42 u16 Kb2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // B通道增益误差校正系数
Kb2:
        DS8 20
        REQUIRE `?<Initializer for Kb2>`

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   43 s8  Ka3[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // A通道高位误差校正系数
Ka3:
        DS8 12
//   44 s8  Kb3[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // B通道高位误差校正系数
Kb3:
        DS8 12
//   45 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   46 D_tab D_Tab[20] ={  // 脉冲波形输出驱动表, 基于72MHz主频
D_Tab:
        DS8 280
        REQUIRE `?<Initializer for D_Tab>`
//   47 //    STR      PSC     ARR       DUTY% 
//   48   {" 10Hz ",  180-1,  40000-1,     50},
//   49   {" 20Hz ",  180-1,  20000-1,     50},
//   50   {" 50Hz ",  180-1,   8000-1,     50},
//   51   {"!100Hz!", 180-1,   4000-1,     50},
//   52   {"!200Hz!", 180-1,   2000-1,     50},
//   53   {"!500Hz!", 180-1,    800-1,     50},
//   54   {" 1KHz ",  180-1,    400-1,     50},
//   55   {" 2KHz ",  180-1,    200-1,     50},
//   56   {" 5KHz ",   18-1,    800-1,     50},
//   57   {"!10KHz!",  18-1,    400-1,     50},
//   58   {"!20KHz!",  18-1,    200-1,     50},
//   59   {"!50KHz!",   1-1,   1440-1,     50},
//   60   {"100KHz",    1-1,    720-1,     50},
//   61   {"200KHz",    1-1,    360-1,     50},
//   62   {"500KHz",    1-1,    144-1,     50},
//   63   {" 1MHz ",    1-1,     72-1,     50},
//   64   {" 2MHz ",    1-1,     36-1,     50},
//   65   {" 4MHz ",    1-1,     18-1,     50},
//   66   {" 6MHz ",    1-1,     12-1,     50},
//   67   {" 8MHz ",    1-1,      9-1,     50}};
//   68 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   69 A_tab A_Tab[11] ={ // 模拟波形输出驱动表, 基于72MHz主频, 每周期36点合成
A_Tab:
        DS8 132
        REQUIRE `?<Initializer for A_Tab>`
//   70 //    STR     PSC     ARR 
//   71   {" 10Hz ",  20-1,  10000-1},
//   72   {" 20Hz ",  20-1,   5000-1},
//   73   {" 50Hz ",  20-1,   2000-1},
//   74   {"!100Hz!", 20-1,   1000-1},
//   75   {"!200Hz!", 20-1,    500-1},
//   76   {"!500Hz!", 20-1,    200-1},
//   77   {" 1KHz ",  20-1,    100-1},
//   78   {" 2KHz ",  20-1,     50-1},
//   79   {" 5KHz ",  20-1,     20-1},
//   80   {"!10KHz!", 20-1,     10-1},
//   81   {"!20KHz!", 20-1,      5-1}};
//   82 
//   83 u16 SIN_DATA[36] =  // Sine wave data                                                                                                 //         
SIN_DATA:
        DS8 72
        REQUIRE `?<Initializer for SIN_DATA>`
//   84   {0x000,0x027,0x08E,0x130,0x209,0x311,0x441,0x58F,0x6F0,    // 90
//   85    0x85A,0x9C0,0xB19,0xC59,0xD76,0xE68,0xF26,0xFAB,0xFF3,    // 180
//   86    0xFFF,0xFD7,0xF70,0xECE,0xDF5,0xCED,0xBBD,0xA6F,0x90E,    // 270
//   87    0x7A4,0x63E,0x4E5,0x3A5,0x288,0x196,0x0D8,0x053,0x00B,};  // 360   
//   88 
//   89 u16 TRG_DATA[36] =  // triangle wave data
TRG_DATA:
        DS8 72
        REQUIRE `?<Initializer for TRG_DATA>`
//   90   {0x000,0x0E3,0x1C6,0x2AA,0x38D,0x471,0x554,0x638,0x71B,    // 90
//   91    0x7FF,0x8E2,0x9C6,0xAA9,0xB8D,0xC70,0xD54,0xE37,0xF1B,    // 180
//   92    0xFFE,0xF1B,0xE37,0xD54,0xC70,0xB8D,0xAA9,0x9C6,0x8E2,    // 270
//   93    0x7FF,0x71B,0x638,0x554,0x471,0x38D,0x2AA,0x1C6,0x0E3};   // 360   
//   94          
//   95 u16 SAW_DATA[36] =  // Sawtooth wave data                                                                                             //         
SAW_DATA:
        DS8 72
        REQUIRE `?<Initializer for SAW_DATA>`
//   96   {0x000,0x075,0x0EA,0x15F,0x1D4,0x249,0x2BE,0x333,0x3A8,    // 90
//   97    0x41D,0x492,0x507,0x57C,0x5F1,0x666,0x6DB,0x750,0x7C5,    // 180
//   98    0x83A,0x8AF,0x924,0x999,0xA0E,0xA83,0xAF8,0xB6D,0xBE2,    // 270
//   99    0xC57,0xCCC,0xD41,0xDB6,0xE2B,0xEA0,0xF15,0xF8A,0xFFF};   // 360    
//  100 
//  101 
//  102 /*******************************************************************************
//  103  App_init: 显示窗口波形数据初始化
//  104 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function App_init
        THUMB
//  105 void App_init(void)
//  106 { 
App_init:
        PUSH     {R4,R5,R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  107   u16 i, j;
//  108   __Set(ADC_CTRL, EN );       
        MOVS     R1,#+1
//  109   __Set(STANDBY, DN);          // 退出省电状态
//  110   __Clear_Screen(BLACK);       // 清屏幕
//  111   Delayms(20); 
//  112   __Set(FIFO_CLR, W_PTR); 
//  113   for(i=0; i<13; i++) for(j=0; j<4; j++) Title[i][j].Flag |= UPDAT;
        LDR.N    R4,??DataTable2  ;; Title
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R0,#+20
        _BLF     __Set,??__Set??rT
        MOVS     R0,#+0
        _BLF     __Clear_Screen,??__Clear_Screen??rT
        MOVS     R0,#+20
        _BLF     Delayms,??Delayms??rT
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOVS     R7,#+80
??App_init_0:
        MOVS     R3,#+0
??App_init_1:
        MOVS     R5,R2
        MOVS     R0,#+20
        MLA      R5,R5,R7,R4
        MLA      R0,R3,R0,R5
        ADDS     R3,R3,#+1
        UXTH     R3,R3
        LDRB     R5,[R0, #+18]
        ORRS     R5,R5,#0x2
        STRB     R5,[R0, #+18]
        CMP      R3,#+4
        BCC.N    ??App_init_1
        ADDS     R2,R2,#+1
        UXTH     R2,R2
        CMP      R2,#+13
        BCC.N    ??App_init_0
//  114   for(i=0; i<9; i++)                     Meter[i].Flag    |= UPDAT;
        LDR.N    R5,??App_init_2  ;; Meter
        MOVS     R0,#+0
??App_init_3:
        MOVS     R2,R0
        MOVS     R3,#+12
        ADDS     R0,R0,#+1
        MLA      R2,R2,R3,R5
        UXTH     R0,R0
        LDRB     R3,[R2, #+11]
        ORRS     R3,R3,#0x2
        STRB     R3,[R2, #+11]
        CMP      R0,#+9
        BCC.N    ??App_init_3
//  115   if(Current != FILE) {
        LDR.N    R0,??App_init_2+0x4  ;; Current
        LDRB     R0,[R0, #+0]
        CMP      R0,#+9
        BEQ.N    ??App_init_4
//  116     Title[FILE][0].Flag &= !UPDAT;
        ADDW     R0,R4,#+738
//  117     Title[FILE][1].Flag &= !UPDAT;
//  118     Title[FILE][3].Flag &= !UPDAT;
        STRB     R1,[R4, #+798]
        STRB     R1,[R0, #+0]
        STRB     R1,[R0, #+20]
//  119   }  
//  120   PD_Cnt = 600;
??App_init_4:
        LDR.N    R0,??App_init_2+0x8  ;; PD_Cnt
        MOVS     R1,#+600
        STRH     R1,[R0, #+0]
//  121   Update = 1;                  // 返回后恢复原来的档位设置
        LDR.N    R0,??App_init_2+0xC  ;; Update
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  122 }
        POP      {R4,R5,R7,PC}
        DATA
??App_init_2:
        DC32     Meter
        DC32     Current
        DC32     PD_Cnt
        DC32     Update
        CFI EndBlock cfiBlock0
//  123 /*******************************************************************************
//  124  View_init: 显示窗口波形数据初始化
//  125 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function View_init
        THUMB
//  126 void View_init(void)
//  127 { 
View_init:
        PUSH     {R4,R6-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  128   u16 i, j = 0, k = 0;
        MOVS     R6,#+0
//  129   for(i = 0; i < X_SIZE * 4; i += 4){
        MOVS     R4,#+0
        MOV      R8,R6
        B.N      ??View_init_0
//  130     TrackBuff[i] = 160;
??View_init_1:
        LDR.N    R0,??DataTable1  ;; TrackBuff
        ADDS     R7,R0,R4
        MOVS     R0,#+160
        STRB     R0,[R7, #+0]
//  131     TrackBuff[i+1] = Get_Ref_Wave(i/4);
        LSRS     R0,R4,#+2
        UXTH     R0,R0
        _BLF     Get_Ref_Wave,??Get_Ref_Wave??rT
        STRB     R0,[R7, #+1]
//  132     if((i%160)==0) j = 1 - j;
        MOVS     R0,R4
        MOVS     R1,#+160
        _BLF     ??div32_t,??rT??div32_t
        CBNZ     R0,??View_init_2
        MOVS     R0,#+1
        MOV      R1,R8
        SUBS     R0,R0,R1
        UXTH     R0,R0
        MOV      R8,R0
//  133     TrackBuff[i+2] = 60 + (j * 17);
??View_init_2:
        MOVS     R0,#+17
        MUL      R0,R8,R0
        ADDS     R0,R0,#+60
        STRB     R0,[R7, #+2]
//  134     if((i%64)==0) k = 1 - k;
        LSRS     R0,R4,#+6
        UXTH     R0,R0
        SUBS     R0,R4,R0, LSL #+6
        ITTT    EQ 
        MOVEQ    R0,#+1
        SUBEQ    R6,R0,R6
        UXTHEQ   R6,R6
//  135     TrackBuff[i+3] = 20 + (k * 17);
        MOVS     R0,#+17
//  136   }
        ADDS     R4,R4,#+4
        MULS     R0,R6,R0
        ADDS     R0,R0,#+20
        STRB     R0,[R7, #+3]
        UXTH     R4,R4
??View_init_0:
        MOVS     R1,#+1200
        CMP      R4,R1
        BCC.N    ??View_init_1
//  137 }
        POP      {R4,R6-R8,PC}
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     TrackBuff
//  138 /*******************************************************************************
//  139  Update_Range: 
//  140 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Update_Range
        THUMB
//  141 void Update_Range(void) 
//  142 {
//  143   Interlace = 0;
Update_Range:
        LDR.N    R0,??Update_Range_0  ;; a_Mid_H + 8
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  144   __Set(ADC_CTRL, EN);       
//  145   __Set(ADC_MODE, SEPARATE);                        // Set Separate mode ((Range + 1)*25)
//  146   __Set(CH_A_COUPLE, Title[TRACK1][COUPLE].Value);
        LDR.N    R4,??DataTable2  ;; Title
//  147   __Set(CH_A_RANGE,  Title[TRACK1][RANGE].Value);
//  148   __Set(CH_A_OFFSET, ((1024 + Ka3[_A_Range])*_1_posi + 512)/1024);
        LDR.N    R6,??Update_Range_0+0x4  ;; Ka3
        MOVS     R1,#+0
        MOVS     R5,R4
        STRB     R1,[R0, #+0]
        MOVS     R1,#+1
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R5, #+36]!
        MOVS     R0,#+9
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R5, #+20]
        MOVS     R0,#+10
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+20]
        LDRSH    R1,[R5, #+40]
        LDRSB    R0,[R6, R0]
        ADDS     R0,R0,#+1024
        MULS     R0,R1,R0
        ADDW     R0,R0,#+512
        ASRS     R1,R0,#+9
        ADDS     R0,R0,R1, LSR #+22
        ASRS     R1,R0,#+10
        MOVS     R0,#+0
        _BLF     __Set,??__Set??rT
//  149 //  if(_1_source == HIDE){
//  150 //    if(_T_base > 16){
//  151 //      Interlace = 1;                      
//  152 //      __Set(CH_A_RANGE, G_Attr[0].Yp_Max+1);        // A通道合并到B通道 
//  153 //      __Set(ADC_CTRL, EN + 2);       
//  154 //      __Set(ADC_MODE, INTERLACE);                   // Set Interlace mode
//  155 //    }  
//  156 //  }
//  157   __Set(CH_B_COUPLE, Title[TRACK2][COUPLE].Value);
        LDRSH    R1,[R5, #+80]
        MOVS     R0,#+11
        _BLF     __Set,??__Set??rT
//  158   __Set(CH_B_RANGE,  Title[TRACK2][RANGE].Value);
        LDRSH    R1,[R5, #+100]
        MOVS     R0,#+12
        _BLF     __Set,??__Set??rT
//  159   __Set(CH_B_OFFSET, ((1024 + Kb3[_B_Range])*_2_posi + 512)/1024);
        LDRSH    R0,[R5, #+100]
        LDRSH    R1,[R5, #+120]
        ADDS     R0,R6,R0
        LDRSB    R0,[R0, #+12]
        ADDS     R0,R0,#+1024
        MULS     R0,R1,R0
        ADDW     R0,R0,#+512
        ASRS     R1,R0,#+9
        ADDS     R0,R0,R1, LSR #+22
        ASRS     R1,R0,#+10
        MOVS     R0,#+1
        _BLF     __Set,??__Set??rT
//  160 //  if(_2_source == HIDE){
//  161 //    if(_T_base > 16){
//  162 //      Interlace = 1;                        
//  163 //      __Set(CH_B_RANGE,  G_Attr[0].Yp_Max+1);      // B通道合并到A通道
//  164 //      __Set(ADC_CTRL, EN + 2);       
//  165 //      __Set(ADC_MODE, INTERLACE);                  // Set Interlace mode
//  166 //    }
//  167 //  } 
//  168   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);       // FIFO写指针复位
        LDRSH    R0,[R4, #+336]
        CBNZ     R0,??Update_Range_1
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  169 }
??Update_Range_1:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??Update_Range_0:
        DC32     a_Mid_H + 8
        DC32     Ka3
        CFI EndBlock cfiBlock2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable2:
        DC32     Title
//  170 /*******************************************************************************
//  171  Update_Base: 
//  172 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Update_Base
        THUMB
//  173 void Update_Base(void) 
//  174 {
Update_Base:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  175   u16 i;
//  176   
//  177   __Set(ADC_CTRL, EN);       
//  178   if(Interlace == 0)  i = Title[T_BASE][BASE].Value;     // 独立采样模式
        LDR.N    R4,??Update_Base_0  ;; Title + 336
        LDR.N    R5,??DataTable7  ;; a_Mid_H
        MOVS     R1,#+1
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        LDRB     R0,[R5, #+8]
        CBNZ     R0,??Update_Base_1
        LDRSH    R6,[R4, #+100]
        B.N      ??Update_Base_2
//  179   else                i = Title[T_BASE][BASE].Value + 5; // 交替采样模式
??Update_Base_1:
        LDRSH    R6,[R4, #+100]
        ADDS     R6,R6,#+5
??Update_Base_2:
        UXTH     R6,R6
//  180   __Set(T_BASE_PSC, X_Attr[i].PSC);
        MOVS     R0,#+20
        MULS     R6,R0,R6
        LDR      R0,[R5, #+120]
        ADDS     R0,R0,R6
        LDRSH    R1,[R0, #+8]
        MOVS     R0,#+7
        _BLF     __Set,??__Set??rT
//  181   __Set(T_BASE_ARR, X_Attr[i].ARR);
        LDR      R0,[R5, #+120]
        ADDS     R0,R0,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+8
        _BLF     __Set,??__Set??rT
//  182   Wait_Cnt = Wait[_T_base];
        LDR.N    R2,??DataTable4  ;; Wait
        LDR.N    R0,??DataTable5  ;; Wait_Cnt
        LDRSH    R1,[R4, #+100]
        LDRH     R1,[R2, R1, LSL #+1]
        STR      R1,[R0, #+0]
//  183   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Base_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  184 }
??Update_Base_3:
        POP      {R4-R6,PC}       ;; return
        DATA
??Update_Base_0:
        DC32     Title + 336
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     Wait_Cnt
//  185 /*******************************************************************************
//  186  Update_Output: 
//  187 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Update_Output
        THUMB
//  188 void Update_Output(void) 
//  189 {
Update_Output:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  190   if(_Kind == SINE){
        LDR.N    R4,??Update_Output_0  ;; Title + 496
        LDR.N    R5,??Update_Output_0+0x4  ;; 0x40020450
        LDR.N    R6,??Update_Output_0+0x8  ;; A_Tab
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Output_1
//  191     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  192     (*((vu32 *)(0x40020400+0x50))) = (u32)&SIN_DATA[0];
        MOVS     R0,R6
        ADDS     R0,R0,#+132
        STR      R0,[R5, #+0]
//  193     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  194   }
//  195   if(_Kind == SAW){
??Update_Output_1:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+2
        BNE.N    ??Update_Output_2
//  196     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  197     (*((vu32 *)(0x40020400+0x50))) = (u32)&SAW_DATA[0];
        ADDW     R0,R6,#+276
        STR      R0,[R5, #+0]
//  198     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  199   }
//  200   if(_Kind == TRIANG){
??Update_Output_2:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Output_3
//  201     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
//  202     (*((vu32 *)(0x40020400+0x50))) = (u32)&TRG_DATA[0];
        ADDS     R6,R6,#+204
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
        STR      R6,[R5, #+0]
//  203     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  204   }
//  205   if(_Kind == DIGI){
??Update_Output_3:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+3
        BNE.N    ??Update_Output_4
//  206     __Set(DIGTAL_PSC, D_Tab[_Frqn].PSC);
        LDRSH    R0,[R4, #+20]
        LDR.N    R5,??Update_Output_0+0xC  ;; D_Tab
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+8]
        MOVS     R0,#+16
        _BLF     __Set,??__Set??rT
//  207     __Set(DIGTAL_ARR, D_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+17
        _BLF     __Set,??__Set??rT
//  208     __Set(DIGTAL_CCR, (D_Tab[_Frqn].ARR+1)/2);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R0,[R0, #+10]
        ADDS     R0,R0,#+1
        ADDS     R0,R0,R0, LSR #+31
        ASRS     R1,R0,#+1
        MOVS     R0,#+18
        _BLF     __Set,??__Set??rT
//  209   }
//  210 }
??Update_Output_4:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??Update_Output_0:
        DC32     Title + 496
        DC32     0x40020450
        DC32     A_Tab
        DC32     D_Tab
        CFI EndBlock cfiBlock4
//  211 /*******************************************************************************
//  212  Update_Trig: 
//  213 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function Update_Trig
        THUMB
//  214 void Update_Trig(void) 
//  215 { 
Update_Trig:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  216   if(_T1 > _T2)  __Set(T_THRESHOLD, (_T1 - _T2));  
        LDR.N    R4,??DataTable6  ;; Title
        ADDW     R0,R4,#+816
        LDRSH    R1,[R0, #+20]
        LDRSH    R0,[R0, #+0]
        CMP      R1,R0
        BGE.N    ??Update_Trig_0
        SUBS     R1,R0,R1
        B.N      ??Update_Trig_1
//  217   else           __Set(T_THRESHOLD, (_T2 - _T1)); 
??Update_Trig_0:
        SUBS     R1,R1,R0
??Update_Trig_1:
        MOVS     R0,#+34
        _BLF     __Set,??__Set??rT
//  218   __Set(TRIGG_MODE,  (_Tr_source<< 3)+_Tr_kind);
//  219   if(Title[TRIGG][SOURCE].Value == TRACK1){ 
        LDR.N    R6,??DataTable7  ;; a_Mid_H
        LDR.N    R7,??Update_Trig_2  ;; V_Trigg
        ADDW     R5,R4,#+576
        LDRSH    R0,[R5, #+0]
        LDRSH    R1,[R5, #+20]
        ADDW     R8,R4,#+56
        ADDS     R1,R1,R0, LSL #+3
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        CBNZ     R0,??Update_Trig_3
        LDRSH    R0,[R8, #+0]
        LDRSH    R1,[R7, #+0]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+80]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+60]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  220     __Set(V_THRESHOLD, (((_Vt1-Ka1[_A_Range])*1024)/Ka2[_A_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  221   }
//  222   if(Title[TRIGG][SOURCE].Value == TRACK2){ 
??Update_Trig_3:
        LDRSH    R0,[R5, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Trig_4
        LDRSH    R0,[R8, #+80]
        LDRSH    R1,[R7, #+4]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+92]
        SUBS     R1,R1,R2
        LDR.N    R2,??DataTable8  ;; Kb2
        LSLS     R1,R1,#+10
        LDRH     R0,[R2, R0, LSL #+1]
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  223     __Set(V_THRESHOLD, (((_Vt2-Kb1[_B_Range])*1024)/Kb2[_B_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  224   }
//  225   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位
??Update_Trig_4:
        LDRSH    R0,[R4, #+336]
        CBNZ     R0,??Update_Trig_5
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  226 }
??Update_Trig_5:
        POP      {R4-R8,PC}       ;; return
        DATA
??Update_Trig_2:
        DC32     V_Trigg
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     a_Mid_H

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     Kb2
//  227 /*******************************************************************************
//  228  Process: 计算处理缓冲区数据 
//  229 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function Process
        THUMB
//  230 void Process(void)
//  231 { 
Process:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
//  232   s16 i, j = 0, k, V[8], n = 0;
//  233   s32 Tmp;
//  234   u8  Ch[4], C_D;
//  235   s8  Sa = 2, Sb = 2, Sc = 2, Sd = 2; // 计时状态
//  236   u16 Ta, Tb, Tc, Td;                 // 脉宽计数
//  237   
//  238   PaS = 0; PbS = 0; PcS = 0; PdS = 0; 
        LDR.N    R6,??Process_0   ;; a_Mid_H
        SUB      SP,SP,#+80
        CFI CFA R13+116
        MOVS     R0,#+0
        MOV      R8,R0
        MOV      R5,R0
        MOVS     R0,#+2
        STR      R0,[SP, #+16]
        STR      R0,[SP, #+20]
        STR      R0,[SP, #+24]
        STR      R0,[SP, #+28]
        MOV      R0,R8
        STRH     R0,[R6, #+18]
        STRH     R0,[R6, #+20]
        STRH     R0,[R6, #+22]
        STRH     R0,[R6, #+24]
//  239   TaN = 0; TbN = 0; TcN = 0; TdN = 0; 
        STRH     R0,[R6, #+26]
        STRH     R0,[R6, #+28]
        STRH     R0,[R6, #+30]
        STRH     R0,[R6, #+32]
//  240 
//  241   Posi_412 = _4_posi - _1_posi - _2_posi;
        LDR.N    R0,??Process_0+0x4  ;; Title
        MOVS     R4,#+0
        MOV      R11,R0
        ADDW     R9,R11,#+16
        ADDW     R10,R11,#+316
        LDRSH    R0,[R9, #+60]
        LDRSH    R1,[R10, #+0]
        MOV      R2,R11
        ADDS     R2,R2,#+156
        STR      R2,[SP, #+52]
        LDRSH    R2,[R2, #+0]
        SUBS     R3,R1,R0
//  242   Posi_41  = _4_posi - _1_posi;
        STRH     R3,[R6, #+36]
        SUBS     R7,R3,R2
//  243   Posi_42  = _4_posi - _2_posi;
        SUBS     R3,R1,R2
        STRH     R3,[R6, #+38]
//  244   Posi_4_2 = _4_posi + _2_posi;
        ADDS     R3,R1,R2
        STRH     R3,[R6, #+40]
//  245   Posi_4F1 = _4_posi - FileBuff[ 299];
        LDR.N    R3,??Process_0+0x8  ;; FileBuff
        STRH     R7,[R6, #+34]
        LDRB     R7,[R3, #+299]
        SUBS     R7,R1,R7
        STRH     R7,[R6, #+42]
//  246   Posi_4F2 = _4_posi - FileBuff[ 599];
        LDRB     R7,[R3, #+599]
        SUBS     R7,R1,R7
        STRH     R7,[R6, #+44]
//  247   Posi_4F3 = _4_posi - FileBuff[ 899];
        LDRB     R7,[R3, #+899]
//  248   Posi_4F4 = _4_posi - FileBuff[1199];
        LDRB     R3,[R3, #+1199]
        SUBS     R7,R1,R7
        SUBS     R3,R1,R3
        STRH     R3,[R6, #+48]
        LDRSH    R3,[R9, #+40]
        STRH     R7,[R6, #+46]
        ADDS     R7,R6,R3
        LDRSB    R7,[R7, #+80]
        ADDS     R3,R6,R3, LSL #+1
        LDRH     R3,[R3, #+60]
        SUBS     R0,R0,R7
        LSLS     R0,R0,#+10
        SDIV     R0,R0,R3
        STRH     R0,[R6, #+54]
        LDRSH    R0,[R9, #+120]
        ADDS     R3,R6,R0
        LDRSB    R3,[R3, #+92]
        SUBS     R2,R2,R3
        LDR.N    R3,??Process_0+0xC  ;; Kb2
        LSLS     R2,R2,#+10
        LDRH     R0,[R3, R0, LSL #+1]
        SDIV     R0,R2,R0
        STRH     R0,[R6, #+56]
//  249   A_Posi   = ((_1_posi-Ka1[_A_Range])*1024)/Ka2[_A_Range];
//  250   B_Posi   = ((_2_posi-Kb1[_B_Range])*1024)/Kb2[_B_Range];
//  251   
//  252   a_Max = A_Posi; b_Max = B_Posi; 
        LDRSH    R0,[R6, #+54]
        STRB     R0,[R6, #+4]
        LDRSH    R2,[R6, #+56]
//  253   a_Min = A_Posi; b_Min = B_Posi;             
        STRB     R0,[R6, #+6]
//  254   a_Avg = 2048;   b_Avg = 2048; 
        MOVS     R0,#+2048
        STR      R0,[R6, #+104]
        STR      R0,[R6, #+108]
//  255   a_Ssq = 2048;   b_Ssq = 2048;      
        STR      R0,[R6, #+112]
        STR      R0,[R6, #+116]
//  256   
//  257   if((_3_posi + 20)>= Y_BASE+Y_SIZE)  c_Max = Y_BASE+Y_SIZE-1;
        LDR      R0,[SP, #+52]
        STRB     R2,[R6, #+5]
        STRB     R2,[R6, #+7]
        LDRSH    R0,[R0, #+80]
        MOVS     R2,#+199
        MOVS     R3,R0
        ADDS     R3,R3,#+20
        CMP      R3,#+200
        ITE     LT 
        ADDLT    R0,R0,#+20
        MOVGE    R0,#+199
        STRH     R0,[R6, #+50]
//  258   else                                c_Max = _3_posi + 20;
//  259   if((_4_posi + 20)>= Y_BASE+Y_SIZE)  d_Max = Y_BASE+Y_SIZE-1;
        MOVS     R0,R1
        ADDS     R0,R0,#+20
        CMP      R0,#+200
        ITT     LT 
//  260   else                                d_Max = _4_posi + 20;
        ADDLT    R1,R1,#+20
        MOVLT    R2,R1
//  261   
//  262   if(Interlace == 0){                           // 独立采样模式
        LDRSH    R0,[R10, #+120]
        LDRB     R3,[R6, #+8]
        STRH     R2,[R6, #+52]
        LDR      R2,[R6, #+120]
        MOVS     R1,#+20
        MLA      R2,R0,R1,R2
        LDRSH    R0,[R11, #+456]
        LDR.N    R1,??Process_0+0x10  ;; 0x25a00
        CMP      R3,#+0
        BNE.W    ??Process_1
//  263     k =((1024 -_Kp1)*150 + 512)/1024 + _X_posi.Value;  // 计算插值运算后窗口位置的修正值
        LDRH     R2,[R2, #+14]
        MOVS     R3,#+150
//  264     for(i=0; i <4096; i++){
        MOVS     R7,#+0
        MLS      R1,R2,R3,R1
        ASRS     R2,R1,#+9
        ADDS     R1,R1,R2, LSR #+22
        ASRS     R1,R1,#+10
        ADDS     R0,R1,R0
        MOV      R11,R0
        B.N      ??Process_2
//  265       if((_T_base > 16)&&(_Status == RUN))  DataBuf[i] = __Read_FIFO(); // 读入32位FIFO数据, 读后指针+1
//  266       else if((__Get(FIFO_EMPTY)==0)&&(i == JumpCnt)&&(_Status == RUN)){
//  267         JumpCnt++;
//  268         DataBuf[i] = __Read_FIFO();             // 读入32位FIFO数据, 读后指针+1
//  269       }
//  270       Ch[A] = (DataBuf[i] & 0xFF );              
//  271       a_Avg += Ch[A];                           // 累计A通道直流平均值              
//  272       Tmp = Ch[A]- A_Posi;
//  273       a_Ssq +=(Tmp * Tmp);                      // 统计A通道平方和
//  274       Ch[B] = ((DataBuf[i] >> 8) & 0xFF);       
//  275       b_Avg += Ch[B];                           // 累计B通道直流平均值
//  276       Tmp = Ch[B]- B_Posi;
//  277       b_Ssq +=(Tmp * Tmp);                      // 统计B通道平方和
//  278         
//  279       if(Ch[A] > a_Max)  a_Max = Ch[A];         // 统计A通道最大值  
//  280       if(Ch[A] < a_Min)  a_Min = Ch[A];         // 统计A通道最小值  
//  281       if(Ch[B] > b_Max)  b_Max = Ch[B];         // 统计B通道最大值  
//  282       if(Ch[B] < b_Min)  b_Min = Ch[B];         // 统计B通道最小值  
//  283        
//  284       C_D = DataBuf[i] >>16;
//  285       if((i>1)&&(i<4094)){
//  286         if(Sa == 2){TaS = i; Ta = i; PaS = 0;}
//  287         if(Ch[A] > a_Mid_H){
//  288           if(Sa == 0){ TaS = i; TaN++;} 
//  289           Sa = 1;  
//  290         } else { 
//  291           if(Ch[A] < a_Mid_L) if(Sa == 1){Sa = 0; PaS += i-TaS;}
//  292         }
//  293         if(Sb == 2){TbS = i; Tb = i; PbS = 0;}
//  294         if(Ch[B] > b_Mid_H){
//  295           if(Sb == 0){ TbS = i; TbN++;} 
//  296           Sb = 1;  
//  297         } else { 
//  298           if(Ch[B] < b_Mid_L) if(Sb == 1){Sb = 0; PbS += i-TbS;}
//  299         }
//  300         if(Sc == 2){TcS = i; Tc = i; PcS = 0;}
//  301         if(C_D & 1){
//  302           if(Sc == 0){ TcS = i; TcN++;} 
//  303           Sc = 1;  
//  304         } else {
//  305           if(Sc == 1){Sc = 0; PcS += i-TcS;} 
//  306         }
//  307         if(Sd == 2){TdS = i; Td = i; PdS = 0;}
//  308         if(C_D & 2){
//  309           if(Sd == 0){ TdS = i; TdN++;} 
//  310           Sd = 1;  
//  311         } else {
//  312           if(Sd == 1){Sd = 0; PdS += i-TdS;} 
??Process_3:
        CMP      R2,#+1
        BNE.N    ??Process_4
        STR      R8,[SP, #+28]
        LDRH     R0,[R6, #+24]
        LDRH     R2,[R6, #+16]
        ADDS     R0,R0,R7
        SUBS     R0,R0,R2
        STRH     R0,[R6, #+24]
//  313         }
//  314       }
//  315       if(i >= k){                               // 指针到达指定窗口位置
??Process_4:
        MOV      R0,R11
        SXTH     R0,R0
        CMP      R7,R0
        BLT.N    ??Process_5
        LDRSH    R0,[R9, #+40]
        LDR      R3,[SP, #+60]
        ADDS     R2,R6,R0, LSL #+1
        LDRH     R2,[R2, #+60]
        ADDS     R0,R6,R0
        LDRSB    R0,[R0, #+80]
        MULS     R2,R3,R2
        ADDW     R2,R2,#+512
        ASRS     R3,R2,#+9
        ADDS     R2,R2,R3, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R0,R0,R2
        LDR.N    R2,??Process_0+0xC  ;; Kb2
        STRH     R0,[SP, #+32]
        LDRSH    R0,[R9, #+120]
        LDRH     R2,[R2, R0, LSL #+1]
        ADDS     R0,R6,R0
        LDRSB    R0,[R0, #+92]
        MULS     R2,R1,R2
        ADDW     R1,R2,#+512
        ASRS     R2,R1,#+9
        ADDS     R1,R1,R2, LSR #+22
        ASRS     R1,R1,#+10
        ADDS     R0,R0,R1
        STRH     R0,[SP, #+10]
        LDRH     R0,[SP, #+10]
        STRH     R0,[SP, #+34]
//  316         V[A]  = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A]+ 512)/1024;      
//  317         V[B]  = Kb1[_B_Range] +(Kb2[_B_Range] *Ch[B]+ 512)/1024;      //当前点的主值
//  318         while(j > 0 ){
??Process_6:
        CMP      R4,#+1
        BLT.N    ??Process_7
//  319           Send_Data( V[A_]+((V[A]-V[A_])*(1024 - j))/1024, //当前CH_A点的插值
//  320                      V[B_]+((V[B]-V[B_])*(1024 - j))/1024, //当前CH_B点的插值
//  321                      C_D,                                  //当前点数字通道值
//  322                      n++);
        LDRSH    R1,[SP, #+38]
        LDRSH    R0,[SP, #+10]
        RSBS     R2,R4,#+1024
        RSBS     R3,R4,#+1024
        SUBS     R0,R0,R1
        MOV      R12,R1
        MULS     R0,R2,R0
        STR      R0,[SP, #+56]
        LDRSH    R0,[SP, #+36]
        LDRSH    R2,[SP, #+32]
        SUBS     R2,R2,R0
        MULS     R2,R3,R2
        STR      R2,[SP, #+4]
        LDR      R2,[SP, #+12]
        UXTH     R3,R5
        ADDS     R5,R5,#+1
        UXTB     R2,R2
        PUSH     {R2}
        CFI CFA R13+120
        LDR      R1,[SP, #+60]
        SXTH     R5,R5
        ASRS     R2,R1,#+9
        ADDS     R1,R1,R2, LSR #+22
        ASRS     R1,R1,#+10
        MOV      R2,R12
        ADDS     R1,R2,R1
        POP      {R2}
        CFI CFA R13+116
        SXTH     R1,R1
        PUSH     {R1}
        CFI CFA R13+120
        MOV      R12,R0
        LDR      R0,[SP, #+8]
        ASRS     R1,R0,#+9
        ADDS     R0,R0,R1, LSR #+22
        ASRS     R0,R0,#+10
        MOV      R1,R12
        ADDS     R0,R1,R0
        POP      {R1}
        CFI CFA R13+116
        SXTH     R0,R0
        BL       Send_Data
//  323           j -= _Kp1;
        LDRSH    R0,[R10, #+120]
        LDR      R2,[R6, #+120]
        MOVS     R1,#+20
        MLA      R0,R0,R1,R2
        LDRH     R0,[R0, #+14]
        SUBS     R4,R4,R0
        SXTH     R4,R4
//  324           if(n >= 300){ k = 8192;  break;}
        CMP      R5,#+300
        BLT.N    ??Process_6
        MOVS     R0,#+8192
        MOV      R11,R0
//  325         }
//  326         j += 1024;
//  327         V[A_] = V[A];  V[B_] = V[B];     
??Process_7:
        LDRH     R0,[SP, #+32]
        ADDS     R4,R4,#+1024
        SXTH     R4,R4
        STRH     R0,[SP, #+36]
        LDRH     R0,[SP, #+10]
        STRH     R0,[SP, #+38]
//  328       }
??Process_5:
        ADDS     R7,R7,#+1
        SXTH     R7,R7
        CMP      R7,#+4096
        BGE.W    ??Process_8
??Process_2:
        LDR.N    R0,??Process_0+0x14  ;; DataBuf
        ADDS     R0,R0,R7, LSL #+2
        STR      R0,[SP, #+4]
        LDRSH    R0,[R10, #+120]
        CMP      R0,#+17
        BLT.N    ??Process_9
        LDRSH    R0,[R10, #+20]
        CBZ      R0,??Process_10
??Process_9:
        MOVS     R0,#+1
        _BLF     __Get,??__Get??rT
        CBNZ     R0,??Process_11
        LDRH     R0,[R6, #+58]
        CMP      R7,R0
        BNE.N    ??Process_11
        LDRSH    R1,[R10, #+20]
        CBNZ     R1,??Process_11
        ADDS     R0,R0,#+1
        STRH     R0,[R6, #+58]
??Process_10:
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        LDR      R1,[SP, #+4]
        STR      R0,[R1, #+0]
??Process_11:
        LDR      R0,[SP, #+4]
        LDR      R2,[R0, #+0]
        MOVS     R0,R2
        STRB     R0,[SP, #+0]
        LDR      R0,[R6, #+104]
        LDRB     R1,[SP, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R6, #+104]
        LDRB     R0,[SP, #+0]
        STR      R0,[SP, #+60]
        LDRSH    R1,[R6, #+54]
        SUBS     R0,R0,R1
        LDR      R1,[R6, #+112]
        MLA      R0,R0,R0,R1
        STR      R0,[R6, #+112]
        LSRS     R0,R2,#+8
        STRB     R0,[SP, #+1]
        LDRB     R1,[SP, #+1]
        LDR      R0,[R6, #+108]
        LDR      R3,[R6, #+116]
        ADDS     R0,R0,R1
        STR      R0,[R6, #+108]
        LDRSH    R0,[R6, #+56]
        SUBS     R0,R1,R0
        MLA      R0,R0,R0,R3
        STR      R0,[R6, #+116]
        LDRB     R0,[R6, #+4]
        LDRB     R3,[SP, #+0]
        CMP      R0,R3
        IT      CC 
        STRBCC   R3,[R6, #+4]
        MOV      R0,R3
        LDRB     R3,[R6, #+6]
        CMP      R0,R3
        IT      CC 
        STRBCC   R0,[R6, #+6]
        LDRB     R0,[R6, #+5]
        CMP      R0,R1
        IT      CC 
        STRBCC   R1,[R6, #+5]
        LDRB     R0,[R6, #+7]
        CMP      R1,R0
        IT      CC 
        STRBCC   R1,[R6, #+7]
        LSRS     R0,R2,#+16
        UXTB     R0,R0
        STR      R0,[SP, #+12]
        CMP      R7,#+2
        BLT.W    ??Process_4
        LDR.N    R0,??Process_0+0x18  ;; 0xffe
        CMP      R7,R0
        BGE.W    ??Process_4
        LDR      R2,[SP, #+16]
        UXTH     R0,R7
        CMP      R2,#+2
        BNE.N    ??Process_12
        STRH     R7,[R6, #+10]
        STR      R0,[SP, #+64]
        MOVS     R2,#+0
        STRH     R2,[R6, #+18]
??Process_12:
        LDRB     R2,[R6, #+0]
        LDRB     R3,[SP, #+0]
        CMP      R2,R3
        BCS.N    ??Process_13
        LDR      R2,[SP, #+16]
        CBNZ     R2,??Process_14
        LDRH     R2,[R6, #+26]
        STRH     R7,[R6, #+10]
        ADDS     R2,R2,#+1
        STRH     R2,[R6, #+26]
??Process_14:
        MOVS     R2,#+1
        STR      R2,[SP, #+16]
        B.N      ??Process_15
??Process_13:
        MOV      R2,R3
        LDRB     R3,[R6, #+1]
        CMP      R2,R3
        BCS.N    ??Process_15
        LDR      R2,[SP, #+16]
        CMP      R2,#+1
        BNE.N    ??Process_15
        STR      R8,[SP, #+16]
        LDRH     R2,[R6, #+18]
        LDRH     R3,[R6, #+10]
        ADDS     R2,R2,R7
        SUBS     R2,R2,R3
        STRH     R2,[R6, #+18]
??Process_15:
        LDR      R2,[SP, #+20]
        CMP      R2,#+2
        BNE.N    ??Process_16
        STRH     R7,[R6, #+12]
        STR      R0,[SP, #+68]
        MOVS     R2,#+0
        STRH     R2,[R6, #+20]
??Process_16:
        LDRB     R2,[R6, #+2]
        CMP      R2,R1
        BCS.N    ??Process_17
        LDR      R2,[SP, #+20]
        CBNZ     R2,??Process_18
        LDRH     R2,[R6, #+28]
        STRH     R7,[R6, #+12]
        ADDS     R2,R2,#+1
        STRH     R2,[R6, #+28]
??Process_18:
        MOVS     R2,#+1
        STR      R2,[SP, #+20]
        B.N      ??Process_19
??Process_17:
        LDRB     R2,[R6, #+3]
        CMP      R1,R2
        BCS.N    ??Process_19
        LDR      R2,[SP, #+20]
        CMP      R2,#+1
        BNE.N    ??Process_19
        STR      R8,[SP, #+20]
        LDRH     R2,[R6, #+20]
        LDRH     R3,[R6, #+12]
        ADDS     R2,R2,R7
        SUBS     R2,R2,R3
        STRH     R2,[R6, #+20]
??Process_19:
        LDR      R2,[SP, #+24]
        CMP      R2,#+2
        BNE.N    ??Process_20
        STRH     R7,[R6, #+14]
        STR      R0,[SP, #+72]
        MOVS     R2,#+0
        STRH     R2,[R6, #+22]
??Process_20:
        LDR      R2,[SP, #+12]
        LSLS     R2,R2,#+31
        LDR      R2,[SP, #+24]
        BPL.N    ??Process_21
        CBNZ     R2,??Process_22
        LDRH     R2,[R6, #+30]
        STRH     R7,[R6, #+14]
        ADDS     R2,R2,#+1
        STRH     R2,[R6, #+30]
??Process_22:
        MOVS     R2,#+1
        STR      R2,[SP, #+24]
        B.N      ??Process_23
        DATA
??Process_0:
        DC32     a_Mid_H
        DC32     Title
        DC32     FileBuff
        DC32     Kb2
        DC32     0x25a00
        DC32     DataBuf
        DC32     0xffe
        THUMB
??Process_21:
        CMP      R2,#+1
        BNE.N    ??Process_23
        STR      R8,[SP, #+24]
        LDRH     R2,[R6, #+22]
        LDRH     R3,[R6, #+14]
        ADDS     R2,R2,R7
        SUBS     R2,R2,R3
        STRH     R2,[R6, #+22]
??Process_23:
        LDR      R2,[SP, #+28]
        CMP      R2,#+2
        BNE.N    ??Process_24
        STRH     R7,[R6, #+16]
        STR      R0,[SP, #+76]
        MOVS     R0,#+0
        STRH     R0,[R6, #+24]
??Process_24:
        LDR      R0,[SP, #+12]
        LSLS     R0,R0,#+30
        BPL.W    ??Process_3
        CBNZ     R2,??Process_25
        LDRH     R0,[R6, #+32]
        STRH     R7,[R6, #+16]
        ADDS     R0,R0,#+1
        STRH     R0,[R6, #+32]
??Process_25:
        MOVS     R0,#+1
        STR      R0,[SP, #+28]
        B.N      ??Process_4
//  329     }
//  330   } 
//  331   else {                            // 交替采样模式
//  332     k =((1024 -_Kp2)*150 + 512)/1024 + _X_posi.Value;  // 计算插值运算后窗口位置的修正值
??Process_1:
        ADDS     R2,R2,#+114
        LDRH     R2,[R2, #+0]
        MOVS     R3,#+150
//  333     for(i=0; i <4096; i++){
        MOVS     R7,#+0
        MLS      R1,R2,R3,R1
        ASRS     R2,R1,#+9
        ADDS     R1,R1,R2, LSR #+22
        ASRS     R1,R1,#+10
        ADDS     R0,R1,R0
        MOV      R11,R0
//  334       if(_Status == RUN)  DataBuf[i] = __Read_FIFO(); // 读入32位FIFO数据, 读后指针+1
??Process_26:
        LDR.N    R0,??Process_27  ;; DataBuf
        ADDS     R0,R0,R7, LSL #+2
        STR      R0,[SP, #+4]
        LDRSH    R0,[R10, #+20]
        CBNZ     R0,??Process_28
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        LDR      R1,[SP, #+4]
        STR      R0,[R1, #+0]
//  335       C_D    = DataBuf[i] >>16;
??Process_28:
        LDR      R0,[SP, #+4]
        LDR      R2,[R0, #+0]
        LSRS     R0,R2,#+16
        UXTB     R0,R0
        STR      R0,[SP, #+12]
//  336       if(_2_source == HIDE){                            // B通道合并到A通道时
        LDRH     R3,[R9, #+80]
        LDR      R1,[R6, #+112]
        LSRS     R0,R2,#+8
        STRH     R3,[SP, #+48]
        LDRSH    R3,[SP, #+48]
        CBNZ     R3,??Process_29
//  337         Ch[A]  = (DataBuf[i] & 0xFF );              
        STRB     R2,[SP, #+0]
//  338         Ch[B]  = ((DataBuf[i] >> 8) & 0xFF);//+ Kab;
        STRB     R0,[SP, #+1]
        LDRB     R2,[SP, #+0]
        LDRSH    R3,[R6, #+54]
//  339         Tmp    = (Ch[A]- A_Posi);
//  340         a_Ssq += (Tmp * Tmp)/2;
//  341         Tmp    = (Ch[B]- A_Posi);
        UXTB     R0,R0
        SUBS     R3,R2,R3
        MOVS     R2,R3
        MULS     R2,R3,R2
        LDRSH    R3,[R6, #+54]
//  342         a_Ssq += (Tmp * Tmp)/2;                         // 统计平方和                    
        ADDS     R2,R2,R2, LSR #+31
        SUBS     R0,R0,R3
        MOVS     R3,R0
        MULS     R3,R0,R3
        ADDS     R0,R3,R3, LSR #+31
        ASRS     R0,R0,#+1
        ADDS     R0,R0,R2, ASR #+1
        B.N      ??Process_30
//  343       } else {                                          // A通道合并到B通道时
//  344         Ch[B]  = (DataBuf[i] & 0xFF );//- Kab;              
??Process_29:
        STRB     R2,[SP, #+1]
//  345         Ch[A]  = ((DataBuf[i] >> 8) & 0xFF);  
        STRB     R0,[SP, #+0]
        LDRSH    R0,[R6, #+56]
        LDRB     R2,[SP, #+0]
        SUBS     R3,R2,R0
//  346         Tmp    = (Ch[A]- B_Posi);
//  347         a_Ssq += (Tmp * Tmp)/2;
        MOVS     R2,R3
        MULS     R2,R3,R2
//  348         Tmp    = (Ch[B]- B_Posi);
        LDRB     R3,[SP, #+1]
//  349         a_Ssq += (Tmp * Tmp)/2;                                    // 统计平方和                    
        ADDS     R2,R2,R2, LSR #+31
        SUBS     R0,R3,R0
        MOVS     R3,R0
        MULS     R3,R0,R3
        ADDS     R0,R3,R3, LSR #+31
        ASRS     R0,R0,#+1
        ADDS     R0,R0,R2, ASR #+1
??Process_30:
        ADDS     R0,R1,R0
        STR      R0,[R6, #+112]
//  350       }
//  351       a_Avg += (Ch[A]+Ch[B])/2;                                   // 累计直流平均值                                   
        LDRB     R0,[SP, #+1]
        STRB     R0,[SP, #+8]
        LDRB     R1,[SP, #+0]
        LDR      R2,[R6, #+104]
        ADDS     R0,R1,R0
        ADDS     R0,R0,R0, LSR #+31
        ADDS     R0,R2,R0, ASR #+1
        STR      R0,[R6, #+104]
//  352       if(Ch[A] > a_Max)  a_Max = Ch[A];          
        LDRB     R0,[R6, #+4]
        LDRB     R2,[SP, #+0]
        CMP      R0,R2
        ITT     CC 
        LDRBCC   R0,[SP, #+0]
        STRBCC   R0,[R6, #+4]
//  353       if(Ch[B] > a_Max)  a_Max = Ch[B];                          // 统计最大值 
        LDRB     R0,[R6, #+4]
        LDRB     R2,[SP, #+8]
        CMP      R0,R2
        IT      CC 
        STRBCC   R2,[R6, #+4]
//  354       if(Ch[A] < a_Min)  a_Min = Ch[A];         
        LDRB     R0,[SP, #+0]
        LDRB     R2,[R6, #+6]
        CMP      R0,R2
        IT      CC 
        STRBCC   R0,[R6, #+6]
//  355       if(Ch[B] < a_Min)  a_Min = Ch[B];                          // 统计最小值  
        LDRB     R0,[SP, #+8]
        LDRB     R2,[R6, #+6]
        CMP      R0,R2
        IT      CC 
        STRBCC   R0,[R6, #+6]
//  356 
//  357       if(i >= k){                 // 第1点指针到达指定窗口位置
        MOV      R0,R11
        SXTH     R0,R0
        CMP      R7,R0
        BLT.N    ??Process_31
//  358         if(_2_source == HIDE){                            // B通道合并到A通道时
        LDRSH    R0,[SP, #+48]
        CBNZ     R0,??Process_32
        LDRSH    R2,[R9, #+40]
        ADDS     R0,R6,R2, LSL #+1
        LDRH     R0,[R0, #+60]
        MULS     R1,R0,R1
        ADDW     R1,R1,#+512
        STR      R1,[SP, #+4]
        LDR      R3,[SP, #+4]
        ADDS     R1,R6,R2
        LDR      R2,[SP, #+4]
        LDRSB    R1,[R1, #+80]
        ASRS     R2,R2,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R2,R1,R2
        STRH     R2,[SP, #+32]
//  359           V[A] = Ka1[_A_Range] +(Ka2[_A_Range]*Ch[A]+ 512)/1024;    //计算当前第1点的主值
//  360           V[B] = Ka1[_A_Range] +(Ka2[_A_Range]*Ch[B]+ 512)/1024;    //计算当前第2点的主值
        LDRB     R2,[SP, #+8]
        MULS     R0,R2,R0
        ADDW     R0,R0,#+512
        ASRS     R2,R0,#+9
        ADDS     R0,R0,R2, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+34]
        B.N      ??Process_33
//  361         } else {                                          // A通道合并到B通道时
??Process_32:
        LDR.N    R0,??DataTable9  ;; Kb2
        LDRSH    R2,[R9, #+120]
        LDRH     R0,[R0, R2, LSL #+1]
        MULS     R1,R0,R1
        ADDW     R1,R1,#+512
        STR      R1,[SP, #+4]
        LDR      R3,[SP, #+4]
        ADDS     R1,R6,R2
        LDR      R2,[SP, #+4]
        LDRSB    R1,[R1, #+92]
        ASRS     R2,R2,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R2,R1,R2
        STRH     R2,[SP, #+32]
//  362           V[A] = Kb1[_B_Range] +(Kb2[_B_Range]*Ch[A]+ 512)/1024;   //计算当前第1点的主值
//  363           V[B] = Kb1[_B_Range] +(Kb2[_B_Range]*Ch[B]+ 512)/1024;   //计算当前第2点的主值
        LDRB     R2,[SP, #+8]
        MULS     R0,R2,R0
        ADDW     R0,R0,#+512
        ASRS     R2,R0,#+9
        ADDS     R0,R0,R2, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+34]
//  364         }
//  365         while(j > 0 ){
??Process_33:
        CMP      R4,#+1
        BLT.N    ??Process_34
//  366           Tmp = V[B_]+((V[A]- V[B_])*(1024 - j))/1024; //当前第1点的插值
        LDRSH    R0,[SP, #+38]
        LDRSH    R1,[SP, #+32]
        RSBS     R2,R4,#+1024
//  367           Send_Data(Tmp, Tmp, C_D, n++);
        UXTH     R3,R5
        SUBS     R1,R1,R0
        ADDS     R5,R5,#+1
        MULS     R1,R2,R1
        ASRS     R2,R1,#+9
        SXTH     R5,R5
        ADDS     R1,R1,R2, LSR #+22
        LDR      R2,[SP, #+12]
        ADDS     R0,R0,R1, ASR #+10
        SXTH     R1,R0
        UXTB     R2,R2
        SXTH     R0,R0
        BL       Send_Data
//  368           j -= _Kp2;
        LDRSH    R0,[R10, #+120]
        LDR      R2,[R6, #+120]
        MOVS     R1,#+20
        MLA      R0,R0,R1,R2
        ADDS     R0,R0,#+114
        LDRH     R0,[R0, #+0]
        SUBS     R4,R4,R0
        SXTH     R4,R4
//  369           if(n >= 300){ k = 8192;  break;}
        CMP      R5,#+300
        BLT.N    ??Process_33
        MOVS     R0,#+8192
        MOV      R11,R0
//  370         }
//  371         j += 1024;
??Process_34:
        ADDS     R4,R4,#+1024
        SXTH     R4,R4
//  372       }
//  373       if(i >= k){                 // 第2点指针到达指定窗口位置
??Process_31:
        MOV      R0,R11
        SXTH     R0,R0
        CMP      R7,R0
        BLT.N    ??Process_35
//  374         while(j > 0 ){
??Process_36:
        LDRH     R0,[SP, #+34]
        CMP      R4,#+1
        STRH     R0,[SP, #+10]
        BLT.N    ??Process_37
//  375           Tmp = V[A]+((V[B]- V[A])*(1024 - j))/1024;  //当前第2点的插值
        LDRSH    R0,[SP, #+32]
        LDRSH    R1,[SP, #+10]
        RSBS     R2,R4,#+1024
//  376           Send_Data(Tmp, Tmp, C_D, n++);
        UXTH     R3,R5
        SUBS     R1,R1,R0
        ADDS     R5,R5,#+1
        MULS     R1,R2,R1
        ASRS     R2,R1,#+9
        SXTH     R5,R5
        ADDS     R1,R1,R2, LSR #+22
        LDR      R2,[SP, #+12]
        ADDS     R0,R0,R1, ASR #+10
        SXTH     R1,R0
        UXTB     R2,R2
        SXTH     R0,R0
        BL       Send_Data
//  377           j -= _Kp2;
        LDRSH    R0,[R10, #+120]
        LDR      R2,[R6, #+120]
        MOVS     R1,#+20
        MLA      R0,R0,R1,R2
        ADDS     R0,R0,#+114
        LDRH     R0,[R0, #+0]
        SUBS     R4,R4,R0
        SXTH     R4,R4
//  378           if(n >= 300){ k = 8192;  break;}
        CMP      R5,#+300
        BLT.N    ??Process_36
        MOVS     R0,#+8192
        MOV      R11,R0
//  379         }
//  380         j += 1024;
//  381         V[B_] = V[B];       
??Process_37:
        LDRH     R0,[SP, #+10]
        ADDS     R4,R4,#+1024
        SXTH     R4,R4
        STRH     R0,[SP, #+38]
//  382       }
//  383     }
??Process_35:
        ADDS     R7,R7,#+1
        SXTH     R7,R7
        CMP      R7,#+4096
        BLT.W    ??Process_26
//  384     b_Avg  = a_Avg;
        LDR      R0,[R6, #+104]
        STR      R0,[R6, #+108]
//  385     b_Ssq  = a_Ssq;
        LDR      R0,[R6, #+112]
        STR      R0,[R6, #+116]
//  386     b_Max  = a_Max;
        LDRB     R0,[R6, #+4]
        STRB     R0,[R6, #+5]
//  387     b_Min  = a_Min;
        LDRB     R0,[R6, #+6]
        STRB     R0,[R6, #+7]
//  388 
//  389     if(_1_source == HIDE)  a_Avg = _1_posi*4096;   // A通道合并到B通道时      
        LDRSH    R0,[R9, #+0]
        CBNZ     R0,??Process_38
        LDRSH    R0,[R9, #+60]
        LSLS     R0,R0,#+12
        STR      R0,[R6, #+104]
//  390     if(_2_source == HIDE)  b_Avg = _2_posi*4096;   // B通道合并到A通道时
??Process_38:
        LDRSH    R0,[SP, #+48]
        CBNZ     R0,??Process_8
        LDR      R0,[SP, #+52]
        LDRSH    R0,[R0, #+0]
        LSLS     R0,R0,#+12
        STR      R0,[R6, #+108]
//  391   }
//  392 
//  393   a_Mid_H = 4 +(a_Max + a_Min)/2;
??Process_8:
        LDRB     R0,[R6, #+4]
        LDRB     R1,[R6, #+6]
        ADDS     R0,R0,R1
//  394   a_Mid_L = a_Mid_H - 8;
//  395   b_Mid_H = 4 +(b_Max + b_Min)/2;
        LDRB     R1,[R6, #+7]
        ADDS     R0,R0,R0, LSR #+31
        ASRS     R0,R0,#+1
        ADDS     R0,R0,#+4
        STRB     R0,[R6, #+0]
        ADDS     R0,R0,#+248
        STRB     R0,[R6, #+1]
        LDRB     R0,[R6, #+5]
        ADDS     R0,R0,R1
        ADDS     R0,R0,R0, LSR #+31
        ASRS     R0,R0,#+1
        ADDS     R0,R0,#+4
        STRB     R0,[R6, #+2]
//  396   b_Mid_L = b_Mid_H - 8;
        ADDS     R0,R0,#+248
        STRB     R0,[R6, #+3]
//  397 
//  398   TaS -= Ta; TbS -= Tb; TcS -= Tc; TdS -= Td;
        LDRH     R0,[R6, #+10]
        LDR      R1,[SP, #+64]
        SUBS     R0,R0,R1
        STRH     R0,[R6, #+10]
        LDRH     R0,[R6, #+12]
        LDR      R1,[SP, #+68]
        SUBS     R0,R0,R1
        STRH     R0,[R6, #+12]
        LDRH     R0,[R6, #+14]
        LDR      R1,[SP, #+72]
        SUBS     R0,R0,R1
        STRH     R0,[R6, #+14]
        LDRH     R0,[R6, #+16]
        LDR      R1,[SP, #+76]
        SUBS     R0,R0,R1
        STRH     R0,[R6, #+16]
//  399   
//  400   for(j=0; j<4; j++){                               // 消除屏幕端点连线
        MOVS     R0,#+0
//  401     TrackBuff[(  0)*4+ j] = TrackBuff[(  1)*4 + j];
??Process_39:
        LDR.N    R1,??DataTable19  ;; TrackBuff
        ADDS     R2,R1,R0
        LDRB     R2,[R2, #+4]
        STRB     R2,[R1, R0]
//  402     TrackBuff[(299)*4+ j] = TrackBuff[(298)*4 + j];
        ADDS     R1,R1,R0
        ADDS     R1,R1,#+1192
        LDRB     R2,[R1, #+0]
//  403   }
        ADDS     R0,R0,#+1
        CMP      R0,#+4
        STRB     R2,[R1, #+4]
        BLT.N    ??Process_39
//  404 }
        ADD      SP,SP,#+80
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??Process_27:
        DC32     DataBuf
        CFI EndBlock cfiBlock6

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable9:
        DC32     Kb2
//  405 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function Send_Data
        THUMB
//  406 void Send_Data(s16 Va, s16 Vb, u8 C_D, u16 n)  //输出显示数据
//  407 {
Send_Data:
        PUSH     {R4-R11}
        CFI R11 Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
//  408   s32 Tmp, i;
//  409 
//  410   i = n*4;
        LDR.N    R4,??DataTable19  ;; TrackBuff
        SUB      SP,SP,#+20
        CFI CFA R13+52
        MOV      R8,R1
        MOV      R11,R3
        LSLS     R3,R3,#+2
        MOV      R9,R4
        CMP      R0,#+200
        BLT.N    ??Send_Data_1
//  411   if(Va >= Y_BASE+Y_SIZE)  TrackBuff[i + TRACK1] = Y_BASE+Y_SIZE-1;
        MOVS     R5,#+199
        STRB     R5,[R4, R3]
        B.N      ??Send_Data_2
//  412   else if(Va <= Y_BASE+1)  TrackBuff[i + TRACK1] = Y_BASE+1;
??Send_Data_1:
        CMP      R0,#+2
        ITEE    GE 
        STRBGE   R0,[R4, R3]
        MOVLT    R5,#+1
        STRBLT   R5,[R4, R3]
//  413   else                     TrackBuff[i + TRACK1] = Va;
//  414   if(Vb >= Y_BASE+Y_SIZE)  TrackBuff[i + TRACK2] = Y_BASE+Y_SIZE-1;
??Send_Data_2:
        MOV      R4,R8
        CMP      R4,#+200
        BLT.N    ??Send_Data_3
        MOV      R4,R9
        ADDS     R4,R4,R3
        MOVS     R5,#+199
        B.N      ??Send_Data_4
//  415   else if(Vb <= Y_BASE+1)  TrackBuff[i + TRACK2] = Y_BASE+1;
??Send_Data_3:
        CMP      R4,#+2
        MOV      R4,R9
        BGE.N    ??Send_Data_5
        ADDS     R4,R4,R3
        MOVS     R5,#+1
        B.N      ??Send_Data_4
//  416   else                     TrackBuff[i + TRACK2] = Vb;
??Send_Data_5:
        ADDS     R4,R4,R3
        MOV      R5,R8
??Send_Data_4:
        STRB     R5,[R4, #+1]
//  417   
//  418   if(C_D & 1)  TrackBuff[i + TRACK3] = c_Max;
        LDR.N    R5,??DataTable15  ;; Title
        MOVS     R4,R5
        ADDS     R4,R4,#+236
        STR      R4,[SP, #+0]
        LDR.N    R4,??DataTable16  ;; a_Mid_H
        LSLS     R6,R2,#+31
        MOV      R6,R9
        BPL.N    ??Send_Data_6
        LDRH     R7,[R4, #+50]
        ADDS     R6,R6,R3
        B.N      ??Send_Data_7
//  419   else         TrackBuff[i + TRACK3] = _3_posi;
??Send_Data_6:
        LDR      R7,[SP, #+0]
        ADDS     R6,R6,R3
        LDRH     R7,[R7, #+0]
??Send_Data_7:
        STRB     R7,[R6, #+2]
//  420   
//  421   switch (_4_source){                       
        LDRSH    R6,[R4, #+34]
        ADDS     R5,R5,#+16
        ADDS     R6,R6,R0
        STR      R6,[SP, #+12]
        LDRSH    R6,[R4, #+36]
        ADDS     R0,R6,R0
        LDR.N    R6,??DataTable14  ;; FileBuff
        STR      R0,[SP, #+16]
        LDR      R0,[SP, #+0]
        ADDS     R10,R11,R6
        LDR      R6,[SP, #+0]
        LDRSH    R0,[R0, #+80]
        STR      R5,[SP, #+4]
        STR      R0,[SP, #+8]
        LDRSH    R6,[R6, #+20]
        LDRSH    R0,[R5, #+0]
        LDRB     R5,[R4, #+8]
        SUBS     R6,R6,#+2
        CMP      R6,#+7
        BHI.N    ??Send_Data_8
        TBB      [PC, R6]
        DATA
??Send_Data_0:
        DC8      +4,+21,+38,+45
        DC8      +51,+57,+62,+68
        THUMB
//  422   case A_add_B:
//  423     if(Interlace == 0) Tmp = Posi_412 + Va + Vb;
??Send_Data_9:
        CBNZ     R5,??Send_Data_10
        LDR      R0,[SP, #+12]
        ADDS     R1,R8,R0
        B.N      ??Send_Data_11
//  424     else{
//  425       if(_1_source != HIDE) Tmp = Posi_41  + Va;
??Send_Data_10:
        CBZ      R0,??Send_Data_12
        LDR      R1,[SP, #+16]
//  426       if(_2_source != HIDE) Tmp = Posi_42  + Vb;
??Send_Data_12:
        LDR      R0,[SP, #+4]
        LDRSH    R0,[R0, #+80]
        CMP      R0,#+0
        BEQ.N    ??Send_Data_11
        LDRSH    R0,[R4, #+38]
        ADDS     R1,R8,R0
        B.N      ??Send_Data_11
//  427     } break;
//  428   case A_sub_B:
//  429     if(Interlace == 0) Tmp = Posi_412 + Va - Vb;
??Send_Data_13:
        CBNZ     R5,??Send_Data_14
        LDR      R0,[SP, #+12]
        SUBS     R1,R0,R8
        B.N      ??Send_Data_11
//  430     else{
//  431       if(_1_source != HIDE) Tmp = Posi_41  + Va;
??Send_Data_14:
        CBZ      R0,??Send_Data_15
        LDR      R1,[SP, #+16]
//  432       if(_2_source != HIDE) Tmp = Posi_4_2 - Vb;
??Send_Data_15:
        LDR      R0,[SP, #+4]
        LDRSH    R0,[R0, #+80]
        CMP      R0,#+0
        BEQ.N    ??Send_Data_11
        LDRSH    R0,[R4, #+40]
        SUBS     R1,R0,R8
        B.N      ??Send_Data_11
//  433     } break;
//  434   case C_and_D:
//  435     if((~C_D)& 3) Tmp = d_Max; 
??Send_Data_16:
        MVNS     R0,R2
        LSLS     R0,R0,#+30
        ITE     EQ 
        LDREQ    R1,[SP, #+8]
        LDRSHNE  R1,[R4, #+52]
        B.N      ??Send_Data_11
//  436     else          Tmp = _4_posi;
//  437     break;  
//  438   case C_or_D:
//  439     if(C_D & 3)   Tmp = d_Max; 
??Send_Data_17:
        LSLS     R0,R2,#+30
        ITE     EQ 
        LDREQ    R1,[SP, #+8]
        LDRSHNE  R1,[R4, #+52]
        B.N      ??Send_Data_11
//  440     else          Tmp = _4_posi;
//  441     break;  
//  442   case REC_1:
//  443     Tmp = Posi_4F1 + FileBuff[n];  
??Send_Data_18:
        LDRSH    R0,[R4, #+42]
        LDRB     R1,[R10, #+0]
??Send_Data_19:
        ADDS     R1,R0,R1
        B.N      ??Send_Data_11
//  444     break;
//  445   case REC_2:
//  446     Tmp = Posi_4F2 + FileBuff[n+300];  
??Send_Data_20:
        LDRSH    R0,[R4, #+44]
        LDRB     R1,[R10, #+300]
        B.N      ??Send_Data_19
//  447     break;
//  448   case REC_3:
//  449     Tmp = Posi_4F3 + FileBuff[n+600];  
??Send_Data_21:
        LDRSH    R0,[R4, #+46]
        LDRB     R1,[R10, #+600]
        ADDS     R1,R0,R1
        B.N      ??Send_Data_11
//  450     break;
//  451   case REC_4:
//  452     Tmp = Posi_4F4 +  FileBuff[n+900];  
??Send_Data_22:
        LDRSH    R0,[R4, #+48]
        LDRB     R1,[R10, #+900]
        B.N      ??Send_Data_19
//  453     break;
//  454   default:
//  455     if(C_D & 2)  Tmp = d_Max;
??Send_Data_8:
        LSLS     R0,R2,#+30
        ITE     PL 
        LDRPL    R1,[SP, #+8]
        LDRSHMI  R1,[R4, #+52]
//  456     else         Tmp = _4_posi;
//  457   }
//  458   if(Tmp >= Y_BASE+Y_SIZE)  TrackBuff[i + TRACK4] = Y_BASE+Y_SIZE-1;
??Send_Data_11:
        CMP      R1,#+200
        BLT.N    ??Send_Data_23
        MOV      R0,R9
        ADDS     R0,R0,R3
        MOVS     R1,#+199
        B.N      ??Send_Data_24
//  459   else if(Tmp <= Y_BASE+1)  TrackBuff[i + TRACK4] = Y_BASE+1;
??Send_Data_23:
        CMP      R1,#+2
        MOV      R0,R9
        BGE.N    ??Send_Data_25
        ADDS     R0,R0,R3
        MOVS     R1,#+1
        B.N      ??Send_Data_24
//  460   else                      TrackBuff[i + TRACK4] = Tmp;
??Send_Data_25:
        ADDS     R0,R0,R3
??Send_Data_24:
        STRB     R1,[R0, #+3]
//  461 }
        ADD      SP,SP,#+20
        CFI CFA R13+32
        POP      {R4-R11}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable14:
        DC32     FileBuff
//  462 /*******************************************************************************
//  463  Synchro: 扫描同步处理，按设定模式显示波形 
//  464 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function Synchro
        THUMB
//  465 void Synchro(void)  //扫描同步方式共有：AUTO、NORM、SGL、NONE、SCAN 5种模式
//  466 { 
//  467   u16  i;
//  468 
//  469   switch (_Mode){ 
Synchro:
        LDR.N    R0,??DataTable15  ;; Title
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        LDR.N    R5,??DataTable16  ;; a_Mid_H
        LDR.N    R6,??DataTable17  ;; Wait_Cnt
        MOV      R8,R0
        ADDW     R0,R8,#+576
        LDRSH    R1,[R0, #+0]
        LDRSH    R0,[R0, #+20]
        ADDW     R4,R8,#+336
        MOVS     R7,#+0
        ADDS     R1,R0,R1, LSL #+3
        LDR.N    R0,??DataTable18  ;; Wait
        MOV      R9,R0
        LDR.N    R0,??DataTable19  ;; TrackBuff
        MOV      R10,R0
        LDRSH    R0,[R4, #+80]
        CMP      R0,#+4
        BHI.N    ??Synchro_1
        TBB      [PC, R0]
        DATA
??Synchro_0:
        DC8      +3,+27,+50,+58
        DC8      +58,+0
        THUMB
//  470   case AUTO:
//  471     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_2:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  472     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_3
//  473       Process();                                  // 生成新的显示波形
??Synchro_4:
        BL       Process
//  474       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R4, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
??Synchro_5:
        STR      R0,[R6, #+0]
        B.N      ??Synchro_1
//  475     } else if(Wait_Cnt==0){
??Synchro_3:
        LDR      R0,[R6, #+0]
        CMP      R0,#+0
        BNE.N    ??Synchro_1
//  476       if(JumpCnt >= 4095)  JumpCnt = 0;         
        LDRH     R0,[R5, #+58]
        LDR.N    R1,??Synchro_6   ;; 0xfff
        CMP      R0,R1
        BCC.N    ??Synchro_4
        STRH     R7,[R5, #+58]
        B.N      ??Synchro_4
//  477       Process();   
//  478       Wait_Cnt = Wait[_T_base];
//  479     } break;
//  480   case NORM:
//  481     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_7:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  482     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CMP      R0,#+0
        BNE.N    ??Synchro_4
//  483       Process();                                  // 生成新的显示波形
//  484       Wait_Cnt = Wait[_T_base];
//  485     } else if(Wait_Cnt==0){
        LDR      R0,[R6, #+0]
        CBNZ     R0,??Synchro_1
//  486       for(i=0; i<4*X_SIZE; ++i)  TrackBuff[i] = 0;// 清除旧的显示波形
??Synchro_8:
        MOV      R1,R10
        MOVS     R2,#+1200
        STRB     R7,[R1, R0]
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        CMP      R0,R2
        BCC.N    ??Synchro_8
//  487       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R4, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        B.N      ??Synchro_5
//  488     } break;
//  489   case SGL:
//  490     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_9:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  491     if(__Get(FIFO_START)!=0)  Process();          // 生成新的显示波形
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_1
        B.N      ??Synchro_10
//  492     break;
//  493   case NONE:
//  494   case SCAN:
//  495     __Set(TRIGG_MODE, UNCONDITION);               // 设为无条件触发
??Synchro_11:
        MOVS     R1,#+32
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  496     Process();                                    // 生成当前显示波形
??Synchro_10:
        BL       Process
//  497     break;
//  498   }
//  499   Draw_Window();                                  // 刷新屏幕波形显示区
??Synchro_1:
        _BLF     Draw_Window,??Draw_Window??rT
//  500 
//  501   if((_Status == RUN)&&(__Get(FIFO_FULL)!=0)){    // FIFO is full
        LDRSH    R0,[R4, R7]
        CMP      R0,#+0
        BNE.N    ??Synchro_12
        MOVS     R0,#+3
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_12
//  502     __Set(FIFO_CLR, W_PTR);                       // FIFO写指针复位
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  503     Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R4, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R6, #+0]
//  504     JumpCnt =0;
//  505     if(_Mode == SGL){
        LDRSH    R0,[R4, #+80]
        STRH     R7,[R5, #+58]
        CMP      R0,#+2
        BNE.N    ??Synchro_13
//  506       _Status = HOLD;                             // 一帧完后，进入暂停
        MOVS     R0,#+1
        STRH     R0,[R4, #+0]
//  507       _State.Flag |= UPDAT;
        LDRB     R0,[R4, #+2]
        ORRS     R0,R0,#0x2
        STRB     R0,[R4, #+2]
        B.N      ??Synchro_12
//  508     }
//  509     if(_Mode == SCAN){
??Synchro_13:
        CMP      R0,#+4
        BNE.N    ??Synchro_12
//  510       for(i=0; i<X_SIZE; i++){                    // 重建当前轨迹基线                   
        MOVS     R0,#+0
??Synchro_14:
        MOV      R2,R8
        LDRH     R3,[R2, #+76]!
        ADDS     R1,R10,R0, LSL #+2
//  511         TrackBuff[i*4 + TRACK1] = _1_posi;
//  512         TrackBuff[i*4 + TRACK2] = _2_posi; 
        ADDS     R2,R2,#+80
        STRB     R3,[R1, #+0]
        LDRH     R2,[R2, #+0]
//  513         TrackBuff[i*4 + TRACK3] = _3_posi; 
//  514         TrackBuff[i*4 + TRACK4] = _4_posi;
//  515       }
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        STRB     R2,[R1, #+1]
        MOV      R2,R8
        LDRH     R3,[R2, #+236]!
        ADDS     R2,R2,#+80
        STRB     R3,[R1, #+2]
        LDRH     R2,[R2, #+0]
        STRB     R2,[R1, #+3]
        MOVS     R2,#+300
        CMP      R0,R2
        BCC.N    ??Synchro_14
//  516     }
//  517   }    
//  518 }  
??Synchro_12:
        POP      {R4-R10,PC}      ;; return
        DATA
??Synchro_6:
        DC32     0xfff
        CFI EndBlock cfiBlock8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable15:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable16:
        DC32     a_Mid_H

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable17:
        DC32     Wait_Cnt

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable18:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable19:
        DC32     TrackBuff

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Set??rT:
        LDR.N    R3,??Subroutine0_0  ;; __Set
        BX       R3
        DATA
??Subroutine0_0:
        DC32     __Set
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Clear_Screen??rT:
        LDR.N    R3,??Subroutine1_0  ;; __Clear_Screen
        BX       R3
        DATA
??Subroutine1_0:
        DC32     __Clear_Screen
        CFI EndBlock cfiBlock10

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI NoFunction
        THUMB
??Delayms??rT:
        LDR.N    R3,??Subroutine2_0  ;; Delayms
        BX       R3
        DATA
??Subroutine2_0:
        DC32     Delayms
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_Ref_Wave??rT:
        LDR.N    R3,??Subroutine3_0  ;; Get_Ref_Wave
        BX       R3
        DATA
??Subroutine3_0:
        DC32     Get_Ref_Wave
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI NoFunction
        THUMB
??rT??div32_t:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine4_0  ;; ??div32_t
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine4_0:
        DC32     ??div32_t
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Read_FIFO??rT:
        LDR.N    R3,??Subroutine5_0  ;; __Read_FIFO
        BX       R3
        DATA
??Subroutine5_0:
        DC32     __Read_FIFO
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Get??rT:
        LDR.N    R3,??Subroutine6_0  ;; __Get
        BX       R3
        DATA
??Subroutine6_0:
        DC32     __Get
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??Draw_Window??rT:
        LDR.N    R3,??Subroutine7_0  ;; Draw_Window
        BX       R3
        DATA
??Subroutine7_0:
        DC32     Draw_Window
        CFI EndBlock cfiBlock16

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for a_Mid_H>`:
        DATA
        DC8 0
`?<Initializer for a_Mid_L>`:
        DC8 0
`?<Initializer for b_Mid_H>`:
        DC8 0
`?<Initializer for b_Mid_L>`:
        DC8 0
`?<Initializer for a_Max>`:
        DC8 0
`?<Initializer for b_Max>`:
        DC8 0
`?<Initializer for a_Min>`:
        DC8 0
`?<Initializer for b_Min>`:
        DC8 0
`?<Initializer for Interlace>`:
        DC8 0
        DC8 0
`?<Initializer for TaS>`:
        DC8 0, 0
`?<Initializer for TbS>`:
        DC8 0, 0
`?<Initializer for TcS>`:
        DC8 0, 0
`?<Initializer for TdS>`:
        DC8 0, 0
`?<Initializer for PaS>`:
        DC8 0, 0
`?<Initializer for PbS>`:
        DC8 0, 0
`?<Initializer for PcS>`:
        DC8 0, 0
`?<Initializer for PdS>`:
        DC8 0, 0
`?<Initializer for TaN>`:
        DC8 0, 0
`?<Initializer for TbN>`:
        DC8 0, 0
`?<Initializer for TcN>`:
        DC8 0, 0
`?<Initializer for TdN>`:
        DC8 0, 0
`?<Initializer for Posi_412>`:
        DC8 0, 0
`?<Initializer for Posi_41>`:
        DC8 0, 0
`?<Initializer for Posi_42>`:
        DC8 0, 0
`?<Initializer for Posi_4_2>`:
        DC8 0, 0
`?<Initializer for Posi_4F1>`:
        DC8 0, 0
`?<Initializer for Posi_4F2>`:
        DC8 0, 0
`?<Initializer for Posi_4F3>`:
        DC8 0, 0
`?<Initializer for Posi_4F4>`:
        DC8 0, 0
`?<Initializer for c_Max>`:
        DC8 0, 0
`?<Initializer for d_Max>`:
        DC8 0, 0
`?<Initializer for A_Posi>`:
        DC8 0, 0
`?<Initializer for B_Posi>`:
        DC8 0, 0
`?<Initializer for JumpCnt>`:
        DC8 0, 0
`?<Initializer for Ka2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Ka1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Kb1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for a_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for X_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Full>`:
        DATA
        DC8 1

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for Kb2>`:
        DATA
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for D_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 179, 39999, 50
        DC8 " 20Hz "
        DC8 0
        DC16 179, 19999, 50
        DC8 " 50Hz "
        DC8 0
        DC16 179, 7999, 50
        DC8 "!100Hz!"
        DC16 179, 3999, 50
        DC8 "!200Hz!"
        DC16 179, 1999, 50
        DC8 "!500Hz!"
        DC16 179, 799, 50
        DC8 " 1KHz "
        DC8 0
        DC16 179, 399, 50
        DC8 " 2KHz "
        DC8 0
        DC16 179, 199, 50
        DC8 " 5KHz "
        DC8 0
        DC16 17, 799, 50
        DC8 "!10KHz!"
        DC16 17, 399, 50
        DC8 "!20KHz!"
        DC16 17, 199, 50
        DC8 "!50KHz!"
        DC16 0, 1439, 50
        DC8 "100KHz"
        DC8 0
        DC16 0, 719, 50
        DC8 "200KHz"
        DC8 0
        DC16 0, 359, 50
        DC8 "500KHz"
        DC8 0
        DC16 0, 143, 50
        DC8 " 1MHz "
        DC8 0
        DC16 0, 71, 50
        DC8 " 2MHz "
        DC8 0
        DC16 0, 35, 50
        DC8 " 4MHz "
        DC8 0
        DC16 0, 17, 50
        DC8 " 6MHz "
        DC8 0
        DC16 0, 11, 50
        DC8 " 8MHz "
        DC8 0
        DC16 0, 8, 50

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for A_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 19, 9999
        DC8 " 20Hz "
        DC8 0
        DC16 19, 4999
        DC8 " 50Hz "
        DC8 0
        DC16 19, 1999
        DC8 "!100Hz!"
        DC16 19, 999
        DC8 "!200Hz!"
        DC16 19, 499
        DC8 "!500Hz!"
        DC16 19, 199
        DC8 " 1KHz "
        DC8 0
        DC16 19, 99
        DC8 " 2KHz "
        DC8 0
        DC16 19, 49
        DC8 " 5KHz "
        DC8 0
        DC16 19, 19
        DC8 "!10KHz!"
        DC16 19, 9
        DC8 "!20KHz!"
        DC16 19, 4
`?<Initializer for SIN_DATA>`:
        DC16 0, 39, 142, 304, 521, 785, 1089, 1423, 1776, 2138, 2496, 2841
        DC16 3161, 3446, 3688, 3878, 4011, 4083, 4095, 4055, 3952, 3790, 3573
        DC16 3309, 3005, 2671, 2318, 1956, 1598, 1253, 933, 648, 406, 216, 83
        DC16 11
`?<Initializer for TRG_DATA>`:
        DC16 0, 227, 454, 682, 909, 1137, 1364, 1592, 1819, 2047, 2274, 2502
        DC16 2729, 2957, 3184, 3412, 3639, 3867, 4094, 3867, 3639, 3412, 3184
        DC16 2957, 2729, 2502, 2274, 2047, 1819, 1592, 1364, 1137, 909, 682
        DC16 454, 227
`?<Initializer for SAW_DATA>`:
        DC16 0, 117, 234, 351, 468, 585, 702, 819, 936, 1053, 1170, 1287, 1404
        DC16 1521, 1638, 1755, 1872, 1989, 2106, 2223, 2340, 2457, 2574, 2691
        DC16 2808, 2925, 3042, 3159, 3276, 3393, 3510, 3627, 3744, 3861, 3978
        DC16 4095

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
//  519 /******************************** END OF FILE *********************************/
// 
//  3 454 bytes in segment CODE
//     56 bytes in segment DATA_C
//    773 bytes in segment DATA_I
//    773 bytes in segment DATA_ID
// 17 621 bytes in segment DATA_Z
//     24 bytes in segment INITTAB
// 
//  3 382 bytes of CODE  memory (+ 96 bytes shared)
//    829 bytes of CONST memory
// 18 394 bytes of DATA  memory
//
//Errors: none
//Warnings: none
