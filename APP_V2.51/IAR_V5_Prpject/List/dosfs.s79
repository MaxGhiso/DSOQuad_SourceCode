//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   17/Jun/2011  17:42:12 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203\PRG\APP_V2.50\source\dosfs.c        /
//    Command line    =  D:\Design\DS203\PRG\APP_V2.50\source\dosfs.c -lA    /
//                       D:\Design\DS203\PRG\APP_V2.50\IAR_V4_Prpject\List\  /
//                       -o D:\Design\DS203\PRG\APP_V2.50\IAR_V4_Prpject\Obj /
//                       \ -s9 --debug --cpu_mode thumb --endian little      /
//                       --cpu cortex-M3 --stack_align 4 --fpu None          /
//                       --dlib_config "C:\Program Files\IAR                 /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\LIB\dl7mptnnl8f.h" -I                /
//                       D:\Design\DS203\PRG\APP_V2.50\IAR_V4_Prpject\..\..\ /
//                       FWLib\inc\ -I D:\Design\DS203\PRG\APP_V2.50\IAR_V4_ /
//                       Prpject\..\..\USBLib\inc\ -I                        /
//                       D:\Design\DS203\PRG\APP_V2.50\IAR_V4_Prpject\..\inc /
//                       lude\ -I "C:\Program Files\IAR Systems\Embedded     /
//                       Workbench 4.0 Evaluation\arm\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\Design\DS203\PRG\APP_V2.50\IAR_V4_Prpject\List\d /
//                       osfs.s79                                            /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME dosfs

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

??DataTable1 EQU 0
??DataTable10 EQU 0
??DataTable11 EQU 0
??DataTable22 EQU 0
??DataTable23 EQU 0
??DataTable25 EQU 0
??DataTable28 EQU 0
??DataTable3 EQU 0
??DataTable8 EQU 0
??DataTable9 EQU 0
        MULTWEAK ??__Disk_Buff_RD??rT
        MULTWEAK ??__Disk_Buff_WR??rT
        MULTWEAK ??div??rT
        MULTWEAK ??ldiv??rT
        MULTWEAK ??memcmp??rT
        MULTWEAK ??memcpy??rT
        MULTWEAK ??memset??rT
        MULTWEAK ??strcmp??rT
        MULTWEAK ??strcpy??rT
        MULTWEAK ??strlen??rT
        MULTWEAK ??strncpy??rT
        PUBLIC DFS_CanonicalToDir
        FUNCTION DFS_CanonicalToDir,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC DFS_GetFAT
        FUNCTION DFS_GetFAT,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC DFS_GetFreeDirEnt
        FUNCTION DFS_GetFreeDirEnt,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC DFS_GetFreeFAT
        FUNCTION DFS_GetFreeFAT,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC DFS_GetNext
        FUNCTION DFS_GetNext,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC DFS_GetPtnStart
        FUNCTION DFS_GetPtnStart,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC DFS_GetVolInfo
        FUNCTION DFS_GetVolInfo,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC DFS_OpenDir
        FUNCTION DFS_OpenDir,0203H
        LOCFRAME CSTACK, 72, STACK
        PUBLIC DFS_OpenFile
        FUNCTION DFS_OpenFile,0203H
        LOCFRAME CSTACK, 172, STACK
        PUBLIC DFS_ReadFile
        FUNCTION DFS_ReadFile,0203H
        LOCFRAME CSTACK, 60, STACK
        PUBLIC DFS_ReadSector
        FUNCTION DFS_ReadSector,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC DFS_Seek
        FUNCTION DFS_Seek,0203H
        LOCFRAME CSTACK, 40, STACK
        PUBLIC DFS_SetFAT
        FUNCTION DFS_SetFAT,0203H
        LOCFRAME CSTACK, 52, STACK
        PUBLIC DFS_UnlinkFile
        FUNCTION DFS_UnlinkFile,0203H
        LOCFRAME CSTACK, 52, STACK
        PUBLIC DFS_WriteFile
        FUNCTION DFS_WriteFile,0203H
        LOCFRAME CSTACK, 84, STACK
        PUBLIC DFS_WriteSector
        FUNCTION DFS_WriteSector,0203H
        LOCFRAME CSTACK, 12, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
__Disk_Buff_RD      SYMBOL "__Disk_Buff_RD"
__Disk_Buff_WR      SYMBOL "__Disk_Buff_WR"
div                 SYMBOL "div"
ldiv                SYMBOL "ldiv"
memcmp              SYMBOL "memcmp"
memcpy              SYMBOL "memcpy"
memset              SYMBOL "memset"
strcmp              SYMBOL "strcmp"
strcpy              SYMBOL "strcpy"
strlen              SYMBOL "strlen"
strncpy             SYMBOL "strncpy"
??__Disk_Buff_RD??rT SYMBOL "??rT", __Disk_Buff_RD
??__Disk_Buff_WR??rT SYMBOL "??rT", __Disk_Buff_WR
??div??rT           SYMBOL "??rT", div
??ldiv??rT          SYMBOL "??rT", ldiv
??memcmp??rT        SYMBOL "??rT", memcmp
??memcpy??rT        SYMBOL "??rT", memcpy
??memset??rT        SYMBOL "??rT", memset
??strcmp??rT        SYMBOL "??rT", strcmp
??strcpy??rT        SYMBOL "??rT", strcpy
??strlen??rT        SYMBOL "??rT", strlen
??strncpy??rT       SYMBOL "??rT", strncpy

        EXTERN __Disk_Buff_RD
        FUNCTION __Disk_Buff_RD,0200H
        EXTERN __Disk_Buff_WR
        FUNCTION __Disk_Buff_WR,0200H
        EXTERN div
        FUNCTION div,010202H
        EXTERN ldiv
        FUNCTION ldiv,010202H
        EXTERN memcmp
        FUNCTION memcmp,010202H
        EXTERN memcpy
        FUNCTION memcpy,010202H
        EXTERN memset
        FUNCTION memset,010202H
        EXTERN strcmp
        FUNCTION strcmp,010202H
        EXTERN strcpy
        FUNCTION strcpy,010202H
        EXTERN strlen
        FUNCTION strlen,010202H
        EXTERN strncpy
        FUNCTION strncpy,010202H

// D:\Design\DS203\PRG\APP_V2.50\source\dosfs.c
//    1 /*
//    2   DOSFS Embedded FAT-Compatible Filesystem
//    3   (C) 2005 Lewin A.R.W. Edwards (sysadm@zws.com)
//    4 
//    5   You are permitted to modify and/or use this code in your own projects without
//    6   payment of royalty, regardless of the license(s) you choose for those projects.
//    7 
//    8   You cannot re-copyright or restrict use of the code as released by Lewin Edwards.
//    9 */
//   10 
//   11 #include <string.h>
//   12 #include <stdlib.h>
//   13 #include <stdio.h>
//   14 #include "BIOS.h"
//   15 #include "dosfs.h"
//   16 #include "stm32f10x_lib.h"
//   17 #include "Function.h"
//   18 //#include "ASM.h"
//   19 
//   20 #define DS203
//   21 
//   22 //===================================================================
//   23 // User-supplied functions

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function DFS_ReadSector
        THUMB
//   24 u32 DFS_ReadSector(u8 unit, u8 *buffer, u32 sector, u32 count)
//   25 {
DFS_ReadSector:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        MOVS     R0,R1
        MOVS     R1,R2
//   26     u32 add;
//   27     add=sector<<9;
//   28   __Disk_Buff_RD(buffer,add, SECTOR_SIZE);
        MOVS     R2,#+512
        LSLS     R1,R1,#+9
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//   29   return 0;
        MOVS     R0,#+0
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock0
//   30 }
//   31 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function DFS_WriteSector
        THUMB
//   32 u32 DFS_WriteSector(u8 unit, u8 *buffer, u32 sector, u32 count)
//   33 {
DFS_WriteSector:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        MOVS     R4,R1
//   34   u32 add;
//   35 
//   36       add=sector*512; 
//   37       __Disk_Buff_WR(buffer, add);
        MOVS     R0,R4
        LSLS     R5,R2,#+9
        MOVS     R1,R5
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//   38       __Disk_Buff_WR(&buffer[256], add+256);
        ADDW     R1,R5,#+256
        ADDW     R0,R4,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//   39       return 0;
        MOVS     R0,#+0
        POP      {R4,R5,PC}       ;; return
        CFI EndBlock cfiBlock1
//   40 }
//   41 //===================================================================
//   42 /*
//   43   Get starting sector# of specified partition on drive #unit
//   44   NOTE: This code ASSUMES an MBR on the disk.
//   45   scratchsector should point to a SECTOR_SIZE scratch area
//   46   Returns 0xffffffff for any error.
//   47   If pactive is non-NULL, this function also returns the partition active flag.
//   48   If pptype is non-NULL, this function also returns the partition type.
//   49   If psize is non-NULL, this function also returns the partition size.
//   50 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function DFS_GetPtnStart
        THUMB
//   51 u32 DFS_GetPtnStart(u8 unit, u8 *scratchsector, u8 pnum, u8 *pactive, u8 *pptype, u32 *psize)
//   52 {
DFS_GetPtnStart:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        LDR      R5,[SP, #+24]
        LDR      R6,[SP, #+28]
        MOVS     R4,R3
        MOV      R8,R1
        MOVS     R7,R2
//   53   u32 result;
//   54   PMBR mbr = (PMBR) scratchsector;
//   55 
//   56   // DOS ptable supports maximum 4 partitions
//   57   if (pnum > 3)
        CMP      R7,#+4
        BCC.N    ??DFS_GetPtnStart_0
//   58     return DFS_ERRMISC;
        MOVS     R0,#-1
        B.N      ??DFS_GetPtnStart_1
//   59 
//   60   // Read MBR from target media
//   61   if (DFS_ReadSector(unit,scratchsector,0,1)) {
??DFS_GetPtnStart_0:
        MOVS     R2,#+512
        MOVS     R1,#+0
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        ADDS     R0,R8,R7, LSL #+4
        ADDS     R1,R0,#+446
        LDRB     R2,[R1, #+9]
        LDRB     R0,[R1, #+8]
        ORRS     R0,R0,R2, LSL #+8
        LDRB     R2,[R1, #+10]
        ORRS     R0,R0,R2, LSL #+16
        LDRB     R2,[R1, #+11]
        ORRS     R0,R0,R2, LSL #+24
//   62     return DFS_ERRMISC;
//   63   }
//   64 
//   65   result = (u32) mbr->ptable[pnum].start_0 |
//   66     (((u32) mbr->ptable[pnum].start_1) << 8) |
//   67     (((u32) mbr->ptable[pnum].start_2) << 16) |
//   68     (((u32) mbr->ptable[pnum].start_3) << 24);
//   69 
//   70   if (pactive)
        CBZ      R4,??DFS_GetPtnStart_2
//   71     *pactive = mbr->ptable[pnum].active;
        LDRB     R2,[R1, #+0]
        STRB     R2,[R4, #+0]
//   72 
//   73   if (pptype)
??DFS_GetPtnStart_2:
        CBZ      R5,??DFS_GetPtnStart_3
//   74     *pptype = mbr->ptable[pnum].type;
        LDRB     R2,[R1, #+4]
        STRB     R2,[R5, #+0]
//   75 
//   76   if (psize)
??DFS_GetPtnStart_3:
        CBZ      R6,??DFS_GetPtnStart_1
//   77     *psize = (u32) mbr->ptable[pnum].size_0 |
//   78       (((u32) mbr->ptable[pnum].size_1) << 8) |
//   79       (((u32) mbr->ptable[pnum].size_2) << 16) |
//   80       (((u32) mbr->ptable[pnum].size_3) << 24);
        LDRB     R3,[R1, #+13]
        LDRB     R2,[R1, #+12]
        ORRS     R2,R2,R3, LSL #+8
        LDRB     R3,[R1, #+14]
        LDRB     R1,[R1, #+15]
        ORRS     R2,R2,R3, LSL #+16
        ORRS     R1,R2,R1, LSL #+24
        STR      R1,[R6, #+0]
//   81 
//   82   return result;
??DFS_GetPtnStart_1:
        POP      {R4-R8,PC}       ;; return
        CFI EndBlock cfiBlock2
//   83 }
//   84 
//   85 
//   86 /*
//   87   Retrieve volume info from BPB and store it in a VOLINFO structure
//   88   You must provide the unit and starting sector of the filesystem, and
//   89   a pointer to a sector buffer for scratch
//   90   Attempts to read BPB and glean information about the FS from that.
//   91   Returns 0 OK, nonzero for any error.
//   92 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function DFS_GetVolInfo
        THUMB
//   93 u32 DFS_GetVolInfo(u8 unit, u8 *scratchsector, u32 startsector, PVOLINFO volinfo)
//   94 {
DFS_GetVolInfo:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOVS     R4,R1
        MOVS     R5,R3
        MOVS     R6,R2
//   95   //u32 SectorSize;  
//   96   
//   97   PLBR lbr = (PLBR) scratchsector;
//   98   volinfo->unit = unit;
//   99   volinfo->startsector = startsector;
//  100 
//  101   if(DFS_ReadSector(0,scratchsector, startsector, 512)) return DFS_ERRMISC;
//  102   volinfo->sectorsize =(u16)lbr->bpb.bytepersec_l|(((u16)lbr->bpb.bytepersec_h)<<8);
        MOVS     R7,R4
        STRB     R0,[R5, #+0]
        STR      R6,[R5, #+16]
        MOVS     R2,#+512
        LSLS     R1,R6,#+9
        MOVS     R0,R4
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        LDRB     R0,[R7, #+11]!
        LDRB     R1,[R7, #+1]
        ORRS     R0,R0,R1, LSL #+8
        STRH     R0,[R5, #+52]
//  103 
//  104   volinfo->secperclus = lbr->bpb.secperclus;  //SecPerClus=volinfo->secperclus
        LDRB     R0,[R7, #+2]
        STRB     R0,[R5, #+20]
//  105   volinfo->reservedsecs = (u16) lbr->bpb.reserved_l |
//  106       (((u16) lbr->bpb.reserved_h) << 8);
        LDRB     R1,[R7, #+4]
        LDRB     R0,[R7, #+3]
        ORRS     R0,R0,R1, LSL #+8
        STRH     R0,[R5, #+22]
//  107 
//  108   volinfo->numsecs =  (u16) lbr->bpb.sectors_s_l |
//  109       (((u16) lbr->bpb.sectors_s_h) << 8);  
        LDRB     R1,[R7, #+9]
        LDRB     R0,[R7, #+8]
        ORRS     R0,R0,R1, LSL #+8
        STR      R0,[R5, #+24]
//  110 
//  111   if (!volinfo->numsecs)
        BNE.N    ??DFS_GetVolInfo_0
//  112     volinfo->numsecs = (u32) lbr->bpb.sectors_l_0 |
//  113       (((u32) lbr->bpb.sectors_l_1) << 8) |
//  114       (((u32) lbr->bpb.sectors_l_2) << 16) |
//  115       (((u32) lbr->bpb.sectors_l_3) << 24);
        LDRB     R1,[R7, #+22]
        LDRB     R0,[R7, #+21]
        ORRS     R0,R0,R1, LSL #+8
        LDRB     R1,[R7, #+23]
        ORRS     R0,R0,R1, LSL #+16
        LDRB     R1,[R7, #+24]
        ORRS     R0,R0,R1, LSL #+24
        STR      R0,[R5, #+24]
//  116 
//  117   // If secperfat is 0, we must be in a FAT32 volume; get secperfat
//  118   // from the FAT32 EBPB. The volume label and system ID string are also
//  119   // in different locations for FAT12/16 vs FAT32.
//  120   //FAT_SIZE
//  121   volinfo->secperfat =  (u16) lbr->bpb.secperfat_l |
//  122       (((u16) lbr->bpb.secperfat_h) << 8);    
??DFS_GetVolInfo_0:
        LDRB     R1,[R7, #+12]
        LDRB     R0,[R7, #+11]
        ORRS     R0,R0,R1, LSL #+8
        STR      R0,[R5, #+28]
//  123 
//  124   if (!volinfo->secperfat) 
        BNE.N    ??DFS_GetVolInfo_1
//  125   {
//  126     volinfo->secperfat = (u32) lbr->ebpb.ebpb32.fatsize_0 |
//  127       (((u32) lbr->ebpb.ebpb32.fatsize_1) << 8) |
//  128       (((u32) lbr->ebpb.ebpb32.fatsize_2) << 16) |
//  129       (((u32) lbr->ebpb.ebpb32.fatsize_3) << 24);
        LDRB     R1,[R7, #+26]
        LDRB     R0,[R7, #+25]
//  130 
//  131     memcpy(volinfo->label, lbr->ebpb.ebpb32.label, 11);
        MOVS     R2,#+11
        ORRS     R0,R0,R1, LSL #+8
        LDRB     R1,[R7, #+27]
        ORRS     R0,R0,R1, LSL #+16
        LDRB     R1,[R7, #+28]
        ORRS     R0,R0,R1, LSL #+24
        STR      R0,[R5, #+28]
        MOVS     R1,R4
        ADDS     R1,R1,#+71
        B.N      ??DFS_GetVolInfo_2
//  132     volinfo->label[11] = 0;
//  133   
//  134 // tag: OEMID, refer dosfs.h
//  135 //    memcpy(volinfo->system, lbr->ebpb.ebpb32.system, 8);
//  136 //    volinfo->system[8] = 0; 
//  137   }
//  138   else 
//  139   {
//  140     memcpy(volinfo->label, lbr->ebpb.ebpb.label, 11);
??DFS_GetVolInfo_1:
        MOVS     R2,#+11
        MOVS     R1,R4
        ADDS     R1,R1,#+43
??DFS_GetVolInfo_2:
        ADDS     R0,R5,#+2
        _BLF     memcpy,??memcpy??rT
//  141     volinfo->label[11] = 0;
        MOVS     R0,#+0
        STRB     R0,[R5, #+13]
//  142   
//  143 // tag: OEMID, refer dosfs.h
//  144 //    memcpy(volinfo->system, lbr->ebpb.ebpb.system, 8);
//  145 //    volinfo->system[8] = 0; 
//  146   }
//  147 
//  148   // note: if rootentries is 0, we must be in a FAT32 volume.
//  149   volinfo->rootentries =  (u16) lbr->bpb.rootentries_l |
//  150       (((u16) lbr->bpb.rootentries_h) << 8);
        LDRB     R1,[R7, #+7]
        LDRB     R0,[R7, #+6]
        ORRS     R0,R0,R1, LSL #+8
        STRH     R0,[R5, #+32]
//  151 
//  152   // after extracting raw info we perform some useful precalculations
//  153   volinfo->fat1 = (startsector + volinfo->reservedsecs)*(volinfo->sectorsize/SECTOR_SIZE);    //???
        LDRH     R1,[R5, #+52]
        LDRH     R2,[R5, #+22]
        LSRS     R1,R1,#+9
        ADDS     R2,R6,R2
        MULS     R2,R1,R2
        STR      R2,[R5, #+40]
//  154 
//  155   // The calculation below is designed to round up the root directory size for FAT12/16
//  156   // and to simply ignore the root directory for FAT32, since it's a normal, expandable
//  157   // file in that situation.
//  158   if (volinfo->rootentries) 
        CBZ      R0,??DFS_GetVolInfo_3
//  159   {
//  160     volinfo->rootdir = volinfo->fat1 + (volinfo->secperfat * 2)*(volinfo->sectorsize/SECTOR_SIZE);//+ (SectorSize - 1))
        LDR      R3,[R5, #+28]
//  161     volinfo->dataarea = volinfo->rootdir+ ((volinfo->rootentries * 32)/SECTOR_SIZE);//
        LSLS     R0,R0,#+5
        MULS     R3,R1,R3
        ADDS     R1,R2,R3, LSL #+1
        ASRS     R2,R0,#+8
        ADDS     R0,R0,R2, LSR #+23
        ADDS     R0,R1,R0, ASR #+9
        STR      R0,[R5, #+48]
        B.N      ??DFS_GetVolInfo_4
//  162   }
//  163   else 
//  164   {
//  165     volinfo->dataarea = volinfo->fat1 + (volinfo->secperfat * 2*(volinfo->sectorsize/SECTOR_SIZE));//SectorSize
??DFS_GetVolInfo_3:
        LDR      R0,[R5, #+28]
        MULS     R0,R1,R0
        ADDS     R0,R2,R0, LSL #+1
        STR      R0,[R5, #+48]
//  166     volinfo->rootdir = (u32) lbr->ebpb.ebpb32.root_0 |
//  167       (((u32) lbr->ebpb.ebpb32.root_1) << 8) |
//  168       (((u32) lbr->ebpb.ebpb32.root_2) << 16) |
//  169       (((u32) lbr->ebpb.ebpb32.root_3) << 24);
        LDRB     R0,[R4, #+44]!
        LDRB     R1,[R4, #+1]
        ORRS     R0,R0,R1, LSL #+8
        LDRB     R1,[R4, #+2]
        ORRS     R0,R0,R1, LSL #+16
        LDRB     R1,[R4, #+3]
        ORRS     R1,R0,R1, LSL #+24
??DFS_GetVolInfo_4:
        STR      R1,[R5, #+44]
//  170   }
//  171 //DirSecNum = (volinfo->rootentries * 32)/volinfo->sectorsize ;
//  172 //Root_Addr=volinfo->fat1 + (volinfo->secperfat * 2)*SectorSize;
//  173 // Calculate number of clusters in data area and infer FAT type from this information.
//  174   volinfo->numclusters = (volinfo->numsecs - volinfo->dataarea) / volinfo->secperclus;
        LDR      R0,[R5, #+24]
        LDR      R1,[R5, #+48]
        SUBS     R0,R0,R1
        LDRB     R1,[R5, #+20]
        UDIV     R0,R0,R1
//  175   if (volinfo->numclusters < 4085)
        LDR.N    R1,??DFS_GetVolInfo_5  ;; 0xff5
        STR      R0,[R5, #+36]
        CMP      R0,R1
        BCS.N    ??DFS_GetVolInfo_6
//  176     volinfo->filesystem = FAT12;
        MOVS     R0,#+0
        B.N      ??DFS_GetVolInfo_7
//  177   else if (volinfo->numclusters < 65525)
??DFS_GetVolInfo_6:
        LDR.N    R1,??DFS_GetVolInfo_5+0x4  ;; 0xfff5
        CMP      R0,R1
        ITE     CS 
        MOVCS    R0,#+2
//  178     volinfo->filesystem = FAT16;
        MOVCC    R0,#+1
??DFS_GetVolInfo_7:
        STRB     R0,[R5, #+1]
//  179   else
//  180     volinfo->filesystem = FAT32;
//  181 
//  182   return DFS_OK;
        MOVS     R0,#+0
        POP      {R4-R7,PC}
        Nop      
        DATA
??DFS_GetVolInfo_5:
        DC32     0xff5
        DC32     0xfff5
        CFI EndBlock cfiBlock3
//  183 }
//  184 
//  185 /*
//  186   Fetch FAT entry for specified cluster number
//  187   You must provide a scratch buffer for one sector (SECTOR_SIZE) and a populated VOLINFO
//  188   Returns a FAT32 BAD_CLUSTER value for any error, otherwise the contents of the desired
//  189   FAT entry.
//  190   scratchcache should point to a UINT32. This variable caches the physical sector number
//  191   last read into the scratch buffer for performance enhancement reasons.
//  192 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function DFS_GetFAT
        THUMB
//  193 u32 DFS_GetFAT(PVOLINFO volinfo,u8 *scratch,u32 *scratchcache, u32 cluster)//
//  194 {
DFS_GetFAT:
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+8
        CFI CFA R13+40
        MOVS     R4,R1
//  195   u32 offset, sector, result;
//  196 
//  197   
//  198   if (volinfo->filesystem == FAT12) {
        LDR.N    R1,??DataTable0  ;; 0xffffff7
        MOV      R8,R0
        LDRB     R0,[R8, #+1]
        MOV      R9,R2
        MOVS     R5,R3
        MOV      R10,R1
        CMP      R0,#+0
        BNE.N    ??DFS_GetFAT_0
//  199     offset = cluster + (cluster / 2);
        ADDS     R7,R5,R5, LSR #+1
//  200   }
//  201   else if (volinfo->filesystem == FAT16) {
//  202     offset = cluster * 2;
//  203   }
//  204   else if (volinfo->filesystem == FAT32) {
//  205     offset = cluster * 4;
//  206   }
//  207   else
//  208     return 0x0ffffff7;  // FAT32 bad cluster  
//  209 
//  210   // at this point, offset is the BYTE offset of the desired sector from the start
//  211   // of the FAT. Calculate the physical sector containing this FAT entry.
//  212   sector = ldiv(offset, SECTOR_SIZE).quot + volinfo->fat1;
??DFS_GetFAT_1:
        MOVS     R2,#+512
        MOVS     R1,R7
        MOV      R0,SP
        _BLF     ldiv,??ldiv??rT
        LDR      R1,[R8, #+40]
        LDR      R0,[SP, #+0]
        ADDS     R6,R0,R1
//  213 
//  214   // If this is not the same sector we last read, then read it into RAM  
//  215   if (sector != *scratchcache) {
        LDR      R0,[R9, #+0]
        CMP      R6,R0
        BEQ.N    ??DFS_GetFAT_2
//  216     if(DFS_ReadSector(volinfo->unit, scratch, sector, 1)) {
        MOVS     R2,#+512
        LSLS     R1,R6,#+9
        MOVS     R0,R4
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  217       // avoid anyone assuming that this cache value is still valid, which
//  218       // might cause disk corruption
//  219       *scratchcache = 0;
//  220       return 0x0ffffff7;  // FAT32 bad cluster  
//  221     }
//  222     *scratchcache = sector;
        STR      R6,[R9, #+0]
//  223   }
//  224 
//  225   // At this point, we "merely" need to extract the relevant entry.
//  226   // This is easy for FAT16 and FAT32, but a royal PITA for FAT12 as a single entry
//  227   // may span a sector boundary. The normal way around this is always to read two
//  228   // FAT sectors, but that luxury is (by design intent) unavailable to DOSFS.
//  229   offset = ldiv(offset, SECTOR_SIZE).rem;
??DFS_GetFAT_2:
        MOVS     R2,#+512
        MOVS     R1,R7
        MOV      R0,SP
        _BLF     ldiv,??ldiv??rT
//  230 
//  231   if (volinfo->filesystem == FAT12) {
        LDRB     R1,[R8, #+1]
        LDR      R0,[SP, #+4]
        CMP      R1,#+0
        BNE.N    ??DFS_GetFAT_3
//  232     // Special case for sector boundary - Store last byte of current sector.
//  233     // Then read in the next sector and put the first byte of that sector into
//  234     // the high byte of result.
//  235     if (offset == SECTOR_SIZE - 1) {
        LDR.N    R1,??DataTable2  ;; 0x1ff
        CMP      R0,R1
        BNE.N    ??DFS_GetFAT_4
//  236       result = (u32) scratch[offset];
        LDRB     R7,[R4, #+511]
//  237       sector++;
        ADDS     R6,R6,#+1
//  238       if(DFS_ReadSector(volinfo->unit, scratch, sector, 1)) {
        ADDS     R2,R1,#+1
        LSLS     R1,R6,#+9
        MOVS     R0,R4
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  239         // avoid anyone assuming that this cache value is still valid, which
//  240         // might cause disk corruption
//  241         *scratchcache = 0;
//  242         return 0x0ffffff7;  // FAT32 bad cluster  
//  243       }
//  244       *scratchcache = sector;
        STR      R6,[R9, #+0]
//  245       // Thanks to Claudio Leonel for pointing out this missing line.
//  246       if(cluster & 1)
        LSLS     R0,R5,#+31
        BPL.N    ??DFS_GetFAT_5
//  247       {
//  248 //        result = ((result & 0xf0)>>4) | (((u32)scratch[0]) << 8);
//  249         result = ((result & 0xf0)>>4) | (((u32)scratch[0]) << 4);
        LDRB     R1,[R4, #+0]
        ANDS     R0,R7,#0xF0
        LSLS     R1,R1,#+4
        ORRS     R0,R1,R0, LSR #+4
        B.N      ??DFS_GetFAT_6
//  250       }
??DFS_GetFAT_0:
        CMP      R0,#+1
        BNE.N    ??DFS_GetFAT_7
        LSLS     R7,R5,#+1
        B.N      ??DFS_GetFAT_1
??DFS_GetFAT_7:
        CMP      R0,#+2
        BNE.N    ??DFS_GetFAT_8
        LSLS     R7,R5,#+2
        B.N      ??DFS_GetFAT_1
//  251       else
//  252       {
//  253         result = result |(((u32)scratch[0] & 0xf)<<8);
??DFS_GetFAT_5:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+28
        LSRS     R0,R0,#+28
        ORRS     R0,R7,R0, LSL #+8
        B.N      ??DFS_GetFAT_6
//  254       }
//  255     }
//  256     else {
//  257       if (cluster & 1)
??DFS_GetFAT_4:
        ADDS     R0,R4,R0
        LSLS     R1,R5,#+31
        LDRB     R1,[R0, #+0]
        LDRB     R0,[R0, #+1]
        BPL.N    ??DFS_GetFAT_9
//  258 //        result = (((u32) scratch[offset] & 0xf0)>>4) |((u32)scratch[offset+1] <<8);
//  259         result = (((u32) scratch[offset] & 0xf0)>>4) |((u32)scratch[offset+1] <<4);
        LSLS     R0,R0,#+4
        ORRS     R0,R0,R1, LSR #+4
        B.N      ??DFS_GetFAT_6
//  260       else
//  261         result = (u32)scratch[offset] | (((u32)scratch[offset+1] & 0x0f) << 8);
??DFS_GetFAT_9:
        LSLS     R0,R0,#+28
        LSRS     R0,R0,#+28
        ORRS     R0,R1,R0, LSL #+8
        B.N      ??DFS_GetFAT_6
//  262     }
//  263     
//  264   }
//  265   else if (volinfo->filesystem == FAT16) {
??DFS_GetFAT_3:
        ADDS     R0,R4,R0
        CMP      R1,#+1
        BNE.N    ??DFS_GetFAT_10
//  266     result = (u32) scratch[offset] |
//  267       ((u32) scratch[offset+1]) << 8;
        LDRB     R1,[R0, #+0]
        LDRB     R0,[R0, #+1]
        ORRS     R0,R1,R0, LSL #+8
        B.N      ??DFS_GetFAT_6
//  268   }
//  269   else if (volinfo->filesystem == FAT32) {
??DFS_GetFAT_10:
        CMP      R1,#+2
        BNE.N    ??DFS_GetFAT_8
//  270     result = ((u32) scratch[offset] |
//  271       ((u32) scratch[offset+1]) << 8 |
//  272       ((u32) scratch[offset+2]) << 16 |
//  273       ((u32) scratch[offset+3]) << 24) & 0x0fffffff;
        LDRB     R2,[R0, #+1]
        LDRB     R1,[R0, #+0]
        ORRS     R1,R1,R2, LSL #+8
        LDRB     R2,[R0, #+2]
        LDRB     R0,[R0, #+3]
        ORRS     R1,R1,R2, LSL #+16
        ORRS     R0,R1,R0, LSL #+24
        LSLS     R0,R0,#+4
        LSRS     R0,R0,#+4
        B.N      ??DFS_GetFAT_6
//  274   }
//  275   else
//  276     result = 0x0ffffff7;  // FAT32 bad cluster  
??DFS_GetFAT_8:
        MOV      R0,R10
//  277   return result;
??DFS_GetFAT_6:
        ADD      SP,SP,#+8
        CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
        CFI EndBlock cfiBlock4
//  278 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable0:
        DC32     0xffffff7
//  279 
//  280 
//  281 /*
//  282   Set FAT entry for specified cluster number
//  283   You must provide a scratch buffer for one sector (SECTOR_SIZE) and a populated VOLINFO
//  284   Returns DFS_ERRMISC for any error, otherwise DFS_OK
//  285   scratchcache should point to a UINT32. This variable caches the physical sector number
//  286   last read into the scratch buffer for performance enhancement reasons.
//  287 
//  288   NOTE: This code is HIGHLY WRITE-INEFFICIENT, particularly for flash media. Considerable
//  289   performance gains can be realized by caching the sector. However this is difficult to
//  290   achieve on FAT12 without requiring 2 sector buffers of scratch space, and it is a design
//  291   requirement of this code to operate on a single 512-byte scratch.
//  292 
//  293   If you are operating DOSFS over flash, you are strongly advised to implement a writeback
//  294   cache in your physical I/O driver. This will speed up your code significantly and will
//  295   also conserve power and flash write life.
//  296 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function DFS_SetFAT
        THUMB
//  297 u32 DFS_SetFAT(PVOLINFO volinfo, u8 *scratch, u32 *scratchcache, u32 cluster, u32 new_contents)
//  298 {
DFS_SetFAT:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+16
        CFI CFA R13+52
        LDR      R7,[SP, #+52]
        MOVS     R4,R1
        MOV      R8,R0
//  299   u32 offset, result,sector=0;
//  300 
//  301 
//  302   if (volinfo->filesystem == FAT12) {
        LDRB     R0,[R8, #+1]
        MOVS     R5,R2
        MOVS     R6,R3
        CMP      R0,#+0
        BNE.N    ??DFS_SetFAT_0
//  303     offset = cluster + (cluster / 2);
        ADDS     R9,R6,R6, LSR #+1
//  304     new_contents &=0xfff;
        LSLS     R7,R7,#+20
        LSRS     R7,R7,#+20
//  305   }
//  306   else if (volinfo->filesystem == FAT16) {
//  307     offset = cluster * 2;
//  308     new_contents &=0xffff;
//  309   }
//  310   else if (volinfo->filesystem == FAT32) {
//  311     offset = cluster * 4;
//  312     new_contents &=0x0fffffff;  // FAT32 is really "FAT28"
//  313   }
//  314   else
//  315     return DFS_ERRMISC;  
//  316 
//  317   // at this point, offset is the BYTE offset of the desired sector from the start
//  318   // of the FAT. Calculate the physical sector containing this FAT entry.
//  319   sector = ldiv(offset, SECTOR_SIZE).quot + volinfo->fat1;
??DFS_SetFAT_1:
        MOVS     R2,#+512
        MOV      R1,R9
        ADD      R0,SP,#+8
        _BLF     ldiv,??ldiv??rT
        LDR      R1,[R8, #+40]
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R1
        MOV      R11,R0
//  320   
//  321   // If this is not the same sector we last read, then read it into RAM
//  322   if (sector != *scratchcache) {
        LDR      R0,[R5, #+0]
        CMP      R11,R0
        BEQ.N    ??DFS_SetFAT_2
//  323     if(DFS_ReadSector(volinfo->unit, scratch, sector, 1)) {
        MOVS     R2,#+512
        MOV      R0,R11
        LSLS     R1,R0,#+9
        MOVS     R0,R4
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  324       // avoid anyone assuming that this cache value is still valid, which
//  325       // might cause disk corruption
//  326       *scratchcache = 0;
//  327       return DFS_ERRMISC;
//  328     }
//  329     *scratchcache = sector;
        STR      R11,[R5, #+0]
//  330   }
//  331 
//  332   // At this point, we "merely" need to extract the relevant entry.
//  333   // This is easy for FAT16 and FAT32, but a royal PITA for FAT12 as a single entry
//  334   // may span a sector boundary. The normal way around this is always to read two
//  335   // FAT sectors, but that luxury is (by design intent) unavailable to DOSFS.
//  336   offset = ldiv(offset, SECTOR_SIZE).rem;
??DFS_SetFAT_2:
        MOVS     R2,#+512
        MOV      R1,R9
        ADD      R0,SP,#+8
        _BLF     ldiv,??ldiv??rT
//  337 
//  338   if (volinfo->filesystem == FAT12) {
        LDRB     R1,[R8, #+1]
        LDR      R0,[SP, #+12]
        ADDW     R10,R4,#+256
        CMP      R1,#+0
        BNE.W    ??DFS_SetFAT_3
//  339 
//  340     // If this is an odd cluster, pre-shift the desired new contents 4 bits to
//  341     // make the calculations below simpler
//  342     if (cluster & 1)
        LSLS     R1,R6,#+31
        IT      MI 
//  343       new_contents = new_contents << 4;
        LSLMI    R7,R7,#+4
//  344 
//  345     // Special case for sector boundary
//  346     if (offset == SECTOR_SIZE - 1) {
        LDR.N    R2,??DataTable2  ;; 0x1ff
        ANDS     R1,R7,#0xF00
        LSRS     R1,R1,#+8
        STRB     R1,[SP, #+0]
        ANDS     R1,R7,#0xF0
        CMP      R0,R2
        BNE.N    ??DFS_SetFAT_4
//  347 
//  348       // Odd cluster: High 12 bits being set
//  349       if (cluster & 1) {
        ADDW     R0,R4,#+511
        LSLS     R2,R6,#+31
        BPL.N    ??DFS_SetFAT_5
//  350         scratch[offset] = (scratch[offset] & 0x0f) | new_contents & 0xf0;
        LDRB     R2,[R0, #+0]
        LSLS     R2,R2,#+28
        LSRS     R2,R2,#+28
        ORRS     R1,R1,R2
        STRB     R1,[R0, #+0]
        B.N      ??DFS_SetFAT_6
//  351       }
??DFS_SetFAT_0:
        CMP      R0,#+1
        BNE.N    ??DFS_SetFAT_7
        LSLS     R0,R6,#+1
        MOV      R9,R0
        UXTH     R7,R7
        B.N      ??DFS_SetFAT_1
??DFS_SetFAT_7:
        CMP      R0,#+2
        BNE.N    ??DFS_SetFAT_8
        LSLS     R0,R6,#+2
        MOV      R9,R0
        LSLS     R7,R7,#+4
        LSRS     R7,R7,#+4
        B.N      ??DFS_SetFAT_1
??DFS_SetFAT_8:
        MOVS     R0,#-1
        B.N      ??DFS_SetFAT_9
//  352       // Even cluster: Low 12 bits being set
//  353       else {
//  354         scratch[offset] = new_contents & 0xff;
??DFS_SetFAT_5:
        STRB     R7,[R0, #+0]
//  355       }
//  356       result = DFS_WriteSector(volinfo->unit, scratch, *scratchcache, 1);//
??DFS_SetFAT_6:
        LDR      R0,[R5, #+0]
        LSLS     R0,R0,#+9
        MOV      R9,R0
        MOV      R1,R9
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R9,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  357       // mirror the FAT into copy 2
//  358       if (DFS_OK == result)
//  359         result = DFS_WriteSector(volinfo->unit, scratch, (*scratchcache)+volinfo->secperfat, 1);
        LDR      R1,[R8, #+28]
        MOVS     R0,#+0
        MOV      R9,R0
        LDR      R0,[R5, #+0]
        ADDS     R0,R0,R1
        LSLS     R0,R0,#+9
        STR      R0,[SP, #+4]
        LDR      R1,[SP, #+4]
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[SP, #+4]
        ADDW     R1,R0,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  360 
//  361       // If we wrote that sector OK, then read in the subsequent sector
//  362       // and poke the first byte with the remainder of this FAT entry.
//  363       if (DFS_OK == result) 
//  364       {
//  365         sector++;
//  366         *scratchcache=sector;
        MOV      R0,R11
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+0]
//  367         result = DFS_ReadSector(volinfo->unit, scratch, *scratchcache, 1);
        MOVS     R2,#+512
        LSLS     R1,R0,#+9
        MOVS     R0,R4
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  368         if (DFS_OK == result) {
//  369           // Odd cluster: High 12 bits being set
//  370           if (cluster & 1) {
        LSLS     R0,R6,#+31
        BPL.N    ??DFS_SetFAT_10
//  371             scratch[0] = (new_contents & 0xff00)>>8;
        LSRS     R0,R7,#+8
        STRB     R0,[R4, #+0]
        B.N      ??DFS_SetFAT_11
//  372           }
//  373           // Even cluster: Low 12 bits being set
//  374           else {
//  375             scratch[0] = (scratch[0] & 0xf0) | ((new_contents & 0x0f00)>>8);
??DFS_SetFAT_10:
        LDRB     R0,[R4, #+0]
        LDRB     R1,[SP, #+0]
        ANDS     R0,R0,#0xF0
        ORRS     R1,R1,R0
        STRB     R1,[R4, #+0]
//  376           }
//  377           result = DFS_WriteSector(volinfo->unit, scratch, *scratchcache, 1);
??DFS_SetFAT_11:
        LDR      R0,[R5, #+0]
        LSLS     R6,R0,#+9
        MOVS     R1,R6
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R6,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  378           // mirror the FAT into copy 2
//  379           if (DFS_OK == result)
//  380             result = DFS_WriteSector(volinfo->unit, scratch, (*scratchcache)+volinfo->secperfat, 1);
        LDR      R0,[R5, #+0]
        LDR      R1,[R8, #+28]
        ADDS     R0,R0,R1
        LSLS     R5,R0,#+9
        MOVS     R1,R5
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R5,#+256
??DFS_SetFAT_12:
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        B.N      ??DFS_SetFAT_13
//  381         }
//  382         else {
//  383           // avoid anyone assuming that this cache value is still valid, which
//  384           // might cause disk corruption
//  385           *scratchcache = 0;
//  386         }
//  387       }
//  388     } // if (offset == SECTOR_SIZE - 1)
//  389 
//  390     // Not a sector boundary. But we still have to worry about if it's an odd
//  391     // or even cluster number.
//  392     else {
//  393       // Odd cluster: High 12 bits being set
//  394       if (cluster & 1) {
??DFS_SetFAT_4:
        ADDS     R0,R4,R0
        LSLS     R2,R6,#+31
        BPL.N    ??DFS_SetFAT_14
//  395         scratch[offset] = (scratch[offset] & 0x0f) | new_contents & 0xf0;
        LDRB     R2,[R0, #+0]
        LSLS     R2,R2,#+28
        LSRS     R2,R2,#+28
        ORRS     R1,R1,R2
        STRB     R1,[R0, #+0]
//  396         scratch[offset+1] = (new_contents & 0xff00)>>8;
        LSRS     R1,R7,#+8
        STRB     R1,[R0, #+1]
        B.N      ??DFS_SetFAT_15
//  397       }
//  398       // Even cluster: Low 12 bits being set
//  399       else 
//  400       {
//  401           scratch[offset] = new_contents & 0xff;
??DFS_SetFAT_14:
        STRB     R7,[R0, #+0]
//  402           scratch[offset+1] = (scratch[offset+1] & 0xf0) | ((new_contents & 0x0f00)>>8);
        LDRB     R1,[R0, #+1]
        LDRB     R2,[SP, #+0]
        ANDS     R1,R1,#0xF0
        ORRS     R2,R2,R1
        STRB     R2,[R0, #+1]
//  403       }
//  404       result = DFS_WriteSector(volinfo->unit, scratch, *scratchcache, 1);
??DFS_SetFAT_15:
        LDR      R0,[R5, #+0]
        LSLS     R6,R0,#+9
        MOVS     R1,R6
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R6,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  405       // mirror the FAT into copy 2
//  406       if (DFS_OK == result)
//  407         result = DFS_WriteSector(volinfo->unit, scratch, (*scratchcache)+volinfo->secperfat, 1);
        LDR      R1,[R8, #+28]
        MOVS     R0,#+0
        MOV      R9,R0
        LDR      R0,[R5, #+0]
        ADDS     R0,R0,R1
        LSLS     R5,R0,#+9
        MOVS     R1,R5
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R5,#+256
        B.N      ??DFS_SetFAT_12
//  408     }
//  409   }
??DFS_SetFAT_3:
        LSRS     R2,R7,#+8
        ADDS     R0,R4,R0
        CMP      R1,#+1
        BNE.N    ??DFS_SetFAT_16
//  410   else if (volinfo->filesystem == FAT16) {
//  411     
//  412     scratch[offset] = (new_contents & 0xff);
        STRB     R7,[R0, #+0]
//  413     scratch[offset+1] = (new_contents & 0xff00) >> 8;
        STRB     R2,[R0, #+1]
//  414     result = DFS_WriteSector(volinfo->unit, scratch, *scratchcache, 1);//volinfo->secperfat
        LDR      R0,[R5, #+0]
        LSLS     R6,R0,#+9
        MOVS     R1,R6
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R6,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  415     // mirror the FAT into copy 2
//  416     if (DFS_OK == result)
//  417       result = DFS_WriteSector(volinfo->unit, scratch, (*scratchcache)+volinfo->secperfat, 1);//
        LDR      R1,[R8, #+28]
        MOVS     R0,#+0
        MOV      R9,R0
        LDR      R0,[R5, #+0]
        ADDS     R0,R0,R1
        LSLS     R5,R0,#+9
        MOVS     R1,R5
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R5,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        B.N      ??DFS_SetFAT_13
//  418   }
//  419   else if (volinfo->filesystem == FAT32) {
??DFS_SetFAT_16:
        CMP      R1,#+2
        BNE.N    ??DFS_SetFAT_17
//  420     scratch[offset] = (new_contents & 0xff);
        STRB     R7,[R0, #+0]
//  421     scratch[offset+1] = (new_contents & 0xff00) >> 8;
        STRB     R2,[R0, #+1]
//  422     scratch[offset+2] = (new_contents & 0xff0000) >> 16;
        LSRS     R1,R7,#+16
        STRB     R1,[R0, #+2]
//  423     scratch[offset+3] = (scratch[offset+3] & 0xf0) | ((new_contents & 0x0f000000) >> 24);
        LDRB     R1,[R0, #+3]
        ANDS     R2,R7,#0xF000000
        LSRS     R2,R2,#+24
        ANDS     R1,R1,#0xF0
        ORRS     R2,R2,R1
        STRB     R2,[R0, #+3]
//  424     // Note well from the above: Per Microsoft's guidelines we preserve the upper
//  425     // 4 bits of the FAT32 cluster value. It's unclear what these bits will be used
//  426     // for; in every example I've encountered they are always zero.
//  427     result = DFS_WriteSector(volinfo->unit, scratch, *scratchcache, 1);
        LDR      R0,[R5, #+0]
        LSLS     R6,R0,#+9
        MOVS     R1,R6
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R6,#+256
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  428     // mirror the FAT into copy 2
//  429     if (DFS_OK == result)
//  430       result = DFS_WriteSector(volinfo->unit, scratch, (*scratchcache)+volinfo->secperfat, 1);
        LDR      R1,[R8, #+28]
        MOVS     R0,#+0
        MOV      R9,R0
        LDR      R0,[R5, #+0]
        ADDS     R0,R0,R1
        LSLS     R5,R0,#+9
        MOVS     R1,R5
        MOVS     R0,R4
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R5,#+256
        B.N      ??DFS_SetFAT_12
//  431   }
//  432   else
//  433     result = DFS_ERRMISC;
??DFS_SetFAT_17:
        MOVS     R0,#-1
        MOV      R9,R0
//  434 
//  435   return result;
??DFS_SetFAT_13:
        MOV      R0,R9
??DFS_SetFAT_9:
        ADD      SP,SP,#+16
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock5
//  436 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable2:
        DC32     0x1ff
//  437 
//  438 /*
//  439   Convert a filename element from canonical (8.3) to directory entry (11) form
//  440   src must point to the first non-separator character.
//  441   dest must point to a 12-byte buffer.
//  442 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function DFS_CanonicalToDir
        THUMB
//  443 u8 *DFS_CanonicalToDir(u8 *dest, u8 *src)
//  444 {
DFS_CanonicalToDir:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  445   u8 *destptr = dest;
//  446 
//  447   memset(dest, ' ', 11);
        MOVS     R2,#+11
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R4
        MOVS     R1,#+32
        _BLF     memset,??memset??rT
//  448   dest[11] = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+11]
        B.N      ??DFS_CanonicalToDir_0
//  449 
//  450   while (*src && (*src != DIR_SEPARATOR) && (destptr - dest < 11)) {
//  451     if (*src >= 'a' && *src <='z') {
??DFS_CanonicalToDir_1:
        CMP      R0,#+123
        BCS.N    ??DFS_CanonicalToDir_2
//  452       *destptr++ = (*src - 'a') + 'A';
        ADDS     R0,R0,#+224
        STRB     R0,[R6], #+1
//  453       src++;
??DFS_CanonicalToDir_3:
        ADDS     R5,R5,#+1
//  454     }
??DFS_CanonicalToDir_0:
        LDRB     R0,[R5, #+0]
        CBZ      R0,??DFS_CanonicalToDir_4
        CMP      R0,#+47
        BEQ.N    ??DFS_CanonicalToDir_4
        SUBS     R1,R6,R4
        CMP      R1,#+11
        BGE.N    ??DFS_CanonicalToDir_4
        CMP      R0,#+97
        BCS.N    ??DFS_CanonicalToDir_1
//  455     else if (*src == '.') {
        CMP      R0,#+46
        BNE.N    ??DFS_CanonicalToDir_2
//  456       src++;
        ADDS     R5,R5,#+1
//  457       destptr = dest + 8;
        MOVS     R6,R4
        ADDS     R6,R6,#+8
        B.N      ??DFS_CanonicalToDir_0
//  458     }
//  459     else {
//  460       *destptr++ = *src++;
??DFS_CanonicalToDir_2:
        STRB     R0,[R6], #+1
        B.N      ??DFS_CanonicalToDir_3
//  461     }
//  462   }
//  463 
//  464   return dest;
??DFS_CanonicalToDir_4:
        MOVS     R0,R4
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock6
//  465 }
//  466 
//  467 /*
//  468   Find the first unused FAT entry
//  469   You must provide a scratch buffer for one sector (SECTOR_SIZE) and a populated VOLINFO
//  470   Returns a FAT32 BAD_CLUSTER value for any error, otherwise the contents of the desired
//  471   FAT entry.
//  472   Returns FAT32 bad_sector (0x0ffffff7) if there is no free cluster available
//  473 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function DFS_GetFreeFAT
        THUMB
//  474 u32 DFS_GetFreeFAT(PVOLINFO volinfo, u8 *scratch)
//  475 {
DFS_GetFreeFAT:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+4
        CFI CFA R13+20
        MOVS     R4,R0
        MOVS     R5,R1
//  476   u32 i, result = 0xffffffff, scratchcache = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
//  477   
//  478   // Search starts at cluster 2, which is the first usable cluster
//  479   // NOTE: This search can't terminate at a bad cluster, because there might
//  480   // legitimately be bad clusters on the disk.
//  481   for (i=2; i < volinfo->numclusters; i++) {
        MOVS     R6,#+2
        B.N      ??DFS_GetFreeFAT_0
??DFS_GetFreeFAT_1:
        ADDS     R6,R6,#+1
??DFS_GetFreeFAT_0:
        LDR      R0,[R4, #+36]
        CMP      R6,R0
        BCS.N    ??DFS_GetFreeFAT_2
//  482     result = DFS_GetFAT(volinfo, scratch, &scratchcache, i);
//  483     if (!result) {
        MOVS     R3,R6
        MOV      R2,SP
        MOVS     R1,R5
        MOVS     R0,R4
        BL       DFS_GetFAT
        CMP      R0,#+0
        BNE.N    ??DFS_GetFreeFAT_1
//  484       return i;
        MOVS     R0,R6
        B.N      ??DFS_GetFreeFAT_3
//  485     }
//  486   }
//  487   return 0x0ffffff7;    // Can't find a free cluster
??DFS_GetFreeFAT_2:
        LDR.N    R0,??DataTable6  ;; 0xffffff7
??DFS_GetFreeFAT_3:
        ADD      SP,SP,#+4
        CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock7
//  488 }
//  489 
//  490 
//  491 /*
//  492   Open a directory for enumeration by DFS_GetNextDirEnt
//  493   You must supply a populated VOLINFO (see DFS_GetVolInfo)
//  494   The empty string or a string containing only the directory separator are
//  495   considered to be the root directory.
//  496   Returns 0 OK, nonzero for any error.
//  497 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function DFS_OpenDir
        THUMB
//  498 u32 DFS_OpenDir(PVOLINFO volinfo, u8 *dirname, PDIRINFO dirinfo)
//  499 {
DFS_OpenDir:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        SUB      SP,SP,#+44
        CFI CFA R13+72
        MOVS     R4,R2
        MOVS     R5,R1
        MOV      R8,R0
//  500   //  char Rvalue = 2; 
//  501  
//  502   if (!strlen((char *) dirname) || (strlen((char *) dirname) == 1 && dirname[0] == DIR_SEPARATOR)) {
        MOVS     R0,#+0
        MOV      R9,R0
        MOVS     R0,R5
        _BLF     strlen,??strlen??rT
        CBZ      R0,??DFS_OpenDir_0
        MOVS     R0,R5
        _BLF     strlen,??strlen??rT
        CMP      R0,#+1
        BNE.N    ??DFS_OpenDir_1
        LDRB     R0,[R5, #+0]
        CMP      R0,#+47
        BNE.N    ??DFS_OpenDir_1
//  503     if (volinfo->filesystem == FAT32) {
??DFS_OpenDir_0:
        LDRB     R0,[R8, #+1]
        CMP      R0,#+2
        BNE.N    ??DFS_OpenDir_2
//  504       dirinfo->currentcluster = volinfo->rootdir;
        LDR      R0,[R8, #+44]
//  505       dirinfo->currentsector = 0;
//  506       dirinfo->currententry = 0;
//  507 
//  508       // read first sector of directory
//  509       return (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->dataarea + ((volinfo->rootdir - 2) * volinfo->secperclus*2), 1));
        MOVS     R2,#+512
        STR      R0,[R4, #+0]
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
        STRB     R0,[R4, #+5]
        LDR      R1,[R8, #+44]
        LDRB     R3,[R8, #+20]
        LDR      R0,[R8, #+48]
        SUBS     R1,R1,#+2
        MULS     R1,R3,R1
        ADDS     R0,R0,R1, LSL #+1
??DFS_OpenDir_3:
        LSLS     R1,R0,#+9
        LDR      R0,[R4, #+8]
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        MOV      R0,R9
        B.N      ??DFS_OpenDir_4
//  510       
//  511     }
//  512     else {
//  513       dirinfo->currentcluster = 0;
??DFS_OpenDir_2:
        STR      R9,[R4, #+0]
//  514       dirinfo->currentsector = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
//  515       dirinfo->currententry = 0;
        STRB     R0,[R4, #+5]
//  516 
//  517       // read first sector of directory
//  518       return (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->rootdir, 1));
        LDR      R0,[R8, #+44]
        MOVS     R2,#+512
        B.N      ??DFS_OpenDir_3
//  519       
//  520     }
//  521   }
//  522 
//  523   // This is not the root directory. We need to find the start of this subdirectory.
//  524   // We do this by devious means, using our own companion function DFS_GetNext.
//  525   else {
//  526     u8 tmpfn[12];
//  527     u8 *ptr = dirname;
//  528     u32 result;
//  529     DIRENT de;
//  530 
//  531     if (volinfo->filesystem == FAT32) {
??DFS_OpenDir_1:
        LDRB     R0,[R8, #+1]
        CMP      R0,#+2
        BNE.N    ??DFS_OpenDir_5
//  532       dirinfo->currentcluster = volinfo->rootdir;
        LDR      R0,[R8, #+44]
//  533       dirinfo->currentsector = 0;
//  534       dirinfo->currententry = 0;
//  535 
//  536       // read first sector of directory
//  537       if (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->dataarea + ((volinfo->rootdir - 2) * volinfo->secperclus*2), 1))
        MOVS     R2,#+512
        STR      R0,[R4, #+0]
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
        STRB     R0,[R4, #+5]
        LDR      R1,[R8, #+44]
        LDRB     R3,[R8, #+20]
        LDR      R0,[R8, #+48]
        SUBS     R1,R1,#+2
        MULS     R1,R3,R1
        ADDS     R0,R0,R1, LSL #+1
??DFS_OpenDir_6:
        LSLS     R1,R0,#+9
        LDR      R0,[R4, #+8]
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        B.N      ??DFS_OpenDir_7
//  538         return DFS_ERRMISC;
//  539     }
//  540     else {
//  541       dirinfo->currentcluster = 0;
??DFS_OpenDir_5:
        STR      R9,[R4, #+0]
//  542       dirinfo->currentsector = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
//  543       dirinfo->currententry = 0;
        STRB     R0,[R4, #+5]
//  544 
//  545       // read first sector of directory
//  546       if (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->rootdir, 1))
        LDR      R0,[R8, #+44]
        MOVS     R2,#+512
        B.N      ??DFS_OpenDir_6
//  547         return DFS_ERRMISC;
//  548     }
//  549 
//  550     // skip leading path separators
//  551     while (*ptr == DIR_SEPARATOR && *ptr)
//  552       ptr++;
??DFS_OpenDir_8:
        ADDS     R5,R5,#+1
??DFS_OpenDir_7:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+47
        BEQ.N    ??DFS_OpenDir_8
//  553 
//  554     // Scan the path from left to right, finding the start cluster of each entry
//  555     // Observe that this code is inelegant, but obviates the need for recursion.
//  556     while (*ptr) {
??DFS_OpenDir_9:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??DFS_OpenDir_10
//  557       DFS_CanonicalToDir(tmpfn, ptr);
        MOV      R7,SP
        MOVS     R2,#+11
        MOVS     R1,#+32
        MOV      R0,SP
        _BLF     memset,??memset??rT
        MOVS     R6,R5
        MOVS     R0,#+0
        STRB     R0,[SP, #+11]
        B.N      ??DFS_OpenDir_11
??DFS_OpenDir_12:
        CMP      R0,#+123
        BCS.N    ??DFS_OpenDir_13
        ADDS     R0,R0,#+224
        STRB     R0,[R7], #+1
??DFS_OpenDir_14:
        ADDS     R6,R6,#+1
??DFS_OpenDir_11:
        LDRB     R0,[R6, #+0]
        CBZ      R0,??DFS_OpenDir_15
        CMP      R0,#+47
        BEQ.N    ??DFS_OpenDir_15
        MOV      R1,SP
        SUBS     R1,R7,R1
        CMP      R1,#+11
        BGE.N    ??DFS_OpenDir_15
        CMP      R0,#+97
        BCS.N    ??DFS_OpenDir_12
        CMP      R0,#+46
        BNE.N    ??DFS_OpenDir_13
        ADDS     R6,R6,#+1
        MOV      R7,SP
        ADDS     R7,R7,#+8
        B.N      ??DFS_OpenDir_11
??DFS_OpenDir_13:
        STRB     R0,[R7], #+1
        B.N      ??DFS_OpenDir_14
//  558 
//  559       de.name[0] = 0;
??DFS_OpenDir_15:
        MOVS     R0,#+0
        STRB     R0,[SP, #+12]
//  560 
//  561       do {
//  562         result = DFS_GetNext(volinfo, dirinfo, &de);
//  563       } while (!result && memcmp(de.name, tmpfn, 11));
??DFS_OpenDir_16:
        ADD      R2,SP,#+12
        MOVS     R1,R4
        MOV      R0,R8
        BL       DFS_GetNext
        CBNZ     R0,??DFS_OpenDir_17
        MOVS     R2,#+11
        MOV      R1,SP
        ADD      R0,SP,#+12
        _BLF     memcmp,??memcmp??rT
        CMP      R0,#+0
        BNE.N    ??DFS_OpenDir_16
//  564 
//  565       if (!memcmp(de.name, tmpfn, 11) && ((de.attr & ATTR_DIRECTORY) == ATTR_DIRECTORY)) {
??DFS_OpenDir_17:
        MOVS     R2,#+11
        MOV      R1,SP
        ADD      R0,SP,#+12
        _BLF     memcmp,??memcmp??rT
        CBNZ     R0,??DFS_OpenDir_18
        LDRB     R0,[SP, #+23]
        LSLS     R0,R0,#+27
        BPL.N    ??DFS_OpenDir_18
//  566         if (volinfo->filesystem == FAT32) {
        LDRB     R1,[SP, #+39]
        LDRB     R0,[SP, #+38]
        ORRS     R0,R0,R1, LSL #+8
        LDRB     R1,[R8, #+1]
        CMP      R1,#+2
        BNE.N    ??DFS_OpenDir_19
//  567           dirinfo->currentcluster = (u32) de.startclus_l_l |
//  568             ((u32) de.startclus_l_h) << 8 |
//  569             ((u32) de.startclus_h_l) << 16 |
//  570             ((u32) de.startclus_h_h) << 24;
        LDRB     R1,[SP, #+32]
        ORRS     R0,R0,R1, LSL #+16
        LDRB     R1,[SP, #+33]
        ORRS     R0,R0,R1, LSL #+24
//  571         }
//  572         else {
//  573           dirinfo->currentcluster = (u32) de.startclus_l_l |
//  574             ((u32) de.startclus_l_h) << 8;
??DFS_OpenDir_19:
        STR      R0,[R4, #+0]
//  575         }
//  576         dirinfo->currentsector = 0;
        MOVS     R1,#+0
        STRB     R1,[R4, #+4]
//  577         dirinfo->currententry = 0;
        STRB     R1,[R4, #+5]
//  578 
//  579         if (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->dataarea + ((dirinfo->currentcluster - 2) * volinfo->secperclus*2), 1))
        LDRB     R3,[R8, #+20]
        LDR      R1,[R8, #+48]
        SUBS     R0,R0,#+2
        MOVS     R2,#+512
        MULS     R0,R3,R0
        ADDS     R0,R1,R0, LSL #+1
        LSLS     R1,R0,#+9
        LDR      R0,[R4, #+8]
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        B.N      ??DFS_OpenDir_20
//  580           return DFS_ERRMISC;
//  581       }
//  582       else if (!memcmp(de.name, tmpfn, 11) && !(de.attr & ATTR_DIRECTORY))
??DFS_OpenDir_18:
        MOVS     R2,#+11
        MOV      R1,SP
        ADD      R0,SP,#+12
        _BLF     memcmp,??memcmp??rT
        CBNZ     R0,??DFS_OpenDir_20
        LDRB     R0,[SP, #+23]
        LSLS     R0,R0,#+27
        BMI.N    ??DFS_OpenDir_20
//  583         return DFS_NOTFOUND;
        MOVS     R0,#+3
        B.N      ??DFS_OpenDir_4
//  584 
//  585       // seek to next item in list
//  586       while (*ptr != DIR_SEPARATOR && *ptr)
//  587         ptr++;
??DFS_OpenDir_21:
        ADDS     R5,R5,#+1
??DFS_OpenDir_20:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+47
        BEQ.N    ??DFS_OpenDir_22
        CMP      R0,#+0
        BNE.N    ??DFS_OpenDir_21
//  588       if (*ptr == DIR_SEPARATOR)
??DFS_OpenDir_22:
        CMP      R0,#+47
        BNE.N    ??DFS_OpenDir_9
//  589         ptr++;
        ADDS     R5,R5,#+1
        B.N      ??DFS_OpenDir_9
//  590     }
//  591 
//  592     if (!dirinfo->currentcluster)
??DFS_OpenDir_10:
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        ITE     NE 
        MOVNE    R0,#+0
//  593       return DFS_NOTFOUND;
        MOVEQ    R0,#+3
??DFS_OpenDir_4:
        ADD      SP,SP,#+44
        CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock8
//  594   }
//  595   return DFS_OK;
//  596 }
//  597 
//  598 /*
//  599   Get next entry in opened directory structure. Copies fields into the dirent
//  600   structure, updates dirinfo. Note that it is the _caller's_ responsibility to
//  601   handle the '.' and '..' entries.
//  602   A deleted file will be returned as a NULL entry (first char of filename=0)
//  603   by this code. Filenames beginning with 0x05 will be translated to 0xE5
//  604   automatically. Long file name entries will be returned as NULL.
//  605   returns DFS_EOF if there are no more entries, DFS_OK if this entry is valid,
//  606   or DFS_ERRMISC for a media error
//  607 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function DFS_GetNext
        THUMB
//  608 u32 DFS_GetNext(PVOLINFO volinfo, PDIRINFO dirinfo, PDIRENT dirent)
//  609 {
DFS_GetNext:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        SUB      SP,SP,#+4
        CFI CFA R13+24
        MOVS     R4,R0
        MOVS     R5,R1
//  610   u32 tempint;  // required by DFS_GetFAT
//  611 
//  612   // Do we need to read the next sector of the directory?
//  613   if (dirinfo->currententry >= SECTOR_SIZE / sizeof(DIRENT)) 
        LDRB     R0,[R5, #+5]
        MOVS     R7,R2
        MOVS     R6,#+0
        CMP      R0,#+16
        BCC.N    ??DFS_GetNext_0
//  614   {
//  615     dirinfo->currententry = 0;
        STRB     R6,[R5, #+5]
//  616     dirinfo->currentsector++;
        LDRB     R0,[R5, #+4]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+4]
//  617     
//  618     // Root directory; special case handling 
//  619     // Note that currentcluster will only ever be zero if both:
//  620     // (a) this is the root directory, and
//  621     // (b) we are on a FAT12/16 volume, where the root dir can't be expanded
//  622     if (dirinfo->currentcluster == 0) 
        LDR      R3,[R5, #+0]
        CBNZ     R3,??DFS_GetNext_1
//  623     {
//  624       // Trying to read past end of root directory?
//  625       if (dirinfo->currentsector * (SECTOR_SIZE / sizeof(DIRENT)) >= volinfo->rootentries)
        LDRH     R2,[R4, #+32]
        UXTB     R0,R0
        LSLS     R1,R0,#+4
        CMP      R1,R2
        BCC.N    ??DFS_GetNext_2
//  626         return DFS_EOF;
        MOVS     R0,#+1
        B.N      ??DFS_GetNext_3
//  627 
//  628       // Otherwise try to read the next sector
//  629       return (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->rootdir + dirinfo->currentsector, 1));
??DFS_GetNext_2:
        LDR      R1,[R4, #+44]
        MOVS     R2,#+512
        ADDS     R0,R1,R0
        LSLS     R1,R0,#+9
        LDR      R0,[R5, #+8]
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        B.N      ??DFS_GetNext_4
//  630     }
//  631 
//  632     // Normal handling
//  633     else 
//  634     {
//  635       if (dirinfo->currentsector >= volinfo->secperclus) 
??DFS_GetNext_1:
        LDRB     R1,[R4, #+20]
        UXTB     R0,R0
        CMP      R0,R1
        BCC.N    ??DFS_GetNext_5
//  636       {
//  637         dirinfo->currentsector = 0;
//  638         if ((dirinfo->currentcluster >= 0xff7 &&  volinfo->filesystem == FAT12) ||
//  639           (dirinfo->currentcluster >= 0xfff7 &&  volinfo->filesystem == FAT16) ||
//  640           (dirinfo->currentcluster >= 0x0ffffff7 &&  volinfo->filesystem == FAT32)) 
        LDR.N    R0,??DataTable4  ;; 0xff7
        STRB     R6,[R5, #+4]
        CMP      R3,R0
        BCC.N    ??DFS_GetNext_6
        LDRB     R0,[R4, #+1]
        CBZ      R0,??DFS_GetNext_7
??DFS_GetNext_6:
        LDR.N    R1,??DataTable5  ;; 0xfff7
        LDRB     R0,[R4, #+1]
        CMP      R3,R1
        BCC.N    ??DFS_GetNext_8
        CMP      R0,#+1
        BEQ.N    ??DFS_GetNext_7
??DFS_GetNext_8:
        LDR.N    R1,??DataTable6  ;; 0xffffff7
        CMP      R3,R1
        BCC.N    ??DFS_GetNext_9
        CMP      R0,#+2
        BNE.N    ??DFS_GetNext_9
//  641          {
//  642           
//  643             // We are at the end of the directory chain. If this is a normal
//  644             // find operation, we should indicate that there is nothing more
//  645             // to see.
//  646             if (!(dirinfo->flags & DFS_DI_BLANKENT))
??DFS_GetNext_7:
        LDRB     R0,[R5, #+12]
        LSLS     R0,R0,#+31
        ITE     MI 
        MOVMI    R0,#+5
//  647             return DFS_EOF;
        MOVPL    R0,#+1
        B.N      ??DFS_GetNext_3
//  648           
//  649           // On the other hand, if this is a "find free entry" search,
//  650           // we need to tell the caller to allocate a new cluster
//  651           else
//  652             return DFS_ALLOCNEW;
//  653         }
//  654         dirinfo->currentcluster = DFS_GetFAT(volinfo, dirinfo->scratch, &tempint, dirinfo->currentcluster);
??DFS_GetNext_9:
        LDR      R1,[R5, #+8]
        MOV      R2,SP
        MOVS     R0,R4
        BL       DFS_GetFAT
        STR      R0,[R5, #+0]
//  655       }
//  656       return (DFS_ReadSector(volinfo->unit, dirinfo->scratch, volinfo->dataarea + ((dirinfo->currentcluster - 2) * volinfo->secperclus) + dirinfo->currentsector, 1));
??DFS_GetNext_5:
        LDR      R1,[R5, #+0]
        LDRB     R3,[R4, #+20]
        LDR      R0,[R4, #+48]
        SUBS     R1,R1,#+2
        MOVS     R2,#+512
        MLA      R0,R1,R3,R0
        LDRB     R1,[R5, #+4]
        ADDS     R0,R0,R1
        LSLS     R1,R0,#+9
        LDR      R0,[R5, #+8]
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        B.N      ??DFS_GetNext_4
//  657       
//  658     }
//  659   }
//  660 
//  661   memcpy(dirent, &(((PDIRENT)dirinfo->scratch)[dirinfo->currententry]), sizeof(DIRENT));
??DFS_GetNext_0:
        LDR      R1,[R5, #+8]
        MOVS     R2,#+32
        ADDS     R1,R1,R0, LSL #+5
        MOVS     R0,R7
        _BLF     memcpy,??memcpy??rT
//  662 
//  663   dirinfo->currententry++;
        LDRB     R0,[R5, #+5]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+5]
//  664   if ((dirent->name[0] == 0) || (dirent->name[0] == 0xe5))
        LDRB     R0,[R7, #+0]
        CBZ      R0,??DFS_GetNext_10
        CMP      R0,#+229
        BNE.N    ??DFS_GetNext_11
//  665   {    // no more files in this directory
//  666     // If this is a "find blank" then we can reuse this name.
//  667     
//  668     if (dirinfo->flags & DFS_DI_BLANKENT)
??DFS_GetNext_10:
        LDRB     R0,[R5, #+12]
        LSLS     R0,R0,#+31
        ITE     PL 
        MOVPL    R0,#+1
//  669       return DFS_OK;
        MOVMI    R0,#+0
        B.N      ??DFS_GetNext_3
//  670     else
//  671       return DFS_EOF;
//  672   }
//  673 
//  674   if (dirent->name[0] == 0xe5)  // handle deleted file entries
//  675     dirent->name[0] = 0;
//  676   else if ((dirent->attr & ATTR_LONG_NAME) == ATTR_LONG_NAME)
??DFS_GetNext_11:
        LDRB     R1,[R7, #+11]
        LSLS     R1,R1,#+28
        LSRS     R1,R1,#+28
        CMP      R1,#+15
        BNE.N    ??DFS_GetNext_12
        STRB     R6,[R7, #+0]
        B.N      ??DFS_GetNext_4
//  677     dirent->name[0] = 0;
//  678   else if (dirent->name[0] == 0x05)  // handle kanji filenames beginning with 0xE5
??DFS_GetNext_12:
        CMP      R0,#+5
        ITT     EQ 
//  679     dirent->name[0] = 0xe5;
        MOVEQ    R0,#+229
        STRBEQ   R0,[R7, #+0]
//  680 
//  681 
//  682   return DFS_OK;
??DFS_GetNext_4:
        MOVS     R0,#+0
??DFS_GetNext_3:
        ADD      SP,SP,#+4
        CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock9
//  683 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     0xff7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     0xfff7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     0xffffff7
//  684 
//  685 /*
//  686   INTERNAL
//  687   Find a free directory entry in the directory specified by path
//  688   This function MAY cause a disk write if it is necessary to extend the directory
//  689   size.
//  690   Note - di.scratch must be preinitialized to point to a sector scratch buffer
//  691   de is a scratch structure
//  692   Returns DFS_ERRMISC if a new entry could not be located or created
//  693   de is updated with the same return information you would expect from DFS_GetNext
//  694 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function DFS_GetFreeDirEnt
        THUMB
//  695 u32 DFS_GetFreeDirEnt(PVOLINFO volinfo, u8 *path, PDIRINFO di, PDIRENT de)
//  696 {
DFS_GetFreeDirEnt:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        SUB      SP,SP,#+8
        CFI CFA R13+36
        MOVS     R4,R0
        MOVS     R5,R2
        MOVS     R6,R3
//  697   u32 tempclus,i;
//  698 
//  699   if (DFS_OpenDir(volinfo, path, di))
        BL       DFS_OpenDir
        CBZ      R0,??DFS_GetFreeDirEnt_0
//  700     return DFS_NOTFOUND;
        MOVS     R0,#+3
??DFS_GetFreeDirEnt_1:
        ADD      SP,SP,#+8
        CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
        CFI CFA R13+36
//  701 
//  702   // Set "search for empty" flag so DFS_GetNext knows what we're doing
//  703   di->flags |= DFS_DI_BLANKENT;
??DFS_GetFreeDirEnt_0:
        LDRB     R0,[R5, #+12]
        ORRS     R0,R0,#0x1
        STRB     R0,[R5, #+12]
//  704 
//  705   // We seek through the directory looking for an empty entry
//  706   // Note we are reusing tempclus as a temporary result holder.
//  707   tempclus = 0;  
//  708   do {
//  709     tempclus = DFS_GetNext(volinfo, di, de);
??DFS_GetFreeDirEnt_2:
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        BL       DFS_GetNext
        MOVS     R7,R0
//  710 
//  711     // Empty entry found
//  712     if (tempclus == DFS_OK && (!de->name[0])) {
        BNE.N    ??DFS_GetFreeDirEnt_3
        LDRB     R0,[R6, #+0]
        CMP      R0,#+0
        BNE.N    ??DFS_GetFreeDirEnt_2
//  713       return DFS_OK;
        B.N      ??DFS_GetFreeDirEnt_1
//  714     }
//  715 
//  716     // End of root directory reached
//  717     else if (tempclus == DFS_EOF)
??DFS_GetFreeDirEnt_3:
        CMP      R0,#+1
        BNE.N    ??DFS_GetFreeDirEnt_4
//  718       return DFS_ERRMISC;
??DFS_GetFreeDirEnt_5:
        MOVS     R0,#-1
        B.N      ??DFS_GetFreeDirEnt_1
//  719       
//  720     else if (tempclus == DFS_ALLOCNEW) {
??DFS_GetFreeDirEnt_4:
        CMP      R0,#+5
        BNE.N    ??DFS_GetFreeDirEnt_5
//  721       tempclus = DFS_GetFreeFAT(volinfo, di->scratch);
        LDR      R6,[R5, #+8]
        MOVS     R0,#+0
        MOV      R8,R0
        STR      R8,[SP, #+4]
        MOVS     R7,#+2
        B.N      ??DFS_GetFreeDirEnt_6
??DFS_GetFreeDirEnt_7:
        ADDS     R7,R7,#+1
??DFS_GetFreeDirEnt_6:
        LDR      R0,[R4, #+36]
        CMP      R7,R0
        BCS.N    ??DFS_GetFreeDirEnt_5
        MOVS     R3,R7
        ADD      R2,SP,#+4
        MOVS     R1,R6
        MOVS     R0,R4
        BL       DFS_GetFAT
        CMP      R0,#+0
        BNE.N    ??DFS_GetFreeDirEnt_7
//  722       if (tempclus == 0x0ffffff7)
        LDR.N    R0,??DataTable7  ;; 0xffffff7
        CMP      R7,R0
        BEQ.N    ??DFS_GetFreeDirEnt_5
//  723         return DFS_ERRMISC;
//  724 
//  725       // write out zeroed sectors to the new cluster
//  726       memset(di->scratch, 0, SECTOR_SIZE);
        LDR      R0,[R5, #+8]
        MOVS     R2,#+512
        MOVS     R1,#+0
        _BLF     memset,??memset??rT
//  727       for (i=0;i<volinfo->secperclus;i++) {
        STR      R8,[SP, #+0]
        LDRB     R0,[R4, #+20]
        CBNZ     R0,??DFS_GetFreeDirEnt_8
        B.N      ??DFS_GetFreeDirEnt_9
//  728         if (DFS_WriteSector(volinfo->unit, di->scratch, volinfo->dataarea + (((tempclus - 2) * volinfo->secperclus) + i), 1))
??DFS_GetFreeDirEnt_10:
        LDR      R1,[R5, #+8]
        SUBS     R2,R7,#+2
        MOV      R9,R1
        LDR      R1,[R4, #+48]
        MLA      R0,R2,R0,R1
        LDR      R1,[SP, #+0]
        ADDS     R0,R0,R1
        LSLS     R6,R0,#+9
        MOVS     R1,R6
        MOV      R0,R9
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R6,#+256
        ADDW     R0,R9,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  729           
//  730           return DFS_ERRMISC;
//  731       }
        LDR      R0,[SP, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[SP, #+0]
??DFS_GetFreeDirEnt_8:
        LDRB     R0,[R4, #+20]
        LDR      R1,[SP, #+0]
        CMP      R1,R0
        BCC.N    ??DFS_GetFreeDirEnt_10
//  732       // Point old end cluster to newly allocated cluster
//  733       i = 0;
??DFS_GetFreeDirEnt_9:
        STR      R8,[SP, #+0]
//  734       DFS_SetFAT(volinfo, di->scratch, &i, di->currentcluster, tempclus);
        PUSH     {R7}
        CFI CFA R13+40
        LDR      R3,[R5, #+0]
        LDR      R1,[R5, #+8]
        ADD      R2,SP,#+4
        MOVS     R0,R4
        BL       DFS_SetFAT
//  735 
//  736       // Update DIRINFO so caller knows where to place the new file      
//  737       di->currentcluster = tempclus;
        STR      R7,[R5, #+0]
//  738       di->currentsector = 0;
        MOVS     R0,#+0
        STRB     R0,[R5, #+4]
//  739       di->currententry = 1;  // since the code coming after this expects to subtract 1
        MOVS     R0,#+1
        STRB     R0,[R5, #+5]
//  740       
//  741       // Mark newly allocated cluster as end of chain      
//  742       switch(volinfo->filesystem) {
        LDRB     R0,[R4, #+1]
        ADD      SP,SP,#+4
        CFI CFA R13+36
        CBZ      R0,??DFS_GetFreeDirEnt_11
        CMP      R0,#+1
        BEQ.N    ??DFS_GetFreeDirEnt_12
        CMP      R0,#+2
        BEQ.N    ??DFS_GetFreeDirEnt_13
        B.N      ??DFS_GetFreeDirEnt_5
//  743         case FAT12:    tempclus = 0xff8;  break;
??DFS_GetFreeDirEnt_11:
        LDR.N    R7,??DataTable12  ;; 0xff8
        B.N      ??DFS_GetFreeDirEnt_14
//  744         case FAT16:    tempclus = 0xfff8;  break;
??DFS_GetFreeDirEnt_12:
        LDR.N    R7,??DataTable13  ;; 0xfff8
        B.N      ??DFS_GetFreeDirEnt_14
//  745         case FAT32:    tempclus = 0x0ffffff8;  break;
??DFS_GetFreeDirEnt_13:
        LDR.N    R7,??DataTable14  ;; 0xffffff8
//  746         default:    return DFS_ERRMISC;
//  747       }
//  748       DFS_SetFAT(volinfo, di->scratch, &i, di->currentcluster, tempclus);
??DFS_GetFreeDirEnt_14:
        MOVS     R0,R4
        PUSH     {R7}
        CFI CFA R13+40
        LDR      R3,[R5, #+0]
        LDR      R1,[R5, #+8]
        ADD      R2,SP,#+4
        BL       DFS_SetFAT
        ADD      SP,SP,#+4
        CFI CFA R13+36
        B.N      ??DFS_GetFreeDirEnt_5
        CFI EndBlock cfiBlock10
//  749     }
//  750   } while (!tempclus);
//  751 
//  752   // We shouldn't get here
//  753   return DFS_ERRMISC;
//  754 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     0xffffff7
//  755 
//  756 /*
//  757   Open a file for reading or writing. You supply populated VOLINFO, a path to the file,
//  758   mode (DFS_READ or DFS_WRITE) and an empty fileinfo structure. You also need to
//  759   provide a pointer to a sector-sized scratch buffer.
//  760   Returns various DFS_* error states. If the result is DFS_OK, fileinfo can be used
//  761   to access the file from this point on.
//  762 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function DFS_OpenFile
        THUMB
//  763 u32 DFS_OpenFile(PVOLINFO volinfo, u8 *path, u8 mode, u8 *scratch, PFILEINFO fileinfo)
//  764 {
DFS_OpenFile:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+132
        CFI CFA R13+168
        LDR      R4,[SP, #+168]
        MOVS     R5,R1
        MOV      R8,R0
        MOV      R9,R2
        MOV      R10,R3
//  765   u8 tmppath[MAX_PATH];
//  766   u8 filename[12];
//  767   u8 *p;
//  768   DIRINFO di;
//  769   DIRENT de;
//  770         int rc;
//  771   // larwe 2006-09-16 +1 zero out file structure
//  772   memset(fileinfo, 0, sizeof(FILEINFO));
        MOVS     R2,#+28
        MOVS     R1,#+0
        MOVS     R0,R4
        _BLF     memset,??memset??rT
//  773   // save access mode
//  774   fileinfo->mode = mode;
        STRB     R9,[R4, #+9]
//  775 
//  776   // Get a local copy of the path. If it's longer than MAX_PATH, abort.
//  777   strncpy((char *) tmppath, (char *) path, MAX_PATH);
        MOVS     R2,#+64
        MOVS     R1,R5
        ADD      R0,SP,#+68
        _BLF     strncpy,??strncpy??rT
//  778   tmppath[MAX_PATH - 1] = 0;
        MOVS     R0,#+0
        MOV      R11,R0
        STRB     R0,[SP, #+131]
//  779   if (strcmp((char *) path,(char *) tmppath)) {
        ADD      R1,SP,#+68
        MOVS     R0,R5
        _BLF     strcmp,??strcmp??rT
        CBZ      R0,??DFS_OpenFile_0
//  780     
//  781     return DFS_PATHLEN;
        MOVS     R0,#+4
        B.N      ??DFS_OpenFile_1
//  782   }
//  783 
//  784   // strip leading path separators
//  785   while (tmppath[0] == DIR_SEPARATOR)
//  786     strcpy((char *) tmppath, (char *) tmppath + 1);
??DFS_OpenFile_2:
        ADD      R1,SP,#+68
        ADDS     R1,R1,#+1
        ADD      R0,SP,#+68
        _BLF     strcpy,??strcpy??rT
??DFS_OpenFile_0:
        LDRB     R0,[SP, #+68]
        CMP      R0,#+47
        BEQ.N    ??DFS_OpenFile_2
//  787 
//  788   // Parse filename off the end of the supplied path
//  789   p = tmppath;
        ADD      R5,SP,#+68
//  790   while (*(p++));
??DFS_OpenFile_3:
        MOVS     R0,R5
        LDRB     R0,[R0, #+0]
        ADDS     R5,R5,#+1
        CMP      R0,#+0
        BNE.N    ??DFS_OpenFile_3
//  791 
//  792   p--;
??DFS_OpenFile_4:
        SUBS     R5,R5,#+1
//  793   while (p > tmppath && *p != DIR_SEPARATOR) // larwe 9/16/06 ">=" to ">" bugfix
        ADD      R0,SP,#+68
        STR      R0,[SP, #+0]
        CMP      R0,R5
        BCS.N    ??DFS_OpenFile_5
        LDRB     R0,[R5, #+0]
        CMP      R0,#+47
        BNE.N    ??DFS_OpenFile_4
//  794     p--;
//  795   if (*p == DIR_SEPARATOR)
??DFS_OpenFile_5:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+47
        IT      EQ 
//  796     p++;
        ADDEQ    R5,R5,#+1
//  797 
//  798   DFS_CanonicalToDir(filename, p);
        ADD      R7,SP,#+56
        MOVS     R2,#+11
        MOVS     R1,#+32
        ADD      R0,SP,#+56
        _BLF     memset,??memset??rT
        MOVS     R6,R5
        MOVS     R0,#+0
        STRB     R0,[SP, #+67]
        B.N      ??DFS_OpenFile_6
??DFS_OpenFile_7:
        CMP      R0,#+123
        BCS.N    ??DFS_OpenFile_8
        ADDS     R0,R0,#+224
        STRB     R0,[R7], #+1
??DFS_OpenFile_9:
        ADDS     R6,R6,#+1
??DFS_OpenFile_6:
        LDRB     R0,[R6, #+0]
        CBZ      R0,??DFS_OpenFile_10
        CMP      R0,#+47
        BEQ.N    ??DFS_OpenFile_10
        ADD      R1,SP,#+56
        SUBS     R1,R7,R1
        CMP      R1,#+11
        BGE.N    ??DFS_OpenFile_10
        CMP      R0,#+97
        BCS.N    ??DFS_OpenFile_7
        CMP      R0,#+46
        BNE.N    ??DFS_OpenFile_8
        ADDS     R6,R6,#+1
        ADD      R7,SP,#+56
        ADDS     R7,R7,#+8
        B.N      ??DFS_OpenFile_6
??DFS_OpenFile_8:
        STRB     R0,[R7], #+1
        B.N      ??DFS_OpenFile_9
//  799 
//  800   if (p > tmppath)
??DFS_OpenFile_10:
        LDR      R0,[SP, #+0]
        CMP      R0,R5
        IT      CC 
//  801     p--;
        SUBCC    R5,R5,#+1
//  802   if (*p == DIR_SEPARATOR || p == tmppath) // larwe 9/16/06 +"|| p == tmppath" bugfix
        LDRB     R0,[R5, #+0]
        CMP      R0,#+47
        BEQ.N    ??DFS_OpenFile_11
        ADD      R0,SP,#+68
        CMP      R5,R0
        BNE.N    ??DFS_OpenFile_12
//  803     *p = 0;
??DFS_OpenFile_11:
        MOVS     R0,#+0
        STRB     R0,[R5, #+0]
//  804 
//  805   // At this point, if our path was MYDIR/MYDIR2/FILE.EXT, filename = "FILE    EXT" and
//  806   // tmppath = "MYDIR/MYDIR2".
//  807   
//  808   di.scratch =scratch ;
??DFS_OpenFile_12:
        STR      R10,[SP, #+12]
//  809   if (DFS_OpenDir(volinfo,tmppath, &di))//scratch di=dirinfo
        ADD      R2,SP,#+4
        ADD      R1,SP,#+68
        MOV      R0,R8
        BL       DFS_OpenDir
        CBZ      R0,??DFS_OpenFile_13
//  810     return DFS_NOTFOUND;
??DFS_OpenFile_14:
        MOVS     R0,#+3
        B.N      ??DFS_OpenFile_1
//  811 
//  812   while(1) 
//  813   {
//  814     rc=DFS_GetNext(volinfo, &di, &de);
??DFS_OpenFile_13:
        ADD      R2,SP,#+20
        ADD      R1,SP,#+4
        MOV      R0,R8
        BL       DFS_GetNext
//  815     if(rc==DFS_EOF)break;
        CMP      R0,#+1
        BNE.N    ??DFS_OpenFile_15
//  816     if (!memcmp(de.name, filename, 11)) 
//  817     {
//  818       // You can't use this function call to open a directory.
//  819       if (de.attr & ATTR_DIRECTORY)
//  820         return DFS_NOTFOUND;
//  821 
//  822       fileinfo->volinfo = volinfo;
//  823       fileinfo->pointer = 0;
//  824       // The reason we store this extra info about the file is so that we can
//  825       // speedily update the file size, modification date, etc. on a file that is
//  826       // opened for writing.
//  827       if (di.currentcluster == 0)
//  828         fileinfo->dirsector = volinfo->rootdir + di.currentsector;
//  829       else
//  830         fileinfo->dirsector = volinfo->dataarea + (((di.currentcluster - 2) * volinfo->secperclus * (volinfo->sectorsize/SECTOR_SIZE)) + di.currentsector);
//  831       
//  832 
//  833       fileinfo->diroffset = di.currententry - 1;
//  834       if (volinfo->filesystem == FAT32) {
//  835         fileinfo->cluster = (u32) de.startclus_l_l |
//  836           ((u32) de.startclus_l_h) << 8 |
//  837           ((u32) de.startclus_h_l) << 16 |
//  838           ((u32) de.startclus_h_h) << 24;
//  839       }
//  840       else {
//  841         fileinfo->cluster = (u32) de.startclus_l_l |
//  842           ((u32) de.startclus_l_h) << 8;
//  843       }
//  844       
//  845  
//  846         fileinfo->firstcluster = fileinfo->cluster;
//  847         fileinfo->filelen = (u32) de.filesize_0 |
//  848         ((u32) de.filesize_1) << 8 |
//  849         ((u32) de.filesize_2) << 16 |
//  850         ((u32) de.filesize_3) << 24;
//  851       if(fileinfo->mode==DFS_WRITE)fileinfo->mode=DFS_MODIFLY;
//  852       return DFS_OK;
//  853     }
//  854     
//  855   };
//  856   
//  857 
//  858   // At this point, we KNOW the file does not exist. If the file was opened
//  859   // with write access, we can create it.
//  860   if ((mode & DFS_WRITE)==DFS_WRITE) 
        MOV      R0,R9
        LSLS     R0,R0,#+30
        BPL.N    ??DFS_OpenFile_14
//  861   {
//  862     u32 cluster, temp;
//  863     // Locate or create a directory entry for this file
//  864     if (DFS_OK != DFS_GetFreeDirEnt(volinfo, tmppath, &di, &de))
        ADD      R3,SP,#+20
        ADD      R2,SP,#+4
        ADD      R1,SP,#+68
        MOV      R0,R8
        BL       DFS_GetFreeDirEnt
        CMP      R0,#+0
        BEQ.N    ??DFS_OpenFile_16
//  865       return   DFS_ERRMISC;
??DFS_OpenFile_17:
        MOVS     R0,#-1
        B.N      ??DFS_OpenFile_1
??DFS_OpenFile_15:
        MOVS     R2,#+11
        ADD      R1,SP,#+56
        ADD      R0,SP,#+20
        _BLF     memcmp,??memcmp??rT
        CMP      R0,#+0
        BNE.N    ??DFS_OpenFile_13
        LDRB     R0,[SP, #+31]
        LSLS     R0,R0,#+27
        BMI.N    ??DFS_OpenFile_14
        STR      R8,[R4, #+0]
        STR      R11,[R4, #+24]
        LDR      R0,[SP, #+4]
        CBNZ     R0,??DFS_OpenFile_18
        LDR      R0,[R8, #+44]
        LDRB     R1,[SP, #+8]
        B.N      ??DFS_OpenFile_19
??DFS_OpenFile_18:
        LDR      R1,[SP, #+4]
        LDRB     R2,[R8, #+20]
        LDR      R0,[R8, #+48]
        SUBS     R1,R1,#+2
        MULS     R1,R2,R1
        LDRH     R2,[R8, #+52]
        LSRS     R2,R2,#+9
        MLA      R0,R1,R2,R0
        LDRB     R1,[SP, #+8]
??DFS_OpenFile_19:
        ADDS     R0,R0,R1
        STR      R0,[R4, #+4]
        LDRB     R0,[SP, #+9]
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+8]
        LDRB     R0,[R8, #+1]
        CMP      R0,#+2
        BNE.N    ??DFS_OpenFile_20
        LDRB     R1,[SP, #+47]
        LDRB     R0,[SP, #+46]
        ORRS     R0,R0,R1, LSL #+8
        LDRB     R1,[SP, #+40]
        ORRS     R0,R0,R1, LSL #+16
        LDRB     R1,[SP, #+41]
        ORRS     R0,R0,R1, LSL #+24
        B.N      ??DFS_OpenFile_21
??DFS_OpenFile_20:
        LDRB     R1,[SP, #+47]
        LDRB     R0,[SP, #+46]
        ORRS     R0,R0,R1, LSL #+8
??DFS_OpenFile_21:
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+12]
        LDRB     R1,[SP, #+49]
        LDRB     R0,[SP, #+48]
        ORRS     R0,R0,R1, LSL #+8
        LDRB     R1,[SP, #+50]
        ORRS     R0,R0,R1, LSL #+16
        LDRB     R1,[SP, #+51]
        ORRS     R0,R0,R1, LSL #+24
        STR      R0,[R4, #+16]
        LDRB     R0,[R4, #+9]
        CMP      R0,#+2
        ITT     EQ 
        MOVEQ    R0,#+3
        STRBEQ   R0,[R4, #+9]
        MOVS     R0,#+0
        B.N      ??DFS_OpenFile_1
//  866     
//  867 
//  868     // put sane values in the directory entry
//  869     memset(&de, 0, sizeof(de));
??DFS_OpenFile_16:
        MOVS     R2,#+32
        MOVS     R1,#+0
        ADD      R0,SP,#+20
        _BLF     memset,??memset??rT
//  870     memcpy(de.name, filename, 11);
        MOVS     R2,#+11
        ADD      R1,SP,#+56
        ADD      R0,SP,#+20
        _BLF     memcpy,??memcpy??rT
//  871     //de.crttimetenth=0;
//  872     de.crttime_l = 0;  // 01:01:00am, Jan 1, 2006.
        MOV      R0,R11
        STRB     R0,[SP, #+34]
//  873     de.crttime_h = 0;//0X40;
        STRB     R0,[SP, #+35]
//  874     de.crtdate_l = 0;//0XA1;
        STRB     R0,[SP, #+36]
//  875     de.crtdate_h = 0;//0X3E;
        STRB     R0,[SP, #+37]
//  876     //de.lstaccdate_l = 11;
//  877     //de.lstaccdate_h = 34;
//  878     
//  879     de.wrttime_l = 0;      //2011/05/01
        STRB     R0,[SP, #+42]
//  880     de.wrttime_h = 0;//0X40;
        STRB     R0,[SP, #+43]
//  881     de.wrtdate_l = 0;//0XA1;
        STRB     R0,[SP, #+44]
//  882     de.wrtdate_h = 0;//0X3E;
        STRB     R0,[SP, #+45]
//  883 
//  884     // allocate a starting cluster for the directory entry
//  885     cluster = DFS_GetFreeFAT(volinfo, scratch);
        STR      R11,[SP, #+0]
        MOVS     R5,#+2
        B.N      ??DFS_OpenFile_22
??DFS_OpenFile_23:
        ADDS     R5,R5,#+1
??DFS_OpenFile_22:
        LDR      R0,[R8, #+36]
        CMP      R5,R0
        BCS.N    ??DFS_OpenFile_24
        MOVS     R3,R5
        MOV      R2,SP
        MOV      R1,R10
        MOV      R0,R8
        BL       DFS_GetFAT
        CMP      R0,#+0
        BNE.N    ??DFS_OpenFile_23
        B.N      ??DFS_OpenFile_25
??DFS_OpenFile_24:
        LDR.N    R5,??DataTable19  ;; 0xffffff7
//  886 
//  887     de.startclus_l_l = cluster & 0xff;
??DFS_OpenFile_25:
        MOVS     R0,R5
        STRB     R0,[SP, #+46]
//  888     de.startclus_l_h = (cluster & 0xff00) >> 8;
        LSRS     R0,R0,#+8
        STRB     R0,[SP, #+47]
//  889     de.startclus_h_l = (cluster & 0xff0000) >> 16;
        LSRS     R0,R5,#+16
        STRB     R0,[SP, #+40]
//  890     de.startclus_h_h = (cluster & 0xff000000) >> 24;
        LSRS     R0,R5,#+24
        STRB     R0,[SP, #+41]
//  891     
//  892     
//  893     // update FILEINFO for our caller's sake
//  894     fileinfo->volinfo = volinfo;
        STR      R8,[R4, #+0]
//  895     fileinfo->pointer = 0;
        STR      R11,[R4, #+24]
//  896     // The reason we store this extra info about the file is so that we can
//  897     // speedily update the file size, modification date, etc. on a file that is
//  898     // opened for writing.
//  899     if (di.currentcluster == 0)
        LDR      R0,[SP, #+4]
        CBNZ     R0,??DFS_OpenFile_26
//  900       fileinfo->dirsector = volinfo->rootdir + di.currentsector;
        LDR      R0,[R8, #+44]
        LDRB     R1,[SP, #+8]
        B.N      ??DFS_OpenFile_27
//  901     else
//  902       fileinfo->dirsector = volinfo->dataarea + ((di.currentcluster - 2) * volinfo->secperclus*(volinfo->sectorsize/SECTOR_SIZE) ) + di.currentsector;
??DFS_OpenFile_26:
        LDR      R1,[SP, #+4]
        LDRB     R2,[R8, #+20]
        LDR      R0,[R8, #+48]
        SUBS     R1,R1,#+2
        MULS     R1,R2,R1
        LDRH     R2,[R8, #+52]
        LSRS     R2,R2,#+9
        MLA      R0,R1,R2,R0
        LDRB     R1,[SP, #+8]
??DFS_OpenFile_27:
        ADDS     R0,R0,R1
        STR      R0,[R4, #+4]
//  903     
//  904     fileinfo->diroffset = di.currententry - 1;
        LDRB     R1,[SP, #+9]
//  905     //dirsec=fileinfo->dirsector;
//  906     //diroff=fileinfo->diroffset;
//  907     fileinfo->cluster = cluster;
//  908     fileinfo->firstcluster = cluster;
//  909     
//  910     fileinfo->filelen = 0;
//  911     // write the directory entry
//  912     // note that we no longer have the sector containing the directory entry,
//  913     // tragically, so we have to re-read it
//  914     if (DFS_ReadSector(volinfo->unit, scratch, fileinfo->dirsector, 1))
        MOVS     R2,#+512
        SUBS     R1,R1,#+1
        STRB     R1,[R4, #+8]
        STR      R5,[R4, #+20]
        STR      R5,[R4, #+12]
        STR      R11,[R4, #+16]
        LSLS     R1,R0,#+9
        MOV      R0,R10
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
//  915     
//  916       return DFS_ERRMISC;
//  917     memcpy(&(((PDIRENT) scratch)[di.currententry-1]), &de, sizeof(DIRENT));
        LDRB     R0,[SP, #+9]
        MOVS     R2,#+32
        ADD      R1,SP,#+20
        ADDS     R0,R10,R0, LSL #+5
        SUBS     R0,R0,#+32
        _BLF     memcpy,??memcpy??rT
//  918     if (DFS_WriteSector(volinfo->unit, scratch, fileinfo->dirsector, 1))
        LDR      R0,[R4, #+4]
        LSLS     R5,R0,#+9
        MOVS     R1,R5
        MOV      R0,R10
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R5,#+256
        ADDW     R0,R10,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
//  919       return DFS_ERRMISC;
//  920 
//  921     // Mark newly allocated cluster as end of chain      
//  922     switch(volinfo->filesystem) {
        LDRB     R0,[R8, #+1]
        CBZ      R0,??DFS_OpenFile_28
        CMP      R0,#+1
        BEQ.N    ??DFS_OpenFile_29
        CMP      R0,#+2
        BEQ.N    ??DFS_OpenFile_30
        B.N      ??DFS_OpenFile_17
//  923       case FAT12:    cluster = 0xff8;  break;
??DFS_OpenFile_28:
        LDR.N    R5,??DataTable12  ;; 0xff8
        B.N      ??DFS_OpenFile_31
//  924       case FAT16:    cluster = 0xfff8;  break;
??DFS_OpenFile_29:
        LDR.N    R5,??DataTable13  ;; 0xfff8
        B.N      ??DFS_OpenFile_31
//  925       case FAT32:    cluster = 0x0ffffff8;  break;
??DFS_OpenFile_30:
        LDR.N    R5,??DataTable14  ;; 0xffffff8
//  926       default:    return DFS_ERRMISC;
//  927     }
//  928     temp = 0;
??DFS_OpenFile_31:
        STR      R11,[SP, #+52]
//  929     DFS_SetFAT(volinfo, scratch, &temp, fileinfo->cluster, cluster);
        MOV      R1,R10
        PUSH     {R5}
        CFI CFA R13+172
        LDR      R3,[R4, #+20]
        ADD      R2,SP,#+56
        MOV      R0,R8
        BL       DFS_SetFAT
//  930 
//  931     return DFS_OK;
        MOVS     R0,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+168
??DFS_OpenFile_1:
        ADD      SP,SP,#+132
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock11
//  932   }
//  933 
//  934 
//  935   return DFS_NOTFOUND;
//  936 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable12:
        DC32     0xff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable13:
        DC32     0xfff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable14:
        DC32     0xffffff8
//  937 
//  938 /*
//  939   Read an open file
//  940   You must supply a prepopulated FILEINFO as provided by DFS_OpenFile, and a
//  941   pointer to a SECTOR_SIZE scratch buffer.
//  942   Note that returning DFS_EOF is not an error condition. This function updates the
//  943   successcount field with the number of bytes actually read.
//  944 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function DFS_ReadFile
        THUMB
//  945 u32 DFS_ReadFile(PFILEINFO fileinfo, u8 *scratch, u8 *buffer, u32 *successcount, u32 len)
//  946 {
DFS_ReadFile:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+24
        CFI CFA R13+60
        LDR      R6,[SP, #+60]
        MOVS     R4,R0
//  947   u32 remain;
//  948   u32 result = DFS_OK;
//  949   u32 sector;
//  950   u32 bytesread;
//  951 u16 tempreadsize;
//  952   // Don't try to read past EOF
//  953   if (len > fileinfo->filelen - fileinfo->pointer)
        LDR      R0,[R4, #+16]
        MOV      R8,R1
        LDR      R1,[R4, #+24]
        MOV      R9,R3
        MOVS     R5,R2
        SUBS     R0,R0,R1
        CMP      R0,R6
        IT      CC 
//  954     len = fileinfo->filelen - fileinfo->pointer;
        MOVCC    R6,R0
//  955 
//  956   remain = len;
//  957   *successcount = 0;
        MOVS     R0,#+0
        MOV      R10,R0
        STR      R10,[R9, #+0]
        B.N      ??DFS_ReadFile_0
//  958   
//  959   while (remain && result == DFS_OK) 
//  960   {
//  961       
//  962     // This is a bit complicated. The sector we want to read is addressed at a cluster
//  963     // granularity by the fileinfo->cluster member. The file pointer tells us how many
//  964     // extra sectors to add to that number.*2*2
//  965     sector = fileinfo->volinfo->dataarea +
//  966       ((fileinfo->cluster - 2) * fileinfo->volinfo->secperclus*(fileinfo->volinfo->sectorsize/SECTOR_SIZE)) +
//  967      div(div(fileinfo->pointer,fileinfo->volinfo->secperclus *fileinfo->volinfo->sectorsize).rem, SECTOR_SIZE).quot;
//  968 
//  969 
//  970     // Case 1 - File pointer is not on a sector boundary
//  971     if (div(fileinfo->pointer, SECTOR_SIZE).rem) 
//  972     {
//  973       
//  974       // We always have to go through scratch in this case
//  975       result = DFS_ReadSector(fileinfo->volinfo->unit, scratch, sector, 1);
//  976       // This is the number of bytes that we actually care about in the sector
//  977       // just read.
//  978       tempreadsize = SECTOR_SIZE - (div(fileinfo->pointer, SECTOR_SIZE).rem);
//  979           
//  980       // Case 1A - We want the entire remainder of the sector. After this
//  981       // point, all passes through the read loop will be aligned on a sector
//  982       // boundary, which allows us to go through the optimal path 2A below.
//  983          if (remain >= tempreadsize) 
//  984          {
//  985         memcpy(buffer, scratch + (SECTOR_SIZE - tempreadsize), tempreadsize);
//  986         bytesread = tempreadsize;
//  987         buffer += tempreadsize;
//  988         fileinfo->pointer += tempreadsize;
//  989         remain -= tempreadsize;
//  990       }
//  991       // Case 1B - This read concludes the file read operation
//  992       else {
//  993         memcpy(buffer, scratch + (SECTOR_SIZE - tempreadsize), remain);
//  994 
//  995         buffer += remain;
//  996         fileinfo->pointer += remain;
//  997         bytesread = remain;
//  998         remain = 0;
//  999       }
// 1000     }
// 1001     // Case 2 - File pointer is on sector boundary
// 1002     else {
// 1003       // Case 2A - We have at least one more full sector to read and don't have
// 1004       // to go through the scratch buffer. You could insert optimizations here to
// 1005       // read multiple sectors at a time, if you were thus inclined (note that
// 1006       // the maximum multi-read you could perform is a single cluster, so it would
// 1007       // be advantageous to have code similar to case 1A above that would round the
// 1008       // pointer to a cluster boundary the first pass through, so all subsequent
// 1009       // [large] read requests would be able to go a cluster at a time).
// 1010       if (remain >= SECTOR_SIZE) {
// 1011         result = DFS_ReadSector(fileinfo->volinfo->unit, buffer, sector, 1);
// 1012 
// 1013         remain -= SECTOR_SIZE;
// 1014         buffer += SECTOR_SIZE;
// 1015         fileinfo->pointer += SECTOR_SIZE;
// 1016         bytesread = SECTOR_SIZE;
// 1017       }
// 1018       // Case 2B - We are only reading a partial sector
// 1019       else {
// 1020         result = DFS_ReadSector(fileinfo->volinfo->unit, scratch, sector, 1);
??DFS_ReadFile_1:
        MOVS     R2,#+512
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
// 1021       
// 1022         memcpy(buffer, scratch, remain);
        MOVS     R2,R6
        MOV      R1,R8
??DFS_ReadFile_2:
        MOVS     R0,R5
        _BLF     memcpy,??memcpy??rT
// 1023         buffer += remain;
// 1024         fileinfo->pointer += remain;
        LDR      R0,[R4, #+24]
        LDR      R5,[SP, #+12]
        ADDS     R0,R0,R6
        STR      R0,[R4, #+24]
// 1025         bytesread = remain;
        STR      R6,[SP, #+0]
// 1026         remain = 0;
        MOVS     R6,#+0
// 1027         
// 1028       }
// 1029     }
// 1030 
// 1031     *successcount += bytesread;
??DFS_ReadFile_3:
        LDR      R0,[R9, #+0]
        LDR      R1,[SP, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R9, #+0]
// 1032 
// 1033     // check to see if we stepped over a cluster boundary
// 1034     if (div(fileinfo->pointer - bytesread, fileinfo->volinfo->secperclus *fileinfo->volinfo->sectorsize).quot !=
// 1035       div(fileinfo->pointer, fileinfo->volinfo->secperclus * fileinfo->volinfo->sectorsize).quot) {
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+0]
        LDRB     R2,[R0, #+20]
        LDRH     R0,[R0, #+52]
        MULS     R2,R0,R2
        LDR      R0,[R4, #+24]
        SUBS     R1,R0,R1
        ADD      R0,SP,#+4
        _BLF     div,??div??rT
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R2,[R0, #+20]
        LDRH     R0,[R0, #+52]
        MULS     R2,R0,R2
        ADD      R0,SP,#+16
        _BLF     div,??div??rT
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+16]
        CMP      R0,R1
        BEQ.N    ??DFS_ReadFile_0
// 1036       // An act of minor evil - we use bytesread as a scratch integer, knowing that
// 1037       // its value is not used after updating *successcount above
// 1038       bytesread = 0;
        STR      R10,[SP, #+0]
// 1039       
// 1040       if (((fileinfo->volinfo->filesystem == FAT12) && (fileinfo->cluster >= 0xff8)) ||
// 1041         ((fileinfo->volinfo->filesystem == FAT16) && (fileinfo->cluster >= 0xfff8)) ||
// 1042         ((fileinfo->volinfo->filesystem == FAT32) && (fileinfo->cluster >= 0x0ffffff8)))
        LDR      R0,[R4, #+0]
        LDRB     R1,[R0, #+1]
        CBNZ     R1,??DFS_ReadFile_4
        LDR      R1,[R4, #+20]
        LDR.N    R2,??DataTable15  ;; 0xff8
        CMP      R1,R2
        BCS.N    ??DFS_ReadFile_0
??DFS_ReadFile_4:
        LDRB     R1,[R0, #+1]
        LDR      R3,[R4, #+20]
        CMP      R1,#+1
        BNE.N    ??DFS_ReadFile_5
        LDR.N    R1,??DataTable16  ;; 0xfff8
        CMP      R3,R1
        BCS.N    ??DFS_ReadFile_0
??DFS_ReadFile_5:
        LDRB     R1,[R0, #+1]
        CMP      R1,#+2
        BNE.N    ??DFS_ReadFile_6
        LDR.N    R1,??DataTable17  ;; 0xffffff8
        CMP      R3,R1
        BCS.N    ??DFS_ReadFile_0
// 1043         result =0;
// 1044       else {////////////
// 1045 //        Send2File(fileinfo->cluster);
// 1046         fileinfo->cluster = DFS_GetFAT(fileinfo->volinfo, scratch, &bytesread, fileinfo->cluster);
??DFS_ReadFile_6:
        MOV      R2,SP
        MOV      R1,R8
        BL       DFS_GetFAT
        STR      R0,[R4, #+20]
// 1047 //        Send2File(fileinfo->cluster);
// 1048       }////////////////
// 1049     }
??DFS_ReadFile_0:
        CMP      R6,#+0
        BEQ.N    ??DFS_ReadFile_7
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R2,[R0, #+20]
        LDRH     R0,[R0, #+52]
        MULS     R2,R0,R2
        ADD      R0,SP,#+16
        _BLF     div,??div??rT
        LDR      R1,[SP, #+20]
        MOVS     R2,#+512
        ADD      R0,SP,#+4
        _BLF     div,??div??rT
        LDR      R2,[R4, #+0]
        LDR      R0,[R4, #+20]
        LDR      R1,[R2, #+48]
        LDRB     R3,[R2, #+20]
        LDRH     R2,[R2, #+52]
        SUBS     R0,R0,#+2
        MULS     R0,R3,R0
        LSRS     R2,R2,#+9
        MLA      R0,R0,R2,R1
        LDR      R1,[SP, #+4]
        MOVS     R2,#+512
        ADDS     R7,R0,R1
        LDR      R1,[R4, #+24]
        ADD      R0,SP,#+4
        _BLF     div,??div??rT
        ADDS     R0,R5,R6
        STR      R0,[SP, #+12]
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DFS_ReadFile_8
        MOVS     R2,#+512
        LSLS     R1,R7,#+9
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        LDR      R1,[R4, #+24]
        MOVS     R2,#+512
        ADD      R0,SP,#+4
        _BLF     div,??div??rT
        LDR      R0,[SP, #+8]
        RSBS     R0,R0,#+512
        UXTH     R0,R0
        MOV      R11,R0
        CMP      R6,R11
        BCC.N    ??DFS_ReadFile_9
        MOVS     R7,R0
        MOVS     R2,R0
        RSBS     R0,R7,#+0
        MOV      R1,R8
        ADDS     R0,R1,R0
        ADDW     R1,R0,#+512
        MOVS     R0,R5
        _BLF     memcpy,??memcpy??rT
        ADDS     R5,R5,R7
        STR      R11,[SP, #+0]
        LDR      R0,[R4, #+24]
        MOV      R1,R11
        SUBS     R6,R6,R11
        ADDS     R0,R0,R1
        STR      R0,[R4, #+24]
        B.N      ??DFS_ReadFile_3
??DFS_ReadFile_9:
        MOVS     R2,R6
        RSBS     R1,R0,#+0
        MOV      R0,R8
        ADDS     R0,R0,R1
        ADDW     R1,R0,#+512
        B.N      ??DFS_ReadFile_2
??DFS_ReadFile_8:
        LSLS     R1,R7,#+9
        CMP      R6,#+512
        BCC.W    ??DFS_ReadFile_1
        MOVS     R2,#+512
        MOVS     R0,R5
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        LDR.N    R0,??DataTable18  ;; 0xfffffffffffffe00
        ADDW     R5,R5,#+512
        ADDS     R6,R6,R0
        LDR      R0,[R4, #+24]
        ADDW     R0,R0,#+512
        STR      R0,[R4, #+24]
        MOVS     R0,#+512
        STR      R0,[SP, #+0]
        B.N      ??DFS_ReadFile_3
// 1050   }
// 1051   
// 1052   return result;
??DFS_ReadFile_7:
        MOVS     R0,#+0
        ADD      SP,SP,#+24
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock12
// 1053 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable15:
        DC32     0xff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable16:
        DC32     0xfff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable17:
        DC32     0xffffff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable18:
        DC32     0xfffffffffffffe00
// 1054 
// 1055 /*
// 1056   Seek file pointer to a given position
// 1057   This function does not return status - refer to the fileinfo->pointer value
// 1058   to see where the pointer wound up.
// 1059   Requires a SECTOR_SIZE scratch buffer
// 1060 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function DFS_Seek
        THUMB
// 1061 void DFS_Seek(PFILEINFO fileinfo, u32 offset, u8 *scratch)
// 1062 {
DFS_Seek:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        SUB      SP,SP,#+20
        CFI CFA R13+40
        MOVS     R4,R0
// 1063   u32 tempint;
// 1064 
// 1065   // larwe 9/16/06 bugfix split case 0a/0b and changed fallthrough handling
// 1066   // Case 0a - Return immediately for degenerate case
// 1067   if (offset == fileinfo->pointer) {
        LDR      R0,[R4, #+24]
        MOVS     R5,R1
        MOVS     R6,R2
        CMP      R5,R0
        BEQ.N    ??DFS_Seek_0
// 1068     return;
// 1069   }
// 1070   
// 1071   // Case 0b - Don't allow the user to seek past the end of the file
// 1072   if (offset > fileinfo->filelen) {
        LDR      R1,[R4, #+16]
        CMP      R1,R5
        IT      CC 
// 1073     offset = fileinfo->filelen;
        MOVCC    R5,R1
// 1074     // NOTE NO RETURN HERE!
// 1075   }
// 1076 
// 1077   // Case 1 - Simple rewind to start
// 1078   // Note _intentional_ fallthrough from Case 0b above
// 1079   if (offset == 0) {
        LDR      R1,[R4, #+12]
        MOVS     R7,#+0
        CBNZ     R5,??DFS_Seek_1
// 1080     fileinfo->cluster = fileinfo->firstcluster;
        STR      R1,[R4, #+20]
// 1081     fileinfo->pointer = 0;
        STR      R7,[R4, #+24]
// 1082     return;    // larwe 9/16/06 +1 bugfix
        B.N      ??DFS_Seek_0
// 1083   }
// 1084   // Case 2 - Seeking backwards. Need to reset and seek forwards
// 1085   else if (offset < fileinfo->pointer) {
??DFS_Seek_1:
        CMP      R5,R0
        ITT     CC 
// 1086     fileinfo->cluster = fileinfo->firstcluster;
        STRCC    R1,[R4, #+20]
// 1087     fileinfo->pointer = 0;
        STRCC    R7,[R4, #+24]
// 1088     // NOTE NO RETURN HERE!
// 1089   }
// 1090 
// 1091   // Case 3 - Seeking forwards
// 1092   // Note _intentional_ fallthrough from Case 2 above
// 1093 
// 1094   // Case 3a - Seek size does not cross cluster boundary - 
// 1095   // very simple case
// 1096   // larwe 9/16/06 changed .rem to .quot in both div calls, bugfix
// 1097   if (div(fileinfo->pointer, fileinfo->volinfo->secperclus * SECTOR_SIZE).quot ==
// 1098     div(fileinfo->pointer + offset, fileinfo->volinfo->secperclus * SECTOR_SIZE).quot) {
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R0,[R0, #+20]
        LSLS     R2,R0,#+9
        ADD      R0,SP,#+8
        _BLF     div,??div??rT
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+20]
        LSLS     R2,R0,#+9
        LDR      R0,[R4, #+24]
        ADDS     R1,R0,R5
        MOV      R0,SP
        _BLF     div,??div??rT
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+0]
        CMP      R0,R1
        BNE.N    ??DFS_Seek_2
// 1099     fileinfo->pointer = offset;
??DFS_Seek_3:
        STR      R5,[R4, #+24]
        B.N      ??DFS_Seek_0
// 1100   }
// 1101   // Case 3b - Seeking across cluster boundary(ies)
// 1102   else {
// 1103     // round file pointer down to cluster boundary
// 1104     fileinfo->pointer = div(fileinfo->pointer, fileinfo->volinfo->secperclus * SECTOR_SIZE).quot *
// 1105       fileinfo->volinfo->secperclus * SECTOR_SIZE;
??DFS_Seek_2:
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R0,[R0, #+20]
        LSLS     R2,R0,#+9
        MOV      R0,SP
        _BLF     div,??div??rT
        LDR      R1,[R4, #+0]
        LDR      R0,[SP, #+0]
        LDRB     R1,[R1, #+20]
        MULS     R0,R1,R0
        LSLS     R0,R0,#+9
        B.N      ??DFS_Seek_4
// 1106 
// 1107     // seek by clusters
// 1108     // larwe 9/30/06 bugfix changed .rem to .quot in both div calls
// 1109     while (div(fileinfo->pointer, fileinfo->volinfo->secperclus * SECTOR_SIZE).quot !=
// 1110       div(fileinfo->pointer + offset, fileinfo->volinfo->secperclus * SECTOR_SIZE).quot) {
// 1111 
// 1112       fileinfo->cluster = DFS_GetFAT(fileinfo->volinfo, scratch, &tempint, fileinfo->cluster);
// 1113       // Abort if there was an error
// 1114       if (fileinfo->cluster == 0x0ffffff7) {
// 1115         fileinfo->pointer = 0;
// 1116         fileinfo->cluster = fileinfo->firstcluster;
// 1117         return;
// 1118       }
// 1119       fileinfo->pointer += SECTOR_SIZE * fileinfo->volinfo->secperclus;
??DFS_Seek_5:
        LDR      R1,[R4, #+0]
        LDR      R0,[R4, #+24]
        LDRB     R1,[R1, #+20]
        ADDS     R0,R0,R1, LSL #+9
??DFS_Seek_4:
        STR      R0,[R4, #+24]
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R0,[R0, #+20]
        LSLS     R2,R0,#+9
        MOV      R0,SP
        _BLF     div,??div??rT
        LDR      R0,[R4, #+0]
        LDRB     R0,[R0, #+20]
        LSLS     R2,R0,#+9
        LDR      R0,[R4, #+24]
        ADDS     R1,R0,R5
        ADD      R0,SP,#+8
        _BLF     div,??div??rT
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BEQ.N    ??DFS_Seek_3
        LDR      R3,[R4, #+20]
        LDR      R0,[R4, #+0]
        ADD      R2,SP,#+16
        MOVS     R1,R6
        BL       DFS_GetFAT
        LDR.N    R1,??DataTable19  ;; 0xffffff7
        STR      R0,[R4, #+20]
        CMP      R0,R1
        BNE.N    ??DFS_Seek_5
        STR      R7,[R4, #+24]
        LDR      R0,[R4, #+12]
        STR      R0,[R4, #+20]
??DFS_Seek_0:
        ADD      SP,SP,#+20
        CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock13
// 1120     }
// 1121 
// 1122     // since we know the cluster is right, we have no more work to do
// 1123     fileinfo->pointer = offset;
// 1124   }
// 1125 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable19:
        DC32     0xffffff7
// 1126 
// 1127 /*
// 1128   Delete a file
// 1129   scratch must point to a sector-sized buffer
// 1130 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function DFS_UnlinkFile
        THUMB
// 1131 u32 DFS_UnlinkFile(PVOLINFO volinfo, u8 *path, u8 *scratch)
// 1132 {
DFS_UnlinkFile:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+32
        CFI CFA R13+48
        MOVS     R4,R0
// 1133   //PDIRENT de = (PDIRENT) scratch;
// 1134   FILEINFO fi;
// 1135   u32 cache = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
// 1136   u32 tempclus;
// 1137 
// 1138   // DFS_OpenFile gives us all the information we need to delete it
// 1139   if (DFS_OK != DFS_OpenFile(volinfo, path, DFS_READ, scratch, &fi))
        ADD      R0,SP,#+4
        PUSH     {R0}
        CFI CFA R13+52
        MOVS     R5,R2
        MOVS     R3,R5
        MOVS     R2,#+1
        MOVS     R0,R4
        BL       DFS_OpenFile
        ADD      SP,SP,#+4
        CFI CFA R13+48
        CBZ      R0,??DFS_UnlinkFile_0
// 1140     return DFS_NOTFOUND;
        MOVS     R0,#+3
        B.N      ??DFS_UnlinkFile_1
// 1141 
// 1142   // First, read the directory sector and delete that entry
// 1143   if (DFS_ReadSector(volinfo->unit, scratch, fi.dirsector, 1))
??DFS_UnlinkFile_0:
        LDR      R0,[SP, #+8]
        MOVS     R2,#+512
        LSLS     R1,R0,#+9
        MOVS     R0,R5
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
// 1144     return DFS_ERRMISC;
// 1145   ((PDIRENT) scratch)[fi.diroffset].name[0] = 0xe5;
        LDRB     R0,[SP, #+12]
        MOVS     R1,#+229
        LSLS     R0,R0,#+5
        STRB     R1,[R5, R0]
// 1146   if (DFS_WriteSector(volinfo->unit, scratch, fi.dirsector, 1))
        LDR      R0,[SP, #+8]
        LSLS     R6,R0,#+9
        MOVS     R1,R6
        MOVS     R0,R5
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R6,#+256
        ADDW     R0,R5,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        B.N      ??DFS_UnlinkFile_2
// 1147     return DFS_ERRMISC;
// 1148 
// 1149   // Now follow the cluster chain to free the file space
// 1150   while (!((volinfo->filesystem == FAT12 && fi.firstcluster >= 0x0ff7) ||
// 1151     (volinfo->filesystem == FAT16 && fi.firstcluster >= 0xfff7) ||
// 1152     (volinfo->filesystem == FAT32 && fi.firstcluster >= 0x0ffffff7))) {
??DFS_UnlinkFile_3:
        LDR.N    R0,??DataTable20  ;; 0xff7
        CMP      R6,R0
        BCS.N    ??DFS_UnlinkFile_4
// 1153     tempclus = fi.firstcluster;
// 1154 
// 1155     fi.firstcluster = DFS_GetFAT(volinfo, scratch, &cache, fi.firstcluster);
??DFS_UnlinkFile_5:
        MOVS     R3,R6
        MOV      R2,SP
        MOVS     R1,R5
        MOVS     R0,R4
        BL       DFS_GetFAT
// 1156     DFS_SetFAT(volinfo, scratch, &cache, tempclus, 0);
        MOVS     R3,R6
        STR      R0,[SP, #+16]
        MOVS     R0,#+0
        PUSH     {R0}
        CFI CFA R13+52
        ADD      R2,SP,#+4
        MOVS     R1,R5
        MOVS     R0,R4
        BL       DFS_SetFAT
        ADD      SP,SP,#+4
        CFI CFA R13+48
// 1157 
// 1158   }
??DFS_UnlinkFile_2:
        LDRB     R0,[R4, #+1]
        LDR      R6,[SP, #+16]
        CMP      R0,#+0
        BEQ.N    ??DFS_UnlinkFile_3
        CMP      R0,#+1
        BNE.N    ??DFS_UnlinkFile_6
        LDR.N    R0,??DataTable21  ;; 0xfff7
        CMP      R6,R0
        BCS.N    ??DFS_UnlinkFile_4
        B.N      ??DFS_UnlinkFile_5
??DFS_UnlinkFile_6:
        CMP      R0,#+2
        BNE.N    ??DFS_UnlinkFile_5
        LDR.N    R0,??DataTable29  ;; 0xffffff7
        CMP      R6,R0
        BCC.N    ??DFS_UnlinkFile_5
// 1159   return DFS_OK;
??DFS_UnlinkFile_4:
        MOVS     R0,#+0
??DFS_UnlinkFile_1:
        ADD      SP,SP,#+32
        CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        CFI EndBlock cfiBlock14
// 1160 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable20:
        DC32     0xff7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable21:
        DC32     0xfff7
// 1161 
// 1162 
// 1163 /*
// 1164   Write an open file
// 1165   You must supply a prepopulated FILEINFO as provided by DFS_OpenFile, and a
// 1166   pointer to a SECTOR_SIZE scratch buffer.
// 1167   This function updates the successcount field with the number of bytes actually written.
// 1168 */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function DFS_WriteFile
        THUMB
// 1169 u32 DFS_WriteFile(PFILEINFO fileinfo, u8 *scratch, u8 *buffer, u32 *successcount, u32 len)
// 1170 {
DFS_WriteFile:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+44
        CFI CFA R13+80
        LDR      R5,[SP, #+80]
        MOVS     R4,R0
        STR      R3,[SP, #+20]
// 1171   u32 remain;
// 1172   u32 result = DFS_OK;
// 1173   u32 sector;
// 1174   u32 byteswritten;
// 1175   
// 1176 
// 1177 
// 1178   // Don't allow writes to a file that's open as readonly
// 1179   //if (!(fileinfo->mode & DFS_WRITE))
// 1180     if(fileinfo->mode<DFS_WRITE)
        LDRB     R0,[R4, #+9]
        MOV      R8,R1
        MOVS     R6,R2
        CMP      R0,#+2
        BCS.N    ??DFS_WriteFile_0
// 1181     return DFS_ERRMISC;
??DFS_WriteFile_1:
        MOVS     R0,#-1
        B.N      ??DFS_WriteFile_2
// 1182 
// 1183   remain = len;
// 1184   *successcount = 0;
??DFS_WriteFile_0:
        MOVS     R0,#+0
        MOV      R9,R0
        STR      R9,[R3, #+0]
        B.N      ??DFS_WriteFile_3
// 1185 
// 1186   while (remain && result ==DFS_OK) {
// 1187     // This is a bit complicated. The sector we want to read is addressed at a cluster
// 1188     // granularity by the fileinfo->cluster member. The file pointer tells us how many
// 1189     // extra sectors to add to that number.
// 1190     sector = fileinfo->volinfo->dataarea +
// 1191       ((fileinfo->cluster - 2) * fileinfo->volinfo->secperclus*(fileinfo->volinfo->sectorsize/SECTOR_SIZE)) +
// 1192       div(div(fileinfo->pointer,fileinfo->volinfo->secperclus*fileinfo->volinfo->sectorsize).rem, SECTOR_SIZE).quot;
// 1193 
// 1194     // Case 1 - File pointer is not on a sector boundary
// 1195     if (div(fileinfo->pointer, SECTOR_SIZE).rem) 
// 1196     {
// 1197       u16 tempsize;
// 1198 
// 1199       // We always have to go through scratch in this case
// 1200       result = DFS_ReadSector(fileinfo->volinfo->unit, scratch, sector, 1);
// 1201 
// 1202       // This is the number of bytes that we don't want to molest in the
// 1203       // scratch sector just read.
// 1204       tempsize = div(fileinfo->pointer, SECTOR_SIZE).rem;
// 1205           
// 1206       // Case 1A - We are writing the entire remainder of the sector. After
// 1207       // this point, all passes through the read loop will be aligned on a
// 1208       // sector boundary, which allows us to go through the optimal path
// 1209       // 2A below.
// 1210          if (remain >= SECTOR_SIZE - tempsize) {
// 1211         memcpy(scratch + tempsize, buffer, SECTOR_SIZE - tempsize);
// 1212         if (!result)
// 1213           result = DFS_WriteSector(fileinfo->volinfo->unit, scratch, sector, 1);
// 1214 
// 1215         byteswritten = SECTOR_SIZE - tempsize;
// 1216         buffer += SECTOR_SIZE - tempsize;
// 1217         fileinfo->pointer += SECTOR_SIZE - tempsize;
// 1218         if (fileinfo->filelen < fileinfo->pointer) {
// 1219           fileinfo->filelen = fileinfo->pointer;
// 1220         }
// 1221         remain -= SECTOR_SIZE - tempsize;
// 1222       }
// 1223       // Case 1B - This concludes the file write operation
// 1224       else {
// 1225         memcpy(scratch + tempsize, buffer, remain);
// 1226         if (!result)
// 1227           result = DFS_WriteSector(fileinfo->volinfo->unit, scratch, sector, 1);
// 1228 
// 1229         buffer += remain;
// 1230         fileinfo->pointer += remain;
// 1231         if (fileinfo->filelen < fileinfo->pointer) {
// 1232           fileinfo->filelen = fileinfo->pointer;
// 1233         }
// 1234         byteswritten = remain;
// 1235         remain = 0;
// 1236       }
// 1237     } // case 1
// 1238     // Case 2 - File pointer is on sector boundary
// 1239     else 
// 1240     {
// 1241       // Case 2A - We have at least one more full sector to write and don't have
// 1242       // to go through the scratch buffer. You could insert optimizations here to
// 1243       // write multiple sectors at a time, if you were thus inclined. Refer to
// 1244       // similar notes in DFS_ReadFile.
// 1245       if (remain >= SECTOR_SIZE) 
// 1246       {
// 1247         result = DFS_WriteSector(fileinfo->volinfo->unit, buffer, sector, 1);
// 1248         remain -= SECTOR_SIZE;
// 1249         buffer += SECTOR_SIZE;
// 1250         fileinfo->pointer += SECTOR_SIZE;
// 1251         if (fileinfo->filelen < fileinfo->pointer) 
// 1252         {
// 1253           fileinfo->filelen = fileinfo->pointer;
// 1254         }
// 1255         byteswritten = SECTOR_SIZE;
// 1256 
// 1257       }
// 1258       // Case 2B - We are only writing a partial sector and potentially need to
// 1259       // go through the scratch buffer.
// 1260       else 
// 1261       {
// 1262         // If the current file pointer is not yet at or beyond the file
// 1263         // length, we are writing somewhere in the middle of the file and
// 1264         // need to load the original sector to do a read-modify-write.
// 1265         if (fileinfo->pointer < fileinfo->filelen) 
// 1266         {
// 1267           result = DFS_ReadSector(fileinfo->volinfo->unit, scratch, sector, 1);
// 1268           if (!result) 
// 1269           {
// 1270             memcpy(scratch, buffer, remain);
// 1271             result = DFS_WriteSector(fileinfo->volinfo->unit, scratch, sector, 1);
// 1272           }
// 1273         }
// 1274         else
// 1275        {
// 1276           result = DFS_WriteSector(fileinfo->volinfo->unit, buffer, sector, 1);
// 1277         }
// 1278 
// 1279         buffer += remain;
// 1280         fileinfo->pointer += remain;
// 1281         if (fileinfo->filelen < fileinfo->pointer) {
// 1282           fileinfo->filelen = fileinfo->pointer;
// 1283         }
// 1284         byteswritten = remain;
// 1285         remain = 0;
// 1286       }
// 1287     }
// 1288 
// 1289     *successcount += byteswritten;
// 1290 
// 1291     // check to see if we stepped over a cluster boundary*fileinfo->volinfo->sectorsize
// 1292     if (div(fileinfo->pointer - byteswritten, fileinfo->volinfo->secperclus*fileinfo->volinfo->sectorsize).quot !=
// 1293       div(fileinfo->pointer, fileinfo->volinfo->secperclus* fileinfo->volinfo->sectorsize ).quot) 
// 1294     {
// 1295         u32 lastcluster;
// 1296 
// 1297         // We've transgressed into another cluster. If we were already at EOF,
// 1298         // we need to allocate a new cluster.
// 1299       // An act of minor evil - we use byteswritten as a scratch integer, knowing
// 1300       // that its value is not used after updating *successcount above
// 1301       byteswritten = 0;
// 1302 
// 1303       lastcluster = fileinfo->cluster;
// 1304       fileinfo->cluster = DFS_GetFAT(fileinfo->volinfo, scratch, &byteswritten, fileinfo->cluster);//
// 1305       if(fileinfo->mode==DFS_WRITE)
// 1306       {
// 1307         // Allocate a new cluster?
// 1308         if (((fileinfo->volinfo->filesystem == FAT12) && (fileinfo->cluster >= 0xff8)) ||
// 1309           ((fileinfo->volinfo->filesystem == FAT16) && (fileinfo->cluster >= 0xfff8)) ||
// 1310           ((fileinfo->volinfo->filesystem == FAT32) && (fileinfo->cluster >= 0x0ffffff8)))
// 1311          {
// 1312             u32 tempclus;
// 1313   
// 1314           tempclus = DFS_GetFreeFAT(fileinfo->volinfo, scratch);
// 1315           byteswritten = 0; // invalidate cache
// 1316           if (tempclus == 0x0ffffff7)
// 1317             return DFS_ERRMISC;
// 1318   
// 1319           // Link new cluster onto file
// 1320           DFS_SetFAT(fileinfo->volinfo, scratch, &byteswritten, lastcluster, tempclus);
// 1321           fileinfo->cluster = tempclus;
// 1322   
// 1323           // Mark newly allocated cluster as end of chain      
// 1324           switch(fileinfo->volinfo->filesystem) 
// 1325         {
// 1326             case FAT12:    tempclus = 0xff8;  break;
// 1327             case FAT16:    tempclus = 0xfff8;  break;
// 1328             case FAT32:    tempclus = 0x0ffffff8;  break;
??DFS_WriteFile_4:
        LDR.N    R7,??DataTable26  ;; 0xffffff8
// 1329             default:    return DFS_ERRMISC;
// 1330           }
// 1331           DFS_SetFAT(fileinfo->volinfo, scratch, &byteswritten, fileinfo->cluster, tempclus);
??DFS_WriteFile_5:
        MOV      R1,R8
        PUSH     {R7}
        CFI CFA R13+84
        LDR      R3,[R4, #+20]
        ADD      R2,SP,#+4
        BL       DFS_SetFAT
// 1332     
// 1333           result = DFS_OK;
        ADD      SP,SP,#+4
        CFI CFA R13+80
??DFS_WriteFile_3:
        ADDW     R0,R8,#+256
        STR      R0,[SP, #+8]
        CMP      R5,#+0
        BEQ.W    ??DFS_WriteFile_6
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R2,[R0, #+20]
        LDRH     R0,[R0, #+52]
        MULS     R2,R0,R2
        ADD      R0,SP,#+28
        _BLF     div,??div??rT
        LDR      R1,[SP, #+32]
        MOVS     R2,#+512
        ADD      R0,SP,#+12
        _BLF     div,??div??rT
        LDR      R2,[R4, #+0]
        LDR      R0,[R4, #+20]
        LDR      R1,[R2, #+48]
        LDRB     R3,[R2, #+20]
        LDRH     R2,[R2, #+52]
        SUBS     R0,R0,#+2
        MULS     R0,R3,R0
        LSRS     R2,R2,#+9
        MLA      R0,R0,R2,R1
        LDR      R1,[SP, #+12]
        MOVS     R2,#+512
        ADDS     R7,R0,R1
        LDR      R1,[R4, #+24]
        ADD      R0,SP,#+12
        _BLF     div,??div??rT
        ADDS     R0,R6,R5
        STR      R0,[SP, #+24]
        LDR      R0,[SP, #+16]
        CMP      R0,#+0
        BEQ.W    ??DFS_WriteFile_7
        LSLS     R0,R7,#+9
        MOV      R10,R0
        MOVS     R2,#+512
        MOV      R1,R10
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        LDR      R1,[R4, #+24]
        MOVS     R2,#+512
        ADD      R0,SP,#+12
        _BLF     div,??div??rT
        LDR      R7,[SP, #+16]
        UXTH     R7,R7
        RSBS     R11,R7,#+512
        CMP      R5,R11
        BCC.N    ??DFS_WriteFile_8
        MOV      R2,R11
        MOVS     R1,R6
        MOV      R3,R8
        ADDS     R0,R3,R7
        _BLF     memcpy,??memcpy??rT
        MOV      R0,R8
        STR      R10,[SP, #+4]
        LDR      R1,[SP, #+4]
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[SP, #+4]
        ADDW     R1,R0,#+256
        LDR      R0,[SP, #+8]
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        RSBS     R0,R7,#+0
        STR      R11,[SP, #+0]
        ADDS     R0,R6,R0
        ADDW     R6,R0,#+512
        LDR      R0,[R4, #+24]
        ADDS     R0,R11,R0
        STR      R0,[R4, #+24]
        LDR      R1,[R4, #+16]
        CMP      R1,R0
        IT      CC 
        STRCC    R0,[R4, #+16]
        SUBS     R5,R5,R11
??DFS_WriteFile_9:
        LDR      R0,[SP, #+20]
        LDR      R2,[SP, #+0]
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,R2
        STR      R1,[R0, #+0]
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+0]
        LDRB     R2,[R0, #+20]
        LDRH     R0,[R0, #+52]
        MULS     R2,R0,R2
        LDR      R0,[R4, #+24]
        SUBS     R1,R0,R1
        ADD      R0,SP,#+12
        _BLF     div,??div??rT
        LDR      R0,[R4, #+0]
        LDR      R1,[R4, #+24]
        LDRB     R2,[R0, #+20]
        LDRH     R0,[R0, #+52]
        MULS     R2,R0,R2
        ADD      R0,SP,#+28
        _BLF     div,??div??rT
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+28]
        CMP      R0,R1
        BEQ.N    ??DFS_WriteFile_3
        STR      R9,[SP, #+0]
        LDR      R3,[R4, #+20]
        MOV      R2,SP
        MOV      R1,R8
        STR      R3,[SP, #+40]
        LDR      R0,[R4, #+0]
        BL       DFS_GetFAT
        STR      R0,[R4, #+20]
        LDRB     R0,[R4, #+9]
        CMP      R0,#+2
        BNE.W    ??DFS_WriteFile_3
        LDR      R0,[R4, #+0]
        LDR.N    R2,??DataTable24  ;; 0xfff8
        LDR      R1,[R4, #+20]
        MOV      R11,R2
        LDRB     R2,[R0, #+1]
        CBNZ     R2,??DFS_WriteFile_10
        LDR.N    R2,??DataTable30  ;; 0xff8
        CMP      R1,R2
        BCS.N    ??DFS_WriteFile_11
??DFS_WriteFile_10:
        LDRB     R2,[R0, #+1]
        CMP      R2,#+1
        BNE.N    ??DFS_WriteFile_12
        CMP      R1,R11
        BCS.N    ??DFS_WriteFile_11
??DFS_WriteFile_12:
        CMP      R2,#+2
        BNE.W    ??DFS_WriteFile_3
        LDR.N    R2,??DataTable26  ;; 0xffffff8
        CMP      R1,R2
        BCC.W    ??DFS_WriteFile_3
??DFS_WriteFile_11:
        STR      R0,[SP, #+4]
        STR      R9,[SP, #+36]
        MOVS     R7,#+2
        B.N      ??DFS_WriteFile_13
??DFS_WriteFile_8:
        MOVS     R2,R5
        MOVS     R1,R6
        MOV      R0,R8
        ADDS     R0,R0,R7
        _BLF     memcpy,??memcpy??rT
        MOV      R6,R10
        MOVS     R1,R6
        MOV      R0,R8
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[SP, #+8]
        ADDW     R1,R6,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[R4, #+24]
        LDR      R6,[SP, #+24]
        ADDS     R0,R0,R5
        STR      R0,[R4, #+24]
        LDR      R1,[R4, #+16]
        CMP      R1,R0
        IT      CC 
        STRCC    R0,[R4, #+16]
??DFS_WriteFile_14:
        STR      R5,[SP, #+0]
        MOVS     R5,#+0
        B.N      ??DFS_WriteFile_9
??DFS_WriteFile_7:
        LSLS     R0,R7,#+9
        MOV      R10,R0
        CMP      R5,#+512
        BCC.N    ??DFS_WriteFile_15
        MOV      R7,R10
        MOVS     R1,R7
        MOVS     R0,R6
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R7,#+256
        ADDW     R0,R6,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR.N    R0,??DataTable27  ;; 0xfffffffffffffe00
        ADDW     R6,R6,#+512
        ADDS     R5,R5,R0
        LDR      R0,[R4, #+24]
        ADDW     R0,R0,#+512
        STR      R0,[R4, #+24]
        LDR      R1,[R4, #+16]
        CMP      R1,R0
        IT      CC 
        STRCC    R0,[R4, #+16]
        MOVS     R0,#+512
        STR      R0,[SP, #+0]
        B.N      ??DFS_WriteFile_9
??DFS_WriteFile_15:
        LDR      R0,[R4, #+24]
        LDR      R1,[R4, #+16]
        CMP      R0,R1
        BCS.N    ??DFS_WriteFile_16
        MOVS     R2,#+512
        MOV      R1,R10
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
        MOVS     R2,R5
        MOVS     R1,R6
        MOV      R0,R8
        _BLF     memcpy,??memcpy??rT
        MOV      R6,R10
        MOVS     R1,R6
        MOV      R0,R8
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[SP, #+8]
        ADDW     R1,R6,#+256
        B.N      ??DFS_WriteFile_17
??DFS_WriteFile_16:
        MOV      R7,R10
        MOVS     R1,R7
        MOVS     R0,R6
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        ADDW     R1,R7,#+256
        ADDW     R0,R6,#+256
??DFS_WriteFile_17:
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[R4, #+24]
        LDR      R6,[SP, #+24]
        ADDS     R0,R0,R5
        STR      R0,[R4, #+24]
        LDR      R1,[R4, #+16]
        CMP      R1,R0
        BCS.N    ??DFS_WriteFile_14
        STR      R0,[R4, #+16]
        B.N      ??DFS_WriteFile_14
??DFS_WriteFile_18:
        ADDS     R7,R7,#+1
??DFS_WriteFile_13:
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+36]
        CMP      R7,R0
        BCS.N    ??DFS_WriteFile_19
        LDR      R0,[SP, #+4]
        MOVS     R3,R7
        ADD      R2,SP,#+36
        MOV      R1,R8
        BL       DFS_GetFAT
        CMP      R0,#+0
        BNE.N    ??DFS_WriteFile_18
        B.N      ??DFS_WriteFile_20
??DFS_WriteFile_19:
        LDR.N    R7,??DataTable29  ;; 0xffffff7
??DFS_WriteFile_20:
        LDR.N    R0,??DataTable29  ;; 0xffffff7
        STR      R9,[SP, #+0]
        CMP      R7,R0
        BEQ.W    ??DFS_WriteFile_1
        PUSH     {R7}
        CFI CFA R13+84
        LDR      R3,[SP, #+44]
        LDR      R0,[R4, #+0]
        ADD      R2,SP,#+4
        MOV      R1,R8
        BL       DFS_SetFAT
        STR      R7,[R4, #+20]
        LDR      R0,[R4, #+0]
        LDRB     R1,[R0, #+1]
        ADD      SP,SP,#+4
        CFI CFA R13+80
        CBZ      R1,??DFS_WriteFile_21
        CMP      R1,#+1
        BEQ.N    ??DFS_WriteFile_22
        CMP      R1,#+2
        BEQ.W    ??DFS_WriteFile_4
        B.N      ??DFS_WriteFile_1
??DFS_WriteFile_21:
        LDR.N    R7,??DataTable30  ;; 0xff8
        B.N      ??DFS_WriteFile_5
??DFS_WriteFile_22:
        MOV      R7,R11
        B.N      ??DFS_WriteFile_5
// 1334         }
// 1335         else 
// 1336           result = DFS_OK;
// 1337         }
// 1338       // No else clause is required.
// 1339     }
// 1340   };//while end
// 1341 
// 1342 
// 1343     if (DFS_ReadSector(fileinfo->volinfo->unit, scratch, fileinfo->dirsector, 1))
??DFS_WriteFile_6:
        LDR      R0,[R4, #+4]
        MOVS     R2,#+512
        LSLS     R1,R0,#+9
        MOV      R0,R8
        _BLF     __Disk_Buff_RD,??__Disk_Buff_RD??rT
// 1344       return DFS_ERRMISC;
// 1345 
// 1346     ((PDIRENT) scratch)[fileinfo->diroffset].filesize_0 = fileinfo->filelen & 0xff;
        LDRB     R0,[R4, #+8]
        LDR      R1,[R4, #+16]
        ADDS     R0,R8,R0, LSL #+5
        STRB     R1,[R0, #+28]
// 1347     ((PDIRENT) scratch)[fileinfo->diroffset].filesize_1 = (fileinfo->filelen & 0xff00) >> 8;
        LDRB     R0,[R4, #+8]
        LDR      R1,[R4, #+16]
        ADDS     R0,R8,R0, LSL #+5
        LSRS     R1,R1,#+8
        STRB     R1,[R0, #+29]
// 1348     ((PDIRENT) scratch)[fileinfo->diroffset].filesize_2 = (fileinfo->filelen & 0xff0000) >> 16;
        LDRB     R0,[R4, #+8]
        LDR      R1,[R4, #+16]
        ADDS     R0,R8,R0, LSL #+5
        LSRS     R1,R1,#+16
        STRB     R1,[R0, #+30]
// 1349     ((PDIRENT) scratch)[fileinfo->diroffset].filesize_3 = (fileinfo->filelen & 0xff000000) >> 24;
        LDRB     R0,[R4, #+8]
        LDR      R1,[R4, #+16]
        ADDS     R0,R8,R0, LSL #+5
        LSRS     R1,R1,#+24
        STRB     R1,[R0, #+31]
// 1350     if (DFS_WriteSector(fileinfo->volinfo->unit, scratch, fileinfo->dirsector, 1))
        LDR      R0,[R4, #+4]
        LSLS     R4,R0,#+9
        MOVS     R1,R4
        MOV      R0,R8
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
        LDR      R0,[SP, #+8]
        ADDW     R1,R4,#+256
        _BLF     __Disk_Buff_WR,??__Disk_Buff_WR??rT
// 1351       return DFS_ERRMISC;
// 1352 
// 1353   return result;
        MOVS     R0,#+0
??DFS_WriteFile_2:
        ADD      SP,SP,#+44
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock15
// 1354 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable24:
        DC32     0xfff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable26:
        DC32     0xffffff8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable27:
        DC32     0xfffffffffffffe00

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable29:
        DC32     0xffffff7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable30:
        DC32     0xff8

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Disk_Buff_RD??rT:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine0_0  ;; __Disk_Buff_RD
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine0_0:
        DC32     __Disk_Buff_RD
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Disk_Buff_WR??rT:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine1_0  ;; __Disk_Buff_WR
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine1_0:
        DC32     __Disk_Buff_WR
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??memcpy??rT:
        LDR.N    R3,??Subroutine2_0  ;; memcpy
        BX       R3
        DATA
??Subroutine2_0:
        DC32     memcpy
        CFI EndBlock cfiBlock18

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon0
        CFI NoFunction
        THUMB
??ldiv??rT:
        LDR.N    R3,??Subroutine3_0  ;; ldiv
        BX       R3
        DATA
??Subroutine3_0:
        DC32     ldiv
        CFI EndBlock cfiBlock19

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??memset??rT:
        LDR.N    R3,??Subroutine4_0  ;; memset
        BX       R3
        DATA
??Subroutine4_0:
        DC32     memset
        CFI EndBlock cfiBlock20

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon0
        CFI NoFunction
        THUMB
??strlen??rT:
        LDR.N    R3,??Subroutine5_0  ;; strlen
        BX       R3
        DATA
??Subroutine5_0:
        DC32     strlen
        CFI EndBlock cfiBlock21

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??memcmp??rT:
        LDR.N    R3,??Subroutine6_0  ;; memcmp
        BX       R3
        DATA
??Subroutine6_0:
        DC32     memcmp
        CFI EndBlock cfiBlock22

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon0
        CFI NoFunction
        THUMB
??strncpy??rT:
        LDR.N    R3,??Subroutine7_0  ;; strncpy
        BX       R3
        DATA
??Subroutine7_0:
        DC32     strncpy
        CFI EndBlock cfiBlock23

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??strcmp??rT:
        LDR.N    R3,??Subroutine8_0  ;; strcmp
        BX       R3
        DATA
??Subroutine8_0:
        DC32     strcmp
        CFI EndBlock cfiBlock24

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon0
        CFI NoFunction
        THUMB
??strcpy??rT:
        LDR.N    R3,??Subroutine9_0  ;; strcpy
        BX       R3
        DATA
??Subroutine9_0:
        DC32     strcpy
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??div??rT:
        LDR.N    R3,??Subroutine10_0  ;; div
        BX       R3
        DATA
??Subroutine10_0:
        DC32     div
        CFI EndBlock cfiBlock26

        END
// 1355 
// 
// 4 796 bytes in segment CODE
// 
// 4 692 bytes of CODE memory (+ 104 bytes shared)
//
//Errors: none
//Warnings: 2
